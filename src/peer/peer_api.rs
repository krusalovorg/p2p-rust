use crate::connection::Connection;
use crate::crypto::token::get_metadata_from_token;
use crate::db::P2PDatabase;
use crate::manager::ConnectionManager::ConnectionManager;
use crate::packets::{
    EncryptedData, Message, PeerFileAccessChange, PeerFileDelete, PeerFileGet, PeerFileMove,
    PeerSearchRequest, PeerUploadFile, PeerWaitConnection, Protocol, SearchPathNode,
    StorageReservationRequest, StorageValidTokenRequest, TransportData, TransportPacket,
};
use crate::tunnel::Tunnel;
use colored::Colorize;
use hex;
use mime_guess;
use sha2::{Digest, Sha256};
use std::sync::Arc;

use flate2::write::GzEncoder;
use flate2::Compression;
use std::io;
use std::io::Write;
use std::path::Path;

#[derive(Debug)]
pub enum UploadError {
    FileNotFound(String),
    NoTokensAvailable,
    InsufficientSpace { required: u64, available: u64 },
    DatabaseError(String),
    IoError(String),
}

impl std::fmt::Display for UploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UploadError::FileNotFound(path) => write!(f, "Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {}", path),
            UploadError::NoTokensAvailable => write!(f, "ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ reserve Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ‚Ğ¾ĞºĞµĞ½Ğ°."),
            UploadError::InsufficientSpace { required, available } => write!(
                f,
                "ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¼ĞµÑÑ‚Ğ° Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°. Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ: {} Ğ±Ğ°Ğ¹Ñ‚, Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾: {} Ğ±Ğ°Ğ¹Ñ‚. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ reserve Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑÑ‚Ğ°.",
                required, available
            ),
            UploadError::DatabaseError(e) => write!(f, "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {}", e),
            UploadError::IoError(e) => write!(f, "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ²Ğ²Ğ¾Ğ´Ğ°/Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°: {}", e),
        }
    }
}

impl std::error::Error for UploadError {}

#[derive(Clone)]
pub struct PeerAPI {
    connection: Arc<Connection>,
    db: Arc<P2PDatabase>,
    manager: Arc<ConnectionManager>,
}

impl PeerAPI {
    pub fn new(connection: Arc<Connection>, db: &P2PDatabase, manager: &ConnectionManager) -> Self {
        PeerAPI {
            connection,
            db: Arc::new(db.clone()),
            manager: Arc::new(manager.clone()),
        }
    }

    pub async fn get_file(&self, identifier: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files
            .iter()
            .find(|f| f.filename == identifier || f.file_hash == identifier);

        if file.is_none() {
            return Err(format!("Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {}", identifier));
        }
        let file = file.unwrap();
        let token = file.token.clone();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "get_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileGet(PeerFileGet {
                token: Some(token),
                peer_id: my_peer_id.clone(),
                file_hash: file.file_hash.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    fn clean_file_path(path: &str, root_dir: &str) -> String {
        let path = Path::new(path);
        let root = Path::new(root_dir);

        if let Ok(relative) = path.strip_prefix(root) {
            relative.to_string_lossy().replace('\\', "/")
        } else {
            path.file_name()
                .unwrap_or_else(|| path.as_os_str())
                .to_string_lossy()
                .to_string()
        }
    }

    pub async fn upload_file(
        &self,
        file_path: String,
        encrypt: bool,
        public: bool,
        auto_decompress: bool,
        root_dir: &str,
    ) -> Result<(), UploadError> {
        println!("Uploading file: {}", file_path);
        let file_size = tokio::fs::metadata(&file_path)
            .await
            .map_err(|e| UploadError::FileNotFound(e.to_string()))?
            .len();

        println!("File size: {}", file_size);

        let (owner_peer_id, token_info) = self
            .db
            .get_best_token(file_size)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?
            .ok_or(UploadError::NoTokensAvailable)?;

        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ·Ğ°Ğ½ÑÑ‚Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾ Ğ² Ñ‚Ğ¾ĞºĞµĞ½Ğµ
        let used_space = self
            .db
            .get_token_used_space(&owner_peer_id)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        if used_space + file_size > token_info.free_space {
            return Err(UploadError::InsufficientSpace {
                required: file_size,
                available: token_info.free_space - used_space,
            });
        }

        println!("Owner peer id: {}", owner_peer_id);
        println!("Token info: {}", token_info.token);
        println!("Used space: {} / {}", used_space, token_info.free_space);

        let metadata = get_metadata_from_token(token_info.token.clone()).await;

        let token_provider = metadata.unwrap().storage_provider;

        if !self
            .manager
            .have_connection_with_peer(token_provider.clone())
            .await
        {
            self.connect_to_peer(token_provider.clone())
                .await
                .map_err(|e| UploadError::IoError(format!("Failed to connect to peer: {}", e)))?;

            let mut attempts = 0;
            let max_attempts = 30;

            while attempts < max_attempts {
                if self
                    .manager
                    .have_connection_with_peer(token_provider.clone())
                    .await
                {
                    break;
                }
                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                attempts += 1;
            }

            if attempts >= max_attempts {
                return Err(UploadError::IoError(
                    "Failed to establish connection with peer".to_string(),
                ));
            }
        }

        // â¬ Ğ¡Ğ¶Ğ°Ñ‚Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°
        let contents = tokio::fs::read(&file_path)
            .await
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder
            .write_all(&contents)
            .map_err(|e| UploadError::IoError(e.to_string()))?;
        let compressed_contents = encoder
            .finish()
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        println!("Compressed size: {}", compressed_contents.len());

        let (final_content, encrypted) = if encrypt {
            // â¬ Ğ¨Ğ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°
            let encrypted_contents = self
                .db
                .encrypt_data(&compressed_contents)
                .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

            let content = serde_json::to_string(&EncryptedData {
                nonce: encrypted_contents.1,
                content: encrypted_contents.0,
            })
            .unwrap();
            (base64::encode(content.to_string().as_bytes()), true)
        } else {
            (base64::encode(compressed_contents), false)
        };

        let my_peer_id = self
            .db
            .get_or_create_peer_id()
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        let file_hash = hex::encode(Sha256::digest(final_content.to_string().as_bytes()));
        let mime = mime_guess::from_path(file_path.clone()).first_or_text_plain();

        let packet = TransportPacket {
            act: "save_file".to_string(),
            to: Some(token_provider),
            data: Some(TransportData::PeerUploadFile(PeerUploadFile {
                filename: Self::clean_file_path(&file_path, root_dir),
                contents: final_content,
                peer_id: my_peer_id.clone(),
                token: token_info.token,
                file_hash: file_hash,
                mime: mime.to_string(),
                public,
                encrypted,
                compressed: true,
                auto_decompress,
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection
            .send_packet(packet)
            .await
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ¼ĞµÑÑ‚Ğ¾ Ğ² Ñ‚Ğ¾ĞºĞµĞ½Ğµ
        self.db
            .update_token_used_space(&owner_peer_id, used_space + file_size)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        Ok(())
    }

    pub async fn upload_file_default(&self, file_path: String) -> Result<(), UploadError> {
        self.upload_file(file_path, true, false, false, "")
            .await
    }

    pub async fn send_message(&self, peer_id: String, message: String) -> Result<(), String> {
        let packet = TransportPacket {
            act: "message".to_string(),
            to: Some(peer_id),
            data: Some(TransportData::Message(Message {
                text: message,
                nonce: None,
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn connect_to_peer(&self, peer_id: String) -> Result<(), String> {
        let tunnel = Tunnel::new().await;
        let tunnel_ip = tunnel.public_ip.clone();
        let tunnel_port = tunnel.public_port.clone();
        self.manager.add_tunnel(peer_id.to_string(), tunnel).await;
        let packet = TransportPacket {
            act: "wait_connection".to_string(),
            to: None,
            data: Some(TransportData::PeerWaitConnection(PeerWaitConnection {
                connect_peer_id: peer_id,
                public_port: tunnel_port,
                public_ip: tunnel_ip,
            })),
            protocol: Protocol::STUN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn request_peer_list(&self) -> Result<(), String> {
        let packet = TransportPacket {
            act: "peer_list".to_string(),
            to: None,
            data: None,
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };
        println!("{}", format!("[Peer] Sending peer list to signal server"));
        self.connection.send_packet(packet).await
    }

    pub async fn reserve_storage(&self, size_in_bytes: u64) -> Result<(), String> {
        let packet = TransportPacket {
            act: "reserve_storage".to_string(),
            to: None,
            data: Some(TransportData::StorageReservationRequest(
                StorageReservationRequest {
                    peer_id: self.db.get_or_create_peer_id().unwrap(),
                    size_in_bytes,
                },
            )),
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn valid_token(&self, token: String) -> Result<(), String> {
        let metadata = get_metadata_from_token(token.clone().to_string()).await;

        if let Ok(metadata) = metadata {
            let packet = TransportPacket {
                act: "valid_token".to_string(),
                to: Some(metadata.storage_provider),
                data: Some(TransportData::StorageValidTokenRequest(
                    StorageValidTokenRequest {
                        token: token.clone(),
                        peer_id: self.db.get_or_create_peer_id().unwrap(),
                    },
                )),
                protocol: Protocol::SIGNAL,
                uuid: self.db.get_or_create_peer_id().unwrap(),
                nodes: vec![],
            };

            self.connection.send_packet(packet).await
        } else {
            Err("Invalid token".to_string())
        }
    }

    pub async fn search_peer(&self, peer_id: String) -> Result<(), String> {
        let packet = TransportPacket {
            act: "search_peer".to_string(),
            to: None,
            data: Some(TransportData::PeerSearchRequest(PeerSearchRequest {
                peer_id: self.db.get_or_create_peer_id().unwrap(),
                search_id: peer_id,
                max_hops: 3,
                path: vec![SearchPathNode {
                    uuid: self.db.get_or_create_peer_id().unwrap(),
                    public_ip: self.connection.ip.clone(),
                    public_port: self.connection.port.clone(),
                }],
            })),
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn change_file_public_access(
        &self,
        file_hash: String,
        public: bool,
    ) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "change_file_access".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileAccessChange(PeerFileAccessChange {
                file_hash,
                public,
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn delete_file(&self, file_hash: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "delete_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileDelete(PeerFileDelete {
                file_hash,
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn move_file(&self, file_hash: String, new_path: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸Ğ¼Ñ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ¸Ğ· Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿ÑƒÑ‚Ğ¸
        let current_filename = std::path::Path::new(&file.filename)
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or(&file.filename);

        // Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸ĞµĞ¼ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°
        let new_path = if new_path.ends_with('/') || new_path.ends_with('\\') {
            format!("{}{}", new_path, current_filename)
        } else {
            format!("{}/{}", new_path, current_filename)
        };

        let packet = TransportPacket {
            act: "move_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileMove(PeerFileMove {
                file_hash: file_hash.clone(),
                new_path: new_path.clone(),
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await?;

        self.db
            .update_fragment_path(&file_hash, &new_path)
            .map_err(|e| format!("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {}", e))?;

        Ok(())
    }

    pub async fn virtual_storage(&self) -> Result<(), String> {
        let files = self
            .db
            .get_my_fragments()
            .map_err(|e| format!("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ ÑĞ¿Ğ¸ÑĞºĞ° Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {}", e))?;

        // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ¿Ğ¾ Ğ¿ÑƒÑ‚ÑĞ¼
        let mut file_tree: std::collections::HashMap<String, Vec<(String, String)>> =
            std::collections::HashMap::new();

        for file in files {
            let path = std::path::Path::new(&file.filename);
            let parent = path.parent().and_then(|p| p.to_str()).unwrap_or("/");

            file_tree
                .entry(parent.to_string())
                .or_insert_with(Vec::new)
                .push((
                    path.file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or(&file.filename)
                        .to_string(),
                    file.file_hash,
                ));
        }

        // Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ğ´ĞµÑ€ĞµĞ²Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²
        println!(
            "\n{}",
            "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—".cyan()
        );
        println!(
            "{}",
            "â•‘                    Ğ’Ğ˜Ğ Ğ¢Ğ£ĞĞ›Ğ¬ĞĞĞ• Ğ¥Ğ ĞĞĞ˜Ğ›Ğ˜Ğ©Ğ•                   â•‘".cyan()
        );
        println!(
            "{}",
            "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£".cyan()
        );

        for (path, files) in file_tree.iter() {
            println!("{}", format!("â•‘ ğŸ“ {}", path).cyan());
            for (filename, hash) in files {
                println!("{}", format!("â•‘   â””â”€ {} ({})", filename, hash).white());
            }
        }

        println!(
            "{}",
            "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".cyan()
        );
        println!("\n{}", "Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:".yellow());
        println!(
            "{}",
            "  â€¢ move <hash> <new_path> - Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»".white()
        );
        println!("{}", "  â€¢ delete <hash> - ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»".white());
        println!("{}", "  â€¢ public <hash> - ÑĞ´ĞµĞ»Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ» Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼".white());
        println!("{}", "  â€¢ private <hash> - ÑĞ´ĞµĞ»Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ» Ğ¿Ñ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ñ‹Ğ¼".white());
        println!("{}", "  â€¢ exit - Ğ²Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· Ğ²Ğ¸Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°".white());

        Ok(())
    }

    pub async fn virtual_storage_interactive(&self) -> Result<(), String> {
        use std::io::{self, Write};

        loop {
            // ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğ°
            self.virtual_storage().await?;

            print!("\n{}", "virtual_storage> ".green());
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut input = String::new();
            io::stdin()
                .read_line(&mut input)
                .map_err(|e| e.to_string())?;
            let input = input.trim();

            if input == "exit" {
                break;
            }

            let parts: Vec<&str> = input.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }

            match parts[0] {
                "move" => {
                    if parts.len() != 3 {
                        println!("{}", "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: move <hash> <new_path>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .move_file(parts[1].to_string(), parts[2].to_string())
                        .await
                    {
                        println!("{}", format!("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°: {}", e).red());
                    } else {
                        println!("{}", "Ğ¤Ğ°Ğ¹Ğ» ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½".green());
                    }
                }
                "delete" => {
                    if parts.len() != 2 {
                        println!("{}", "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: delete <hash>".red());
                        continue;
                    }
                    if let Err(e) = self.delete_file(parts[1].to_string()).await {
                        println!("{}", format!("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°: {}", e).red());
                    } else {
                        println!("{}", "Ğ¤Ğ°Ğ¹Ğ» ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ´Ğ°Ğ»ĞµĞ½".green());
                    }
                }
                "public" => {
                    if parts.len() != 2 {
                        println!("{}", "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: public <hash>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .change_file_public_access(parts[1].to_string(), true)
                        .await
                    {
                        println!("{}", format!("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°: {}", e).red());
                    } else {
                        println!("{}", "Ğ¤Ğ°Ğ¹Ğ» ÑĞ´ĞµĞ»Ğ°Ğ½ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğ¼".green());
                    }
                }
                "private" => {
                    if parts.len() != 2 {
                        println!("{}", "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: private <hash>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .change_file_public_access(parts[1].to_string(), false)
                        .await
                    {
                        println!("{}", format!("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°: {}", e).red());
                    } else {
                        println!("{}", "Ğ¤Ğ°Ğ¹Ğ» ÑĞ´ĞµĞ»Ğ°Ğ½ Ğ¿Ñ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ñ‹Ğ¼".green());
                    }
                }
                _ => {
                    println!(
                        "{}",
                        "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ help Ğ´Ğ»Ñ ÑĞ¿Ğ¸ÑĞºĞ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´.".red()
                    );
                }
            }
        }

        Ok(())
    }

    fn collect_files_recursively(
        &self,
        dir_path: &std::path::Path,
        files: &mut Vec<String>,
    ) -> Result<(), UploadError> {
        for entry in std::fs::read_dir(dir_path).map_err(|e| UploadError::IoError(e.to_string()))? {
            let entry = entry.map_err(|e| UploadError::IoError(e.to_string()))?;
            let path = entry.path();

            if path.is_file() {
                files.push(path.to_string_lossy().to_string());
            } else if path.is_dir() {
                self.collect_files_recursively(&path, files)?;
            }
        }
        Ok(())
    }

    pub async fn upload_directory(
        &self,
        dir_path: String,
        encrypt: bool,
        public: bool,
        auto_decompress: bool,
    ) -> Result<(), UploadError> {
        let path = std::path::Path::new(&dir_path);
        if !path.is_dir() {
            return Err(UploadError::FileNotFound(
                "Ğ£ĞºĞ°Ğ·Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ Ğ½Ğµ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸ĞµĞ¹".to_string(),
            ));
        }

        let mut files = Vec::new();
        self.collect_files_recursively(path, &mut files)?;

        if files.is_empty() {
            return Err(UploadError::FileNotFound("Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¿ÑƒÑÑ‚Ğ°".to_string()));
        }

        println!(
            "{}",
            format!("ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸: {}", files.len()).cyan()
        );

        for (i, file) in files.iter().enumerate() {
            println!(
                "{}",
                format!("Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ñ„Ğ°Ğ¹Ğ»Ğ° {}/{}: {}", i + 1, files.len(), file).yellow()
            );
            if let Err(e) = self
                .upload_file(file.clone(), encrypt, public, auto_decompress, &dir_path)
                .await
            {
                println!(
                    "{}",
                    format!("ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞµ Ñ„Ğ°Ğ¹Ğ»Ğ° {}: {}", file, e).red()
                );
            } else {
                println!("{}", format!("Ğ¤Ğ°Ğ¹Ğ» {} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½", file).green());
            }
        }

        Ok(())
    }
}
