

=== ../src\config.rs ===
use std::fs;
use toml;
use serde::Deserialize;

#[derive(Debug, Deserialize, Clone)]
pub struct Config {
    pub signal_server_ip: String,
    pub signal_server_port: i64,
    pub storage_size: u64,
    pub proxy_ip: String,
    pub proxy_port: u16,
}

impl Config {
    pub fn from_file(file_path: &str) -> Self {
        let config_str = fs::read_to_string(file_path).expect("Failed to read config file");
        let config: toml::Value = toml::from_str(&config_str).expect("Failed to parse config file");
        Self {
            signal_server_ip: config["signal_server_ip"].as_str().unwrap().to_string(),
            signal_server_port: config["signal_server_port"].as_integer().unwrap(),
            storage_size: config["storage_size"].as_integer().unwrap() as u64,
            proxy_ip: config["proxy_ip"].as_str().unwrap().to_string(),
            proxy_port: config["proxy_port"].as_integer().unwrap() as u16,
        }
    }
}

=== ../src\connection.rs ===
use std::sync::Arc;
use std::time::Duration;

use tokio::io::{split, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::{mpsc, oneshot, RwLock};
use tokio::task;
use tokio::time::sleep;

use crate::crypto::crypto::generate_uuid;
use crate::packets::{Protocol, TransportPacket, TransportData, PeerInfo};
use crate::db::P2PDatabase;

const SHOW_LOGS: bool = false;

fn log(message: &str) {
    if SHOW_LOGS {
        println!("{}", message);
    }
}

#[derive(Debug)]
pub enum Message {
    SendData(TransportPacket),
    GetResponse {
        tx: oneshot::Sender<TransportPacket>,
    },
}

#[derive(Clone)]
pub struct Connection {
    pub tx: mpsc::Sender<Message>,
    writer: Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
    reader: Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>,
    pub ip: String,
    pub port: i64,
    db: Arc<P2PDatabase>,
    reconnect_attempts: Arc<RwLock<i32>>,
    max_reconnect_attempts: i32,
}

impl Connection {
    pub async fn new(
        signal_server_ip: String,
        signal_server_port: i64,
        db: &P2PDatabase,
    ) -> Connection {
        let (tx, rx) = mpsc::channel(1024);
        let reconnect_attempts = Arc::new(RwLock::new(0));
        let max_reconnect_attempts = 10;

        let connection = Self::establish_connection(
            &signal_server_ip,
            signal_server_port,
            db,
            tx.clone(),
            rx,
            reconnect_attempts.clone(),
            max_reconnect_attempts,
        ).await;

        connection
    }

    async fn establish_connection(
        signal_server_ip: &str,
        signal_server_port: i64,
        db: &P2PDatabase,
        tx: mpsc::Sender<Message>,
        rx: mpsc::Receiver<Message>,
        reconnect_attempts: Arc<RwLock<i32>>,
        max_reconnect_attempts: i32,
    ) -> Connection {
        let mut attempts = 0;
        let mut stream = None;

        while attempts < max_reconnect_attempts {
            match TcpStream::connect(format!("{}:{}", signal_server_ip, signal_server_port)).await {
                Ok(s) => {
                    stream = Some(s);
                    break;
                }
                Err(e) => {
                    log(&format!("[Connection] Failed to connect (attempt {}/{}): {}", 
                        attempts + 1, max_reconnect_attempts, e));
                    attempts += 1;
                    if attempts < max_reconnect_attempts {
                        sleep(Duration::from_secs(5)).await;
                    }
                }
            }
        }

        let stream = stream.expect("Failed to establish connection after maximum attempts");
        let (reader, writer) = split(stream);

        let reader = Arc::new(RwLock::new(reader));
        let writer = Arc::new(RwLock::new(writer));

        let connect_packet = TransportPacket {
            act: "info".to_string(),
            to: None,
            data: Some(
                TransportData::PeerInfo(PeerInfo {
                    is_signal_server: false,
                    total_space: db.get_storage_size().await.unwrap_or(0),
                    free_space: db.get_storage_free_space().await.unwrap_or(0),
                    stored_files: Vec::new(),
                    public_key: db.get_or_create_peer_id().unwrap(),
                }),
            ),
            protocol: Protocol::SIGNAL,
            peer_key: db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        if let Err(e) = Self::write_packet(&writer, &connect_packet).await {
            log(&format!("[Connection] Failed to send connect packet: {}", e));
        } else {
            log("[Connection] Connect packet sent successfully");
        }

        task::spawn(Self::process_messages(
            tx.clone(),
            rx,
            reader.clone(),
            writer.clone(),
            Arc::new(db.clone()),
        ));

        Connection { 
            tx, 
            writer, 
            reader,
            ip: signal_server_ip.to_string(),
            port: signal_server_port,
            db: Arc::new(db.clone()),
            reconnect_attempts,
            max_reconnect_attempts,
        }
    }
    
    async fn write_packet(
        writer: &Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
        packet: &TransportPacket,
    ) -> Result<(), String> {
        let packet_str = serde_json::to_string(&packet).unwrap();
        let packet_len = packet_str.len() as u32;
        let mut writer = writer.write().await;

        // Отправляем длину сообщения (4 байта)
        let len_bytes = packet_len.to_be_bytes();
        if let Err(e) = writer.write_all(&len_bytes).await {
            return Err(format!("Failed to send packet length: {}", e));
        }

        // Отправляем само сообщение
        match writer.write_all(packet_str.as_bytes()).await {
            Ok(_) => {
                log("[Connection] Packet sent successfully");
                Ok(())
            }
            Err(e) => {
                log(&format!("[Connection] Failed to send packet: {}", e));
                Err(e.to_string())
            }
        }
    }

    async fn process_messages(
        tx: mpsc::Sender<Message>,
        mut rx: mpsc::Receiver<Message>,
        reader: Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>,
        writer: Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
        db: Arc<P2PDatabase>,
    ) {
        log("[Connection] Processing messages started");

        sleep(Duration::from_millis(100)).await;

        match Self::send_peer_info_request(&writer, &db).await {
            Ok(_) => log("[Connection] Peer info request sent successfully"),
            Err(e) => {
                log(&format!("[Connection] Failed to send peer info request: {}", e));
            }
        }

        log("[Connection] Starting message processing loop");
        while let Some(message) = rx.recv().await {
            log("[Connection] Received message from channel");
            match message {
                Message::SendData(packet) => {
                    log(&format!("[Connection] Processing SendData message: {:?}", packet));
                    if let Err(e) = Self::write_packet(&writer, &packet).await {
                        log(&format!("[Connection] Failed to send packet: {}", e));
                    } else {
                        log("[Connection] Packet sent successfully");
                    }
                }
                Message::GetResponse { tx } => {
                    log("[Connection] Processing GetResponse message");
                    let response = match Self::receive_message(&reader).await {
                        Ok(response) => response,
                        Err(e) => {
                            log(&format!("[Connection] Failed to receive message: {}", e));
                            continue;
                        }
                    };
                    if let Err(e) = tx.send(response) {
                        log(&format!("[Connection] Failed to send response to channel: {:?}", e));
                    } else {
                        log("[Connection] Response sent successfully");
                    }
                }
            }
        }
        log("[Connection] Message processing loop ended");
    }

    pub async fn send_peer_info_request(
        writer: &Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
        db: &P2PDatabase,
    ) -> Result<(), String> {
        let fragments = db.get_storage_fragments().unwrap_or(Vec::new());
        let mut stored_files = Vec::new();
        for fragment in fragments {
            stored_files.push(fragment.file_hash.clone());
        }
        let connect_packet = TransportPacket {
            act: "info".to_string(),
            to: None,
            data: Some(
                TransportData::PeerInfo(PeerInfo {
                    is_signal_server: false,
                    total_space: db.get_total_space().unwrap_or(0),
                    free_space: db.get_storage_free_space().await.unwrap_or(0),
                    stored_files: stored_files,
                    public_key: db.get_or_create_peer_id().unwrap(),
                }),
            ),
            protocol: Protocol::STUN,
            peer_key: db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        Self::write_packet(writer, &connect_packet).await
    }

    pub async fn receive_message(
        reader: &Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>,
    ) -> Result<TransportPacket, String> {
        let mut reader = reader.write().await;
        
        // Читаем длину сообщения (4 байта)
        let mut len_bytes = [0u8; 4];
        if let Err(e) = reader.read_exact(&mut len_bytes).await {
            if e.kind() == std::io::ErrorKind::ConnectionReset {
                log(&format!("[Connection] Connection reset by peer: {}", e));
                return Err("Connection reset by peer".to_string());
            }
            return Err(format!("Failed to read message length: {}", e));
        }
        let packet_len = u32::from_be_bytes(len_bytes) as usize;
        
        let mut packet_bytes = vec![0u8; packet_len];
        if let Err(e) = reader.read_exact(&mut packet_bytes).await {
            if e.kind() == std::io::ErrorKind::ConnectionReset {
                log(&format!("[Connection] Connection reset by peer: {}", e));
                return Err("Connection reset by peer".to_string());
            }
            return Err(format!("Failed to read message: {}", e));
        }
        
        let data = String::from_utf8_lossy(&packet_bytes);
        
        match serde_json::from_str(&data) {
            Ok(packet) => {
                Ok(packet)
            }
            Err(e) => {
                log(&format!("[Connection] Failed to parse JSON: {}", e));
                Err(format!("Failed to parse JSON: {}", e))
            }
        }
    }

    pub async fn receive_message_with_reconnect(
        &self,
    ) -> Result<TransportPacket, String> {
        match Self::receive_message(&self.reader).await {
            Ok(packet) => Ok(packet),
            Err(e) => {
                if e.contains("Connection reset by peer") || e.contains("Failed to receive message") {
                    log(&format!("[Connection] Connection lost while receiving: {}", e));
                    match self.handle_connection_loss().await {
                        Ok(_) => {
                            Self::receive_message(&self.reader).await
                        }
                        Err(e) => Err(e),
                    }
                } else {
                    Err(e)
                }
            }
        }
    }

    pub async fn send_peer_info_request_self(&self) -> Result<(), String> {
        Self::send_peer_info_request(&self.writer, &self.db).await
    }

    pub async fn send_packet(&self, packet: TransportPacket) -> Result<(), String> {
        match Self::write_packet(&self.writer, &packet).await {
            Ok(_) => Ok(()),
            Err(e) => {
                if e.contains("Connection reset by peer") || e.contains("Failed to send packet length") {
                    log(&format!("[Connection] Connection lost while sending packet: {}", e));
                    match self.handle_connection_loss().await {
                        Ok(_) => {
                            Self::write_packet(&self.writer, &packet).await
                        }
                        Err(e) => Err(e),
                    }
                } else {
                    Err(e)
                }
            }
        }
    }

    pub async fn get_response(&self) -> Result<TransportPacket, String> {
        let (tx, rx) = oneshot::channel();
        self.tx.send(Message::GetResponse { tx }).await.unwrap();
        match rx.await {
            Ok(response) => Ok(response),
            Err(_) => {
                match self.handle_connection_loss().await {
                    Ok(_) => {
                        let (tx, rx) = oneshot::channel();
                        self.tx.send(Message::GetResponse { tx }).await.unwrap();
                        match rx.await {
                            Ok(response) => Ok(response),
                            Err(_) => Err("Failed to receive response from server".to_string()),
                        }
                    }
                    Err(e) => Err(e),
                }
            }
        }
    }

    pub async fn handle_connection_loss(&self) -> Result<(), String> {
        let mut attempts = self.reconnect_attempts.write().await;
        if *attempts >= self.max_reconnect_attempts {
            return Err("Maximum reconnection attempts reached".to_string());
        }

        *attempts += 1;
        log(&format!("[Connection] Attempting to reconnect (attempt {}/{})", 
            *attempts, self.max_reconnect_attempts));

        // Пытаемся установить новое соединение
        let stream = match TcpStream::connect(format!("{}:{}", self.ip, self.port)).await {
            Ok(s) => s,
            Err(e) => {
                log(&format!("[Connection] Failed to connect: {}", e));
                return Err(e.to_string());
            }
        };

        let (reader, writer) = split(stream);
        
        // Обновляем reader и writer
        {
            let mut current_reader = self.reader.write().await;
            let mut current_writer = self.writer.write().await;
            *current_reader = reader;
            *current_writer = writer;
        }

        // Отправляем info пакет после переподключения
        if let Err(e) = self.send_peer_info_request_self().await {
            log(&format!("[Connection] Failed to send peer info after reconnect: {}", e));
            return Err(e);
        }

        Ok(())
    }
}


=== ../src\lib.rs ===
pub mod signal;
pub mod config;
pub mod packets;
pub mod tunnel;
pub mod db; 
pub mod ui;
pub mod connection;
pub mod manager;
pub mod peer;
pub mod crypto;
pub mod contract;
pub mod simulation;
pub mod http;
pub mod logger;
pub mod commands;

=== ../src\main.rs ===
use clap::{Arg, Command};
use commands::get_db_path;
use peer::Peer;
use std::path::PathBuf;
use crate::config::Config;

mod config;
mod connection;
mod signal;
mod tunnel;
mod db;
mod peer;
mod ui;
mod packets;
mod manager;
mod crypto;
mod contract;
mod http;
mod logger;
mod commands;

use crate::signal::SignalServer;
use crate::db::P2PDatabase;
use crate::ui::{print_all_files, print_welcome, print_all_fragments};
use crate::contract::runtime::hardcoded_test_contract;
use crate::commands::create_base_commands;

#[tokio::main]
async fn main() {
    hardcoded_test_contract();
    let matches = create_base_commands().get_matches();
    let db_path = get_db_path(&matches);

    let path = PathBuf::from(db_path);
    if !path.exists() {
        std::fs::create_dir_all(&path).unwrap();
    }

    let db = P2PDatabase::new(path.to_str().unwrap()).unwrap();
    let config: Config = Config::from_file("config.toml");

    print_welcome();
    print_all_files(&db);

    if matches.get_flag("signal") {
        print_all_fragments(&db);
        let signal_server = SignalServer::new(&config, &db).await;
        signal_server.run().await;
    } else {
        let peer = Peer::new(&config, &db).await;
        peer.run().await;
    }
}

=== ../src\commands\mod.rs ===
use clap::{Arg, Command};

pub fn create_base_commands() -> Command {
    Command::new("P2P Server")
        .arg(Arg::new("signal")
            .long("signal")
            .action(clap::ArgAction::SetTrue)
            .help("Run as signal server"))
        .arg(Arg::new("db-path")
            .long("db-path")
            .action(clap::ArgAction::Set)
            .value_name("FILE")
            .help("Path to the database directory"))
}

pub fn get_db_path(matches: &clap::ArgMatches) -> String {
    matches.get_one::<String>("db-path")
        .map(|s| s.as_str())
        .unwrap_or("./storage").to_string()
}

pub fn get_path_blobs(matches: &clap::ArgMatches) -> String {
    matches.get_one::<String>("db-path")
        .map(|s| format!("{}/blobs", s))
        .unwrap_or("./storage/blobs".to_string())
}



=== ../src\contract\mod.rs ===
pub mod runtime;

=== ../src\contract\runtime.rs ===
use colored::*;
use wasmtime::*;
use std::fmt;

#[derive(Debug)]
enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}

impl fmt::Display for LogLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            LogLevel::Debug => write!(f, "{}", "DEBUG".blue().bold()),
            LogLevel::Info => write!(f, "{}", "INFO".green().bold()),
            LogLevel::Warn => write!(f, "{}", "WARN".yellow().bold()),
            LogLevel::Error => write!(f, "{}", "ERROR".red().bold()),
        }
    }
}

fn log(level: LogLevel, message: &str, context: Option<&str>) {
    let context_str = context.map_or("".to_string(), |c| format!(" [{}]", c.cyan()));
    println!("{} {}{} {}", 
        level,
        "CONTRACT".magenta().bold(),
        context_str,
        message
    );
}

fn log_debug(message: &str, context: Option<&str>) {
    log(LogLevel::Debug, message, context);
}

fn log_info(message: &str, context: Option<&str>) {
    log(LogLevel::Info, message, context);
}

fn log_warn(message: &str, context: Option<&str>) {
    log(LogLevel::Warn, message, context);
}

fn log_error(message: &str, context: Option<&str>) {
    log(LogLevel::Error, message, context);
}

pub fn execute_contract(path: &str, func_name: &str) {
    log_info(&format!("Loading contract from: {}", path.yellow()), Some("CONTRACT_LOADER"));

    let engine = Engine::default();
    let module = match Module::from_file(&engine, path) {
        Ok(m) => m,
        Err(e) => {
            log_error(&format!("Failed to load contract: {}", e), Some("CONTRACT_LOADER"));
            return;
        }
    };

    let mut store = Store::new(&engine, ());
    let instance = match Instance::new(&mut store, &module, &[]) {
        Ok(i) => i,
        Err(e) => {
            log_error(&format!("Failed to create instance: {}", e), Some("CONTRACT_LOADER"));
            return;
        }
    };

    log_info("Contract loaded successfully", Some("CONTRACT_LOADER"));

    log_info(&format!("Looking for function '{}'", func_name.cyan()), Some("FUNCTION_LOOKUP"));
    let func = match instance.get_func(&mut store, func_name) {
        Some(f) => f,
        None => {
            log_error(&format!("Function '{}' not found", func_name), Some("FUNCTION_LOOKUP"));
            return;
        }
    };

    log_info(&format!("Executing '{}'", func_name.cyan()), Some("FUNCTION_EXECUTION"));
    match func.call(&mut store, &[], &mut []) {
        Ok(_) => log_info("Contract executed successfully", Some("FUNCTION_EXECUTION")),
        Err(e) => log_error(&format!("Contract execution failed: {}", e), Some("FUNCTION_EXECUTION")),
    }
}

fn execute_increment_with_arg(contract_path: &str, peer_id: &str) {
    log_debug(&format!("Initializing contract execution for peer: {}", peer_id), Some("INCREMENT_OP"));
    
    let engine = Engine::default();
    let module = match Module::from_file(&engine, contract_path) {
        Ok(m) => m,
        Err(e) => {
            log_error(&format!("Failed to load contract: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };
    
    let mut store = Store::new(&engine, ());
    let instance = match Instance::new(&mut store, &module, &[]) {
        Ok(i) => i,
        Err(e) => {
            log_error(&format!("Failed to create instance: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };

    let memory = match instance.get_memory(&mut store, "memory") {
        Some(m) => m,
        None => {
            log_error("Memory not found", Some("INCREMENT_OP"));
            return;
        }
    };

    let init = match instance.get_func(&mut store, "init") {
        Some(f) => f,
        None => {
            log_error("Init function not found", Some("INCREMENT_OP"));
            return;
        }
    };
    
    log_debug("Initializing contract state", Some("INCREMENT_OP"));
    if let Err(e) = init.call(&mut store, &[], &mut []) {
        log_error(&format!("Failed to initialize contract: {}", e), Some("INCREMENT_OP"));
        return;
    }

    let offset = 1024;
    let peer_id_bytes = peer_id.as_bytes();
    if let Err(e) = memory.write(&mut store, offset, peer_id_bytes) {
        log_error(&format!("Failed to write peer_id to memory: {}", e), Some("INCREMENT_OP"));
        return;
    }

    let increment = match instance.get_typed_func::<(i32, i32), i64>(&mut store, "increment") {
        Ok(f) => f,
        Err(e) => {
            log_error(&format!("Failed to get increment function: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };

    log_debug(&format!("Executing increment for peer_id: {}", peer_id), Some("INCREMENT_OP"));
    let result = match increment.call(&mut store, (offset as i32, peer_id_bytes.len() as i32)) {
        Ok(r) => r,
        Err(e) => {
            log_error(&format!("Failed to execute increment: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };

    log_info(&format!("Counter for peer_id `{}` now equals {}", peer_id, result), Some("INCREMENT_OP"));
}

pub fn hardcoded_test_contract() {
    log_info("Starting WASM smart-contract test suite", Some("TEST_SUITE"));
    log_info("=================================", Some("TEST_SUITE"));

    let path = "contracts/counter/target/wasm32-unknown-unknown/release/counter.wasm";
    execute_increment_with_arg(path, "peer_id");
}


=== ../src\crypto\crypto.rs ===
use chacha20poly1305::aead::Aead;
use chacha20poly1305::{ChaCha20Poly1305, Key, KeyInit, Nonce};
use k256::elliptic_curve::ecdh::diffie_hellman;
use k256::elliptic_curve::ecdh::EphemeralSecret;
use k256::elliptic_curve::sec1::FromEncodedPoint;
use k256::EncodedPoint;
use k256::{ecdh::SharedSecret, PublicKey, SecretKey};
use rand_core::{OsRng, RngCore};
use sha2::{Digest, Sha256};
use uuid::Uuid;


pub fn get_shared_secret(private: &SecretKey, peer_pub_bytes: &[u8]) -> [u8; 32] {
    let secret_scalar = private.to_nonzero_scalar();
    let pub_point = EncodedPoint::from_bytes(peer_pub_bytes).expect("invalid public key bytes");
    let peer_pub = PublicKey::from_encoded_point(&pub_point).expect("invalid public key");

    let shared = diffie_hellman(secret_scalar, peer_pub.as_affine());

    let hash = Sha256::digest(shared.raw_secret_bytes());
    hash.into()
}

pub fn encrypt(plaintext: &[u8], key_bytes: [u8; 32]) -> (Vec<u8>, [u8; 12]) {
    let key = Key::from_slice(&key_bytes);
    let cipher = ChaCha20Poly1305::new(key);

    let mut nonce_bytes = [0u8; 12];
    OsRng.fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::from_slice(&nonce_bytes);

    let ciphertext = cipher
        .encrypt(nonce, plaintext)
        .expect("encryption failure!");
    (ciphertext, nonce_bytes)
}

pub fn decrypt(ciphertext: &[u8], key_bytes: [u8; 32], nonce_bytes: [u8; 12]) -> Vec<u8> {
    let key = Key::from_slice(&key_bytes);
    let cipher = ChaCha20Poly1305::new(key);
    let nonce = Nonce::from_slice(&nonce_bytes);

    cipher
        .decrypt(nonce, ciphertext)
        .expect("decryption failure!")
}


pub fn generate_uuid() -> String {
    Uuid::new_v4().to_string()
}

=== ../src\crypto\mod.rs ===
pub mod token;
pub mod crypto;

use self::token::get_metadata_from_token;
// use crate::crypto::crypto;



=== ../src\crypto\token.rs ===
use crate::packets::StorageToken;
use base64;
use hex;
use k256;
use serde_json;
use k256::elliptic_curve::sec1::ToEncodedPoint;
use k256::ecdsa::signature::Verifier;

pub async fn get_metadata_from_token(token: String) -> Result<StorageToken, String> {
    let token_bytes = base64::decode(&token).map_err(|e| e.to_string())?;
    let token_str = String::from_utf8(token_bytes).map_err(|e| e.to_string())?;
    let token: StorageToken = serde_json::from_str(&token_str).map_err(|e| e.to_string())?;
    Ok(token)
}

pub async fn validate_signature_token(token: String, db: &crate::db::P2PDatabase) -> Result<StorageToken, String> {
    let token_bytes = base64::decode(&token).map_err(|e| e.to_string())?;
    let token_str = String::from_utf8(token_bytes).map_err(|e| e.to_string())?;
    let mut token: StorageToken = serde_json::from_str(&token_str).map_err(|e| e.to_string())?;
    
    let signature = token.signature.clone();
    token.signature = Vec::new();
    
    let token_bytes = serde_json::to_vec(&token).map_err(|e| e.to_string())?;
    
    let pub_key_bytes = hex::decode(&token.storage_provider)
        .map_err(|e| format!("Invalid public key hex: {}", e))?;
    let verifying_key = k256::ecdsa::VerifyingKey::from_sec1_bytes(&pub_key_bytes)
        .map_err(|e| format!("Invalid public key: {}", e))?;
    
    let signature = k256::ecdsa::Signature::from_slice(&signature)
        .map_err(|e| format!("Invalid signature format: {}", e))?;
    
    verifying_key
        .verify(&token_bytes, &signature)
        .map_err(|e| format!("Signature verification failed: {}", e))?;

    token.signature = signature.to_bytes().to_vec();
    Ok(token)
}




=== ../src\db\db.rs ===
use async_std::path::PathBuf;
use redb::{Database, Error};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH};

use super::tables;
use super::models::PeerStats;

#[derive(Clone, Debug)]
pub struct P2PDatabase {
    pub db: Arc<Mutex<Database>>,
    pub path: String,
}

impl P2PDatabase {
    pub fn new(path: &str) -> Result<Self, Error> {
        let db_file = PathBuf::from(path).join("db");

        let db = Database::create(db_file)?;
        {
            let write_txn = db.begin_write()?;
            {
                write_txn.open_table(tables::STORAGE_TABLE)?;
                write_txn.open_table(tables::PEER_INFO_TABLE)?;
                write_txn.open_table(tables::SECRET_KEYS_TABLE)?;
                write_txn.open_table(tables::DHT_TABLE)?;
                write_txn.open_table(tables::TOKENS_TABLE)?;
                write_txn.open_table(tables::VALIDATOR_STORAGE_TABLE)?;
                write_txn.open_table(tables::PEER_STATS_TABLE)?;
            }
            write_txn.commit()?;
        }

        Ok(Self {
            db: Arc::new(Mutex::new(db)),
            path: path.to_string(),
        })
    }
}


=== ../src\db\dht.rs ===
use crate::db::{models::DHTEntry, tables::DHT_TABLE};
use redb::{Error, ReadableTable};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct PeerConnection {
    pub peer_id: String,
    pub connected_peer_id: String,
    pub timestamp: u64,
    pub is_active: bool,
}

use super::P2PDatabase;

impl P2PDatabase {

} 

=== ../src\db\mod.rs ===
mod db;
mod models;
pub mod tables;
mod peer;
mod storage;
mod dht;
mod tokens;
mod stats;
pub use db::P2PDatabase;
pub use models::Storage;

=== ../src\db\models.rs ===
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Storage {
    pub file_hash: String, // sha256
    pub filename: String,
    pub mime: String, // mime type for http proxy
    pub public: bool, // true if file is public (not encrypted)
    pub encrypted: bool, // true if file is encrypted
    pub compressed: bool, // true if file is compressed
    pub auto_decompress: bool, // true if file should be automatically decompressed
    pub owner_key: String, // owner public key
    pub storage_peer_key: String, // provider peer key
    pub uploaded_via_token: Option<String>, // base64 token
    pub token: String, // base64 token
    pub token_hash: Option<String>, // hash of the token
    pub size: u64,
    pub groups: Vec<String>,
    pub tags: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DHTEntry {
    pub peer_id: String,
    pub session_key: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenInfo {
    pub token: String,
    pub free_space: u64,
    pub used_space: u64,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ValidatorStorageInfo {
    pub peer_id: String,
    pub free_space: u64,
    pub total_space: u64,
    pub last_update: u64,
    pub is_online: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PeerStats {
    pub public_key: String,
    pub total_space: u64,
    pub free_space: u64,
    pub stored_files: Vec<String>, // хэши файлов
    pub last_update: u64,
} 

=== ../src\db\peer.rs ===
use crate::db::tables::PEER_INFO_TABLE;
use flate2::bufread::GzEncoder;
use k256::elliptic_curve::group::UncompressedEncoding;
use redb::Error;
use anyhow::Result;
use uuid::Uuid;
use std::io::Read;

use hex::{decode as hex_decode, encode as hex_encode};
use k256::{
    elliptic_curve::rand_core::OsRng,
    SecretKey,
    PublicKey,
};
use k256::ecdsa::{SigningKey, VerifyingKey};
use k256::elliptic_curve::sec1::{ToEncodedPoint, FromEncodedPoint};

use super::P2PDatabase;
use crate::crypto::crypto::{get_shared_secret, encrypt, decrypt};

impl P2PDatabase {
    pub fn get_or_create_peer_id(&self) -> Result<String, Error> {
        let db = self.db.lock().unwrap();
        let read_txn = db.begin_read()?;
        let table = read_txn.open_table(PEER_INFO_TABLE)?;

        if let Some(data) = table.get("private_key")? {
            let priv_key_hex = String::from_utf8(data.value().to_vec()).unwrap();
            let priv_key_bytes = hex_decode(&priv_key_hex).unwrap();

            let secret = SecretKey::from_bytes(priv_key_bytes.as_slice().try_into().unwrap()).unwrap();
            let signing_key = SigningKey::from(secret);
            let verifying_key = signing_key.verifying_key();
            let pub_key = verifying_key.to_encoded_point(true);
            let pub_key_hex = hex_encode(pub_key.as_bytes());
            return Ok(pub_key_hex);
        } else {
            drop(read_txn);

            let signing_key = SigningKey::random(&mut OsRng);
            let priv_key_bytes = signing_key.to_bytes();
            let priv_key_hex = hex_encode(priv_key_bytes);

            let verifying_key = signing_key.verifying_key();
            let pub_key = verifying_key.to_encoded_point(true);
            let pub_key_hex = hex_encode(pub_key.as_bytes());

            let write_txn = db.begin_write()?;
            {
                let mut table = write_txn.open_table(PEER_INFO_TABLE)?;
                table.insert("private_key", priv_key_hex.as_bytes())?;
            }
            write_txn.commit()?;

            Ok(pub_key_hex)
        }
    }

    pub fn generate_uuid(&self) -> Result<String, Error> {
        let uuid = Uuid::new_v4();
        let uuid_hex = uuid.to_string();
        Ok(uuid_hex)
    }

    pub fn get_private_key(&self) -> Result<SecretKey, Error> {
        let db = self.db.lock().unwrap();
        let read_txn = db.begin_read()?;
        let table = read_txn.open_table(PEER_INFO_TABLE)?;

        let data = table.get("private_key")?.ok_or_else(|| Error::Corrupted("Private key not found".to_string()))?;
        let priv_key_hex = String::from_utf8(data.value().to_vec()).unwrap();
        let priv_key_bytes = hex_decode(&priv_key_hex).unwrap();
        Ok(SecretKey::from_bytes(priv_key_bytes.as_slice().try_into().unwrap()).unwrap())
    }

    pub fn get_private_signing_key(&self) -> Result<SigningKey, Error> {
        let db = self.db.lock().unwrap();
        let read_txn = db.begin_read()?;
        let table = read_txn.open_table(PEER_INFO_TABLE)?;

        let data = table.get("private_key")?.ok_or_else(|| Error::Corrupted("Private key not found".to_string()))?;
        let priv_key_hex = String::from_utf8(data.value().to_vec()).unwrap();
        let priv_key_bytes = hex_decode(&priv_key_hex).unwrap();
        Ok(SigningKey::from_bytes(priv_key_bytes.as_slice().try_into().unwrap()).unwrap())
    }

    pub fn encrypt_data(&self, data: &[u8]) -> Result<(Vec<u8>, [u8; 12])> {
        let private_key = self.get_private_key()?;
        let signing_key = SigningKey::from(&private_key);
        let verifying_key = signing_key.verifying_key();
        let pub_key = verifying_key.to_encoded_point(true);
        let pub_key_bytes: [u8; 32] = pub_key.as_bytes()[1..33].try_into().unwrap();
        Ok(encrypt(data, pub_key_bytes))
    }

    pub fn decrypt_data(&self, data: &[u8], nonce: &[u8; 12]) -> Result<Vec<u8>> {
        let private_key = self.get_private_key()?;
        let signing_key = SigningKey::from(&private_key);
        let verifying_key = signing_key.verifying_key();
        let pub_key = verifying_key.to_encoded_point(true);
        let pub_key_bytes: [u8; 32] = pub_key.as_bytes()[1..33].try_into().unwrap();
        Ok(decrypt(data, pub_key_bytes, *nonce))
    }

    pub fn encrypt_message(&self, message: &[u8], peer_public_key: &str) -> Result<(Vec<u8>, [u8; 12])> {
        let private_key = self.get_private_key()?;
        let peer_pub_key_bytes = hex_decode(peer_public_key)?;
        
        let pub_point = k256::EncodedPoint::from_bytes(&peer_pub_key_bytes)
            .map_err(|_| anyhow::anyhow!("Invalid public key bytes"))?;
        let peer_pub_key = PublicKey::from_encoded_point(&pub_point)
            .unwrap();
        
        let signing_key = SigningKey::from(&private_key);
        let shared_secret = get_shared_secret(&private_key, &peer_pub_key_bytes);
        Ok(encrypt(message, shared_secret))
    }

    pub fn decrypt_message(&self, ciphertext: &[u8], nonce: [u8; 12], peer_public_key: &str) -> Result<Vec<u8>> {
        let private_key = self.get_private_key()?;
        let peer_pub_key_bytes = hex_decode(peer_public_key)?;
        let peer_pub_key = PublicKey::from_sec1_bytes(&peer_pub_key_bytes)?;
        let encoded_point = peer_pub_key.to_encoded_point(false);
        let peer_pub_key_bytes = encoded_point.as_bytes();
        
        let signing_key = SigningKey::from(&private_key);
        let shared_secret = get_shared_secret(&private_key, peer_pub_key_bytes);
        Ok(decrypt(ciphertext, shared_secret, nonce))
    }

    pub fn uncompress_data(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut decoder = flate2::read::GzDecoder::new(data);
        let mut decompressed_data = Vec::new();
        decoder.read_to_end(&mut decompressed_data)
            .map_err(|e| anyhow::anyhow!("Failed to decompress data: {}", e))?;
        Ok(decompressed_data)
    }
}


=== ../src\db\stats.rs ===
use redb::{Database, Error, ReadableTable};
use std::time::{SystemTime, UNIX_EPOCH};

use super::db::P2PDatabase;
use super::models::PeerStats;
use super::tables;

impl P2PDatabase {
    pub fn update_peer_stats(&self, public_key: &str, total_space: u64, free_space: u64, stored_files: Vec<String>) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        let stats = PeerStats {
            public_key: public_key.to_string(),
            total_space,
            free_space,
            stored_files,
            last_update: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        {
            let mut table = tx.open_table(tables::PEER_STATS_TABLE)?;
            let data = serde_json::to_string(&stats).unwrap();
            table.insert(public_key, data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_peer_with_most_space(&self) -> Option<String> {
        let mut peers: Vec<(String, PeerStats)> = Vec::new();
        
        let db = self.db.lock().unwrap();
        if let Ok(tx) = db.begin_read() {
            if let Ok(table) = tx.open_table(tables::PEER_STATS_TABLE) {
                for item in table.iter().unwrap() {
                    if let Ok((key, value)) = item {
                        if let Ok(peer_data) = serde_json::from_slice::<PeerStats>(value.value()) {
                            peers.push((key.value().to_string(), peer_data));
                        }
                    }
                }
            }
        }
    
        peers.sort_by(|a, b| b.1.free_space.cmp(&a.1.free_space));
        peers.first().map(|(peer_id, _)| peer_id.clone())
    }
    
    pub fn get_peer_stats(&self, peer_id: &str) -> Result<Option<PeerStats>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(tables::PEER_STATS_TABLE)?;

        match table.get(peer_id)? {
            Some(data) => {
                let json_str = String::from_utf8(data.value().to_vec()).unwrap();
                let stats: PeerStats = serde_json::from_str(&json_str).unwrap();
                Ok(Some(stats))
            }
            None => Ok(None),
        }
    }

    pub fn get_all_peer_stats(&self) -> Result<Vec<PeerStats>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(tables::PEER_STATS_TABLE)?;

        let mut stats = Vec::new();
        for item in table.iter()? {
            let (_, value) = item?;
            let json_str = String::from_utf8(value.value().to_vec()).unwrap();
            let peer_stats: PeerStats = serde_json::from_str(&json_str).unwrap();
            stats.push(peer_stats);
        }

        Ok(stats)
    }

    pub fn remove_peer_stats(&self, peer_id: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;
        
        {
            let mut table = tx.open_table(tables::PEER_STATS_TABLE)?;
            table.remove(peer_id)?;
        }

        tx.commit()?;
        Ok(())
    }
}


=== ../src\db\storage.rs ===
use std::time::{SystemTime, UNIX_EPOCH};

use crate::{
    config::Config,
    db::{models::Storage, tables::STORAGE_TABLE},
};
use async_std::stream::StreamExt;
use redb::{Error, ReadableTable};

use super::{models::TokenInfo, tables::{TOKENS_TABLE, PEER_STATS_TABLE}, P2PDatabase};

#[derive(Debug)]
pub enum StorageError {
    Redb(redb::Error),
    Io(std::io::Error),
}

impl From<redb::Error> for StorageError {
    fn from(err: redb::Error) -> Self {
        StorageError::Redb(err)
    }
}

impl From<std::io::Error> for StorageError {
    fn from(err: std::io::Error) -> Self {
        StorageError::Io(err)
    }
}

impl P2PDatabase {
    pub fn add_storage_fragment(&self, fragment: Storage) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;
        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let data = serde_json::to_string(&fragment).unwrap();
            table.insert(fragment.file_hash.as_str(), data.as_bytes())?;
        }
        tx.commit()?;
        Ok(())
    }

    pub fn get_storage_fragments(&self) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;

        let mut result = Vec::new();
        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            result.push(fragment);
        }

        Ok(result)
    }

    pub fn get_storage_fragments_by_hash(&self, hash: &str) -> Result<Option<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;

        if let Some(value) = table.get(hash)? {
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            Ok(Some(fragment))
        } else {
            Ok(None)
        }
    }

    pub fn get_storage_fragments_by_token(&self, token: &str) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        if let Some(value) = table.get(token)? {
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if fragment.token == token {
                fragments.push(fragment);
            }
        }

        Ok(fragments)
    }

    pub fn get_by_owner_key_fragments(&self, owner_key: &str) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if fragment.owner_key == owner_key {
                fragments.push(fragment);
            }
        }

        Ok(fragments)
    }

    pub fn search_fragment_in_virtual_storage(
        &self,
        identifier: &str,
        public: Option<bool>,
    ) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if (fragment.owner_key == identifier
                || fragment.file_hash == identifier
                || fragment.filename == identifier)
            {
                if public.is_none() {
                    fragments.push(fragment);
                } else if public.is_some() == fragment.public {
                    fragments.push(fragment);
                }
            }
        }

        Ok(fragments)
    }

    pub fn get_my_fragments(&self) -> Result<Vec<Storage>, Error> {
        let my_peer_id = self.get_or_create_peer_id().unwrap();
        let fragments = self.get_by_owner_key_fragments(&my_peer_id)?;
        Ok(fragments)
    }

    pub fn get_total_space(&self) -> Result<u64, StorageError> {
        let config = Config::from_file("config.toml");
        Ok(config.storage_size)
    }

    pub async fn get_storage_size(&self) -> Result<u64, StorageError> {
        let path = format!("{}/blobs", self.path);

        if !std::path::Path::new(&path).exists() {
            std::fs::create_dir_all(&path).unwrap();
            return Ok(0);
        }

        let mut total_size = 0u64;

        let mut entries = async_std::fs::read_dir(&path).await?;
        while let Some(entry) = entries.next().await {
            let entry = entry?;
            let metadata = entry.metadata().await?;
            if metadata.is_file() {
                total_size += metadata.len();
            }
        }

        Ok(total_size)
    }

    pub async fn get_storage_free_space(&self) -> Result<u64, StorageError> {
        let config = Config::from_file("config.toml");
        let free_space = config.storage_size - self.get_storage_size().await?;
        Ok(free_space)
    }

    pub fn update_fragment_public_access(
        &self,
        file_hash: &str,
        public: bool,
    ) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let fragment_data = if let Some(data) = table.get(file_hash)? {
                let data = String::from_utf8(data.value().to_vec()).unwrap();
                let mut fragment: Storage = serde_json::from_str(&data).unwrap();
                fragment.public = public;
                serde_json::to_string(&fragment).unwrap()
            } else {
                return Err(Error::Corrupted("Фрагмент не найден".into()));
            };
            table.insert(file_hash, fragment_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn remove_fragment(&self, file_hash: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            table.remove(file_hash)?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn update_fragment_path(&self, file_hash: &str, new_path: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let data = table.get(file_hash)?;
            let json_str = String::from_utf8(
                data.ok_or_else(|| Error::Corrupted("Файл не найден".to_string()))?
                    .value()
                    .to_vec(),
            )
            .unwrap();
            let mut fragment: Storage = serde_json::from_str(&json_str).unwrap();
            fragment.filename = new_path.to_string();
            let updated_data = serde_json::to_string(&fragment).unwrap();
            table.insert(file_hash, updated_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn update_token_used_space(&self, peer_id: &str, used_space: u64) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(TOKENS_TABLE)?;
            let data = table.get(peer_id)?;
            let json_str = String::from_utf8(
                data.ok_or_else(|| Error::Corrupted("Токен не найден".to_string()))?
                    .value()
                    .to_vec(),
            )
            .unwrap();
            let mut token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            token_info.used_space = used_space;
            let updated_data = serde_json::to_string(&token_info).unwrap();
            table.insert(peer_id, updated_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_token_used_space(&self, peer_id: &str) -> Result<u64, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        if let Some(data) = table.get(peer_id)? {
            let json_str = String::from_utf8(data.value().to_vec()).unwrap();
            let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            Ok(token_info.used_space)
        } else {
            Ok(0)
        }
    }

    pub fn add_file_to_group(&self, group_name: &str, file_hash: &str, tags: Vec<String>) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let fragment_data = if let Some(data) = table.get(file_hash)? {
                let data = String::from_utf8(data.value().to_vec()).unwrap();
                let mut fragment: Storage = serde_json::from_str(&data).unwrap();
                
                if !fragment.groups.contains(&group_name.to_string()) {
                    fragment.groups.push(group_name.to_string());
                }
                fragment.tags.extend(tags);
                
                serde_json::to_string(&fragment).unwrap()
            } else {
                return Err(Error::Corrupted("Файл не найден".into()));
            };
            table.insert(file_hash, fragment_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn remove_file_from_group(&self, group_name: &str, file_hash: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let fragment_data = if let Some(data) = table.get(file_hash)? {
                let data = String::from_utf8(data.value().to_vec()).unwrap();
                let mut fragment: Storage = serde_json::from_str(&data).unwrap();
                
                fragment.groups.retain(|g| g != group_name);
                
                serde_json::to_string(&fragment).unwrap()
            } else {
                return Err(Error::Corrupted("Файл не найден".into()));
            };
            table.insert(file_hash, fragment_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_files_by_group(&self, group_name: &str) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if fragment.groups.contains(&group_name.to_string()) {
                fragments.push(fragment);
            }
        }

        Ok(fragments)
    }

    pub fn get_files_by_tag(&self, tag: &str) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if fragment.tags.contains(&tag.to_string()) {
                fragments.push(fragment);
            }
        }

        Ok(fragments)
    }

    pub fn get_all_groups(&self) -> Result<Vec<String>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut groups = std::collections::HashSet::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            groups.extend(fragment.groups);
        }

        Ok(groups.into_iter().collect())
    }

    pub fn get_all_tags(&self) -> Result<Vec<String>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut tags = std::collections::HashSet::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            tags.extend(fragment.tags);
        }

        Ok(tags.into_iter().collect())
    }

    pub fn update_fragment_metadata(
        &self,
        file_hash: &str,
        filename: String,
        mime: String,
        encrypted: bool,
        compressed: bool,
        auto_decompress: bool,
        public: bool,
        size: u64,
    ) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let fragment_data = if let Some(data) = table.get(file_hash)? {
                let data = String::from_utf8(data.value().to_vec()).unwrap();
                let mut fragment: Storage = serde_json::from_str(&data).unwrap();
                
                fragment.filename = filename;
                fragment.mime = mime;
                fragment.encrypted = encrypted;
                fragment.compressed = compressed;
                fragment.auto_decompress = auto_decompress;
                fragment.public = public;
                fragment.size = size;
                
                serde_json::to_string(&fragment).unwrap()
            } else {
                return Err(Error::Corrupted("Фрагмент не найден".into()));
            };
            table.insert(file_hash, fragment_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }
}


=== ../src\db\tables.rs ===
use redb::TableDefinition;

pub const DHT_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("dht");
pub const STORAGE_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("storage");
pub const PEER_INFO_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("peer_info");
pub const SECRET_KEYS_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("secret_keys");
pub const TOKENS_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("tokens");
pub const VALIDATOR_STORAGE_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("validator_storage");
pub const PEER_STATS_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("peer_stats"); 

=== ../src\db\tokens.rs ===
use crate::db::{models::{TokenInfo, ValidatorStorageInfo}, tables::{TOKENS_TABLE, VALIDATOR_STORAGE_TABLE}};
use redb::{Error, ReadableTable, ReadableTableMetadata};
use std::time::{SystemTime, UNIX_EPOCH};

use super::P2PDatabase;

impl P2PDatabase {
    pub fn add_token(&self, peer_id: &str, token: &str, free_space: u64) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        let token_info = TokenInfo {
            token: token.to_string(),
            free_space,
            used_space: 0,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        {
            let mut table = tx.open_table(TOKENS_TABLE)?;
            let data = serde_json::to_string(&token_info).unwrap();
            table.insert(peer_id, data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_token(&self, peer_id: &str) -> Result<Option<TokenInfo>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        match table.get(peer_id)? {
            Some(data) => {
                let json_str = String::from_utf8(data.value().to_vec()).unwrap();
                let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
                Ok(Some(token_info))
            }
            None => Ok(None),
        }
    }

    pub fn get_all_tokens(&self) -> Result<Vec<(String, TokenInfo)>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        let mut tokens = Vec::new();
        for item in table.iter()? {
            let (key, value) = item?;
            let json_str = String::from_utf8(value.value().to_vec()).unwrap();
            let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            tokens.push((key.value().to_string(), token_info));
        }

        Ok(tokens)
    }

    pub fn get_best_token(&self, file_size: u64) -> Result<Option<(String, TokenInfo)>, Error> {
        let my_peer_id = self.get_or_create_peer_id().unwrap();
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        if table.is_empty()? {
            return Ok(None);
        }

        let mut best_token = None;
        let mut best_free_space = 0;
        
        println!("[DEBUG] Starting iteration over tokens");
        for item in table.iter()? {
            let (key, value) = item?;
            println!("[DEBUG] Processing token for peer: {}", key.value());
            let json_str = String::from_utf8(value.value().to_vec()).unwrap();
            let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            if token_info.free_space >= file_size {
                if token_info.free_space > best_free_space && my_peer_id == key.value().to_string() {
                    best_free_space = token_info.free_space;
                    best_token = Some((key.value().to_string(), token_info));
                    println!("[DEBUG] Found better token with free space: {}", best_free_space);
                }
            }
        }
        println!("[DEBUG] Finished processing tokens");

        Ok(best_token)
    }

    pub fn remove_token(&self, peer_id: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;
        
        {
            let mut table = tx.open_table(TOKENS_TABLE)?;
            table.remove(peer_id)?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn update_token_free_space(&self, peer_id: &str, free_space: u64) -> Result<(), Error> {
        if let Some(mut token_info) = self.get_token(peer_id)? {
            token_info.free_space = free_space;
            token_info.timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();

            let db = self.db.lock().unwrap();
            let tx = db.begin_write()?;
            
            {
                let mut table = tx.open_table(TOKENS_TABLE)?;
                let data = serde_json::to_string(&token_info).unwrap();
                table.insert(peer_id, data.as_bytes())?;
            }

            tx.commit()?;
        }
        Ok(())
    }

    pub fn update_validator_storage(&self, peer_id: &str, free_space: u64, total_space: u64) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        let storage_info = ValidatorStorageInfo {
            peer_id: peer_id.to_string(),
            free_space,
            total_space,
            last_update: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            is_online: true,
        };

        {
            let mut table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;
            let data = serde_json::to_string(&storage_info).unwrap();
            table.insert(peer_id, data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_validator_storage(&self, peer_id: &str) -> Result<Option<ValidatorStorageInfo>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;

        match table.get(peer_id)? {
            Some(data) => {
                let json_str = String::from_utf8(data.value().to_vec()).unwrap();
                let storage_info: ValidatorStorageInfo = serde_json::from_str(&json_str).unwrap();
                Ok(Some(storage_info))
            }
            None => Ok(None),
        }
    }

    pub fn get_all_validator_storage(&self) -> Result<Vec<ValidatorStorageInfo>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;

        let mut storage_info = Vec::new();
        for item in table.iter()? {
            let (_, value) = item?;
            let json_str = String::from_utf8(value.value().to_vec()).unwrap();
            let info: ValidatorStorageInfo = serde_json::from_str(&json_str).unwrap();
            storage_info.push(info);
        }

        Ok(storage_info)
    }

    pub fn mark_peer_offline(&self, peer_id: &str) -> Result<(), Error> {
        if let Some(mut storage_info) = self.get_validator_storage(peer_id)? {
            storage_info.is_online = false;
            storage_info.last_update = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();

            let db = self.db.lock().unwrap();
            let tx = db.begin_write()?;
            
            {
                let mut table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;
                let data = serde_json::to_string(&storage_info).unwrap();
                table.insert(peer_id, data.as_bytes())?;
            }

            tx.commit()?;
        }
        Ok(())
    }
} 

=== ../src\http\http_api.rs ===
use super::api::{full, log, FileAccessRequest, FileCache, UpdateRequest, UploadRequest};
use crate::db::P2PDatabase;
use crate::packets::{
    FragmentSearchRequest, PeerFileGet, PeerFileUpdate, PeerUploadFile, Protocol, TransportData,
    TransportPacket,
};
use bytes::Bytes;
use chrono;
use colored::Colorize;
use dashmap::DashMap;
use hex;
use http_body_util::{combinators::BoxBody, BodyExt, Full};
use hyper::server::conn::http1;
use hyper::service::service_fn;
use hyper::{body::Incoming, Request, Response};
use hyper_util::rt::tokio::TokioIo;
use mime_guess;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::sync::Mutex;
use std::{convert::Infallible, net::SocketAddr, sync::Arc};
use tokio::net::TcpListener;
use tokio::sync::{mpsc, oneshot};
use uuid::Uuid;
use crate::logger;

#[derive(Clone, Debug)]
pub struct HttpApi {
    db: Arc<P2PDatabase>,
    api_tx: mpsc::Sender<TransportPacket>,
    pending_responses: Arc<DashMap<String, oneshot::Sender<TransportPacket>>>,
    fragment_cache: Arc<DashMap<String, String>>,
    file_cache: Arc<FileCache>,
    port: Arc<Mutex<u16>>,
    public_ip: String,
    path_blobs: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct PacketRequest {
    to: Option<String>,
    data: Option<TransportData>,
    protocol: Protocol,
}

impl HttpApi {
    pub async fn new(
        db: Arc<P2PDatabase>,
        public_ip: String,
        api_tx: mpsc::Sender<TransportPacket>,
        path_blobs: String,
    ) -> Self {
        Self {
            db,
            api_tx,
            pending_responses: Arc::new(DashMap::new()),
            fragment_cache: Arc::new(DashMap::new()),
            file_cache: Arc::new(FileCache::new()),
            port: Arc::new(Mutex::new(8080)),
            public_ip,
            path_blobs,
        }
    }

    pub fn get_file_url(&self, file_hash: &str) -> String {
        format!(
            "http://{}:{}/{}",
            self.get_public_ip(),
            *self.port.lock().unwrap(),
            file_hash
        )
    }

    fn get_public_ip(&self) -> String {
        self.public_ip.clone()
    }

    pub async fn set_response(&self, request_id: String, response: TransportPacket) {
        logger::info(&format!("[HTTP API] Set response for request: {}", request_id));
        if let Some((_, sender)) = self.pending_responses.remove(&request_id) {
            let _ = sender.send(response);
        }
    }

    pub async fn start(self: Arc<Self>) {
        let mut port = 8081;
        let mut listener = None;

        while listener.is_none() {
            let addr = SocketAddr::from(([0, 0, 0, 0], port));
            match TcpListener::bind(addr).await {
                Ok(l) => {
                    listener = Some(l);
                    logger::info(&format!("[HTTP API] Listening on http://{}", addr));
                }
                Err(_) => {
                    logger::warning(&format!("[HTTP API] Port {} is busy, trying {}", port, port + 1));
                    port += 1;
                }
            }
        }

        let listener = listener.unwrap();
        let port = listener.local_addr().unwrap().port();
        *self.port.lock().unwrap() = port;

        loop {
            let (stream, _) = listener.accept().await.unwrap();
            let api = self.clone();

            tokio::spawn(async move {
                let service = service_fn(move |req: Request<Incoming>| {
                    let api = api.clone();
                    async move { api.handle(req).await }
                });

                if let Err(err) = http1::Builder::new()
                    .serve_connection(TokioIo::new(stream), service)
                    .await
                {
                    logger::error(&format!("[HTTP API] Connection error: {:?}", err));
                }
            });
        }
    }

    async fn handle(
        &self,
        req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let path = req.uri().path();
        let method = req.method();

        // Обработка CORS preflight запросов
        if method == &hyper::Method::OPTIONS {
            return Ok(Response::builder()
                .status(hyper::StatusCode::OK)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full(""))
                .unwrap());
        }

        match (method, path) {
            (&hyper::Method::GET, "/api/info") => self.handle_node_info(req).await,
            (&hyper::Method::POST, "/api/packet") => self.handle_packet(req).await,
            (&hyper::Method::GET, path) if path.starts_with("/api/file/") => {
                self.handle_get_file(req).await
            }
            (&hyper::Method::GET, "/api/files") => self.handle_list_files(req).await,
            (&hyper::Method::POST, "/api/upload") => self.handle_upload_file(req).await,
            (&hyper::Method::POST, "/api/update") => self.handle_update_file(req).await,
            (&hyper::Method::DELETE, path) if path.starts_with("/api/file/") => {
                self.handle_delete_file(req).await
            }
            (&hyper::Method::PUT, path)
                if path.starts_with("/api/file/") && path.ends_with("/access") =>
            {
                self.handle_change_file_access(req).await
            }
            _ => Ok(Response::builder()
                .status(hyper::StatusCode::NOT_FOUND)
                .body(full("Not Found"))
                .unwrap()),
        }
    }

    async fn handle_node_info(
        &self,
        _req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let peer_id = self.db.get_or_create_peer_id().unwrap();

        #[derive(Serialize)]
        struct NodeInfo {
            node_id: String,
            host_type: String,
            status: String,
            connection_type: String,
            last_switch: String,
        }

        let info = NodeInfo {
            node_id: peer_id,
            host_type: "Validator Node".to_string(),
            status: "ONLINE".to_string(),
            connection_type: "TURN".to_string(),
            last_switch: chrono::Local::now().format("%H:%M:%S").to_string(),
        };

        let response_json = serde_json::to_string(&info).unwrap();
        Ok(Response::builder()
            .status(hyper::StatusCode::OK)
            .header("Content-Type", "application/json")
            .header("Access-Control-Allow-Origin", "*")
            .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
            .header("Access-Control-Allow-Headers", "Content-Type")
            .body(full(response_json))
            .unwrap())
    }

    async fn handle_packet(
        &self,
        req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let whole_body = req.collect().await?.to_bytes();
        let packet_request: PacketRequest = match serde_json::from_slice(&whole_body) {
            Ok(p) => p,
            Err(e) => {
                return Ok(Response::builder()
                    .status(hyper::StatusCode::BAD_REQUEST)
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full(format!("Invalid request format: {}", e)))
                    .unwrap());
            }
        };

        let request_id = Uuid::new_v4().to_string();
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(request_id.clone(), tx);

        let packet = TransportPacket {
            act: "api_request".to_string(),
            to: packet_request.to,
            data: packet_request.data,
            protocol: packet_request.protocol,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: request_id.clone(),
            nodes: vec![],
        };

        if let Err(e) = self.api_tx.send(packet).await {
            return Ok(Response::builder()
                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full(format!("Failed to send packet: {}", e)))
                .unwrap());
        }

        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(response)) => {
                let response_json = serde_json::to_string(&response).unwrap();
                Ok(Response::builder()
                    .status(hyper::StatusCode::OK)
                    .header("Content-Type", "application/json")
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full(response_json))
                    .unwrap())
            }
            _ => Ok(Response::builder()
                .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("Request timeout"))
                .unwrap()),
        }
    }

    async fn handle_get_file(
        &self,
        req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let path = req.uri().path();
        let file_hash = path.strip_prefix("/api/file/").unwrap_or("");
        logger::debug(&format!("[HTTP API] [DEBUG] Handling get file request for hash: {}", file_hash));

        if file_hash.is_empty() {
            logger::debug(&format!("[HTTP API] [DEBUG] Empty file hash received"));
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("File hash is required"))
                .unwrap());
        }

        let request_id = Uuid::new_v4().to_string();
        let mut indentificator = file_hash.to_string(); // file hash
        let mut storage_peer_id = None;
        let mut this_peer_storage_file = false;
        let mut file_hash = None;
        let mut mime = None;

        if indentificator.len() == 64 {
            logger::debug(&format!(
                "[HTTP API] [DEBUG] Searching for fragments with hash length 64"
            ));

            if let Some(cached_owner) = self.fragment_cache.get(&indentificator) {
                logger::debug(&format!(
                    "[HTTP API] [DEBUG] Found cached owner for hash: {}",
                    cached_owner.clone()
                ));
                storage_peer_id = Some(cached_owner.clone());
            } else {
                logger::debug(&format!(
                    "[HTTP API] [DEBUG] No cached owner found, searching in local storage"
                ));
                if let Ok(fragments) = self
                    .db
                    .search_fragment_in_virtual_storage(&indentificator, None)
                {
                    if let Some(fragment) = fragments.first() {
                        logger::debug(&format!(
                            "[HTTP API] [DEBUG] Found fragment in local storage: {:?}",
                            fragment
                        ));
                        self.fragment_cache
                            .insert(indentificator.clone(), fragment.storage_peer_key.clone());
                        storage_peer_id = Some(fragment.storage_peer_key.clone());
                        this_peer_storage_file =
                            fragment.storage_peer_key == self.db.get_or_create_peer_id().unwrap();
                        file_hash = Some(fragment.file_hash.clone());
                        mime = Some(fragment.mime.clone());
                        logger::debug(&format!(
                            "[HTTP API] [DEBUG] This peer storage file: {}",
                            this_peer_storage_file
                        ));
                    } else {
                        logger::debug(&format!("[HTTP API] [DEBUG] No fragment found in local storage, initiating network search"));
                        let search_packet = TransportPacket {
                            act: "search_fragments".to_string(),
                            to: None,
                            data: Some(TransportData::FragmentSearchRequest(
                                FragmentSearchRequest {
                                    query: indentificator.clone(),
                                    request_id: request_id.clone(),
                                },
                            )),
                            protocol: Protocol::TURN,
                            peer_key: self.db.get_or_create_peer_id().unwrap(),
                            uuid: request_id.clone(),
                            nodes: vec![],
                        };

                        let (search_tx, search_rx) = oneshot::channel();
                        self.pending_responses.insert(request_id.clone(), search_tx);

                        if let Err(e) = self.api_tx.send(search_packet).await {
                            logger::debug(&format!(
                                "[HTTP API] [DEBUG] Failed to send search packet: {}",
                                e
                            ));
                            return Ok(Response::builder()
                                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                                .body(full(format!("Failed to send search packet: {}", e)))
                                .unwrap());
                        }

                        logger::debug(&format!("[HTTP API] [DEBUG] Waiting for search response"));
                        if let Ok(search_response) =
                            tokio::time::timeout(tokio::time::Duration::from_secs(5), search_rx)
                                .await
                        {
                            if let Ok(response_data) = search_response {
                                logger::debug(&format!(
                                    "[HTTP API] [DEBUG] Search response received: {:?}",
                                    response_data
                                ));
                                if let Some(TransportData::FragmentSearchResponse(response)) =
                                    response_data.data
                                {
                                    for fragment in response.fragments {
                                        if fragment.file_hash == indentificator {
                                            logger::debug(&format!("[HTTP API] [DEBUG] Found matching fragment in network search"));
                                            self.fragment_cache.insert(
                                                indentificator.clone(),
                                                fragment.storage_peer_key.clone(),
                                            );
                                            storage_peer_id =
                                                Some(fragment.storage_peer_key.clone());
                                            break;
                                        }
                                    }
                                }
                            }
                        } else {
                            logger::debug(&format!("[HTTP API] [DEBUG] Search response timeout"));
                        }
                    }
                }
            }
        }
        let file_hash_clone = file_hash.clone();
        if file_hash.is_some() {
            let file_hash_str = file_hash.unwrap();
            logger::debug(&format!(
                "[HTTP API] [DEBUG] Checking file cache for hash: {}",
                file_hash_str
            ));
            if let Some((cached_content, cached_mime)) =
                self.file_cache.get_cached_file(&file_hash_str)
            {
                logger::debug(&format!(
                    "[HTTP API] [DEBUG] Serving file from cache: {}",
                    file_hash_str
                ));
                return Ok(Response::builder()
                    .status(hyper::StatusCode::OK)
                    .header("Content-Type", cached_mime)
                    .header("Content-Length", cached_content.len().to_string())
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(Full::new(Bytes::from(cached_content)).boxed())
                    .unwrap());
            }

            if this_peer_storage_file {
                let file_hash_str = file_hash_clone.unwrap();
                logger::debug(&format!(
                    "[HTTP API] [DEBUG] File is stored on this peer, reading from local storage"
                ));

                let file_path = format!("{}/{}", self.path_blobs, file_hash_str);
                logger::debug(&format!("[HTTP API] [DEBUG] File path: {}", file_path));

                if !std::path::Path::new(&file_path).exists() {
                    logger::debug(&format!(
                        "[HTTP API] [DEBUG] File not found at path: {}",
                        file_path
                    ));
                    return Ok(Response::builder()
                        .status(hyper::StatusCode::NOT_FOUND)
                        .header("Access-Control-Allow-Origin", "*")
                        .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                        .header("Access-Control-Allow-Headers", "Content-Type")
                        .body(full("File not found"))
                        .unwrap());
                }

                let file_content = std::fs::read(&file_path).unwrap();
                let mime_type = mime.unwrap_or("application/octet-stream".to_string());
                logger::debug(&format!(
                    "[HTTP API] [DEBUG] File read successfully, size: {} bytes, mime: {}",
                    file_content.len(),
                    mime_type
                ));

                return Ok(Response::builder()
                    .status(hyper::StatusCode::OK)
                    .header("Content-Type", mime_type)
                    .header("Content-Length", file_content.len().to_string())
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(Full::new(Bytes::from(file_content)).boxed())
                    .unwrap());
            }
        }

        logger::debug(&format!(
            "[HTTP API] [DEBUG] Initiating file request from network"
        ));
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(request_id.clone(), tx);

        let packet = TransportPacket {
            act: "get_file".to_string(),
            to: storage_peer_id.clone(),
            data: Some(TransportData::PeerFileGet(PeerFileGet {
                token: None,
                peer_id: self.db.get_or_create_peer_id().unwrap(),
                file_hash: file_hash_clone.clone().unwrap_or(indentificator.clone()),
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: request_id.clone(),
            nodes: vec![],
        };
        logger::debug(&format!(
            "[HTTP API] [DEBUG] Sending get_file packet: {:?}",
            packet
        ));

        if self.api_tx.is_closed() {
            logger::debug(&format!(
                "[HTTP API] [DEBUG] Channel is closed, attempting to reconnect..."
            ));
            return Ok(Response::builder()
                .status(hyper::StatusCode::SERVICE_UNAVAILABLE)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("Service temporarily unavailable"))
                .unwrap());
        }

        if let Err(e) = self.api_tx.send(packet).await {
            logger::debug(&format!(
                "[HTTP API] [DEBUG] Failed to send get_file packet: {}",
                e
            ));
            return Ok(Response::builder()
                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full(format!("Failed to send packet: {}", e)))
                .unwrap());
        }

        logger::debug(&format!("[HTTP API] [DEBUG] Waiting for file response"));
        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(response)) => {
                logger::debug(&format!(
                    "[HTTP API] [DEBUG] File response received: {:?}",
                    response
                ));
                if let Some(TransportData::FileData(file_data)) = response.data {
                    let file_content = file_data.contents;
                    self.file_cache.cache_file(
                        file_hash_clone.clone().unwrap_or(indentificator.clone()),
                        file_content.clone(),
                        file_data.mime.clone(),
                    );
                    Ok(Response::builder()
                        .status(hyper::StatusCode::OK)
                        .header("Content-Type", &file_data.mime)
                        .header("Content-Length", file_content.len().to_string())
                        .header("Access-Control-Allow-Origin", "*")
                        .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                        .header("Access-Control-Allow-Headers", "Content-Type")
                        .body(full(file_content))
                        .unwrap())
                } else {
                    logger::debug(&format!("[HTTP API] [DEBUG] Invalid response format"));
                    Ok(Response::builder()
                        .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                        .header("Access-Control-Allow-Origin", "*")
                        .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                        .header("Access-Control-Allow-Headers", "Content-Type")
                        .body(full("Invalid response format"))
                        .unwrap())
                }
            }
            _ => {
                logger::debug(&format!("[HTTP API] [DEBUG] File request timeout"));
                Ok(Response::builder()
                    .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full("Request timeout"))
                    .unwrap())
            }
        }
    }

    async fn handle_list_files(
        &self,
        _req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let files = match self.db.get_storage_fragments() {
            Ok(f) => f,
            Err(e) => {
                return Ok(Response::builder()
                    .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full(format!("Failed to get files: {}", e)))
                    .unwrap());
            }
        };

        let response_json = serde_json::to_string(&files).unwrap();
        Ok(Response::builder()
            .status(hyper::StatusCode::OK)
            .header("Content-Type", "application/json")
            .header("Access-Control-Allow-Origin", "*")
            .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
            .header("Access-Control-Allow-Headers", "Content-Type")
            .body(full(response_json))
            .unwrap())
    }

    async fn handle_upload_file(
        &self,
        req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let content_type = req
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("");

        if !content_type.starts_with("multipart/form-data") {
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("Only multipart/form-data is supported"))
                .unwrap());
        }

        let boundary = match content_type.split("boundary=").nth(1) {
            Some(b) => b,
            None => {
                return Ok(Response::builder()
                    .status(hyper::StatusCode::BAD_REQUEST)
                    .body(full("Missing boundary in multipart request"))
                    .unwrap());
            }
        };

        let boundary_bytes = format!("--{}", boundary).into_bytes();
        let whole_body = req.collect().await?.to_bytes();
        let mut filename = String::new();
        let mut contents = Vec::new();
        let mut public = true;
        let mut encrypted = false;
        let mut compressed = false;
        let mut auto_decompress = false;
        let mut token = String::new();

        logger::debug(&format!(
            "[HTTP API] Received request body size: {} bytes",
            whole_body.len()
        ));

        // Разбиваем тело на части по boundary
        let mut current_pos = 0;
        while current_pos < whole_body.len() {
            // Ищем начало следующей части
            let mut part_start = None;
            for i in current_pos..whole_body.len() {
                if whole_body[i..].starts_with(&boundary_bytes) {
                    part_start = Some(i);
                    break;
                }
            }

            if part_start.is_none() {
                break;
            }

            let part_start = part_start.unwrap();
            if part_start > current_pos {
                current_pos = part_start;
            }

            // Пропускаем boundary и \r\n
            current_pos += boundary_bytes.len() + 2;

            // Ищем конец заголовков
            let mut header_end = None;
            for i in current_pos..whole_body.len() {
                if whole_body[i..].starts_with(b"\r\n\r\n") {
                    header_end = Some(i + 4);
                    break;
                }
            }

            if header_end.is_none() {
                break;
            }

            let header_end = header_end.unwrap();
            let headers = &whole_body[current_pos..header_end];
            current_pos = header_end;

            // Ищем конец части
            let mut part_end = None;
            for i in current_pos..whole_body.len() {
                if whole_body[i..].starts_with(&boundary_bytes) {
                    part_end = Some(i);
                    break;
                }
            }

            if part_end.is_none() {
                part_end = Some(whole_body.len());
            }

            let part_end = part_end.unwrap();
            let content = &whole_body[current_pos..part_end];
            current_pos = part_end;

            // Парсим заголовки
            let mut content_disposition = String::new();
            for line in headers.split(|&b| b == b'\n') {
                if line.starts_with(b"Content-Disposition:") {
                    content_disposition = String::from_utf8_lossy(line).to_string();
                    break;
                }
            }

            logger::debug(&format!(
                "[HTTP API] Processing part: disposition={}, content_length={}",
                content_disposition,
                content.len()
            ));

            if content_disposition.contains("name=\"file\"") {
                if let Some(start) = content_disposition.find("filename=\"") {
                    let start = start + 10;
                    if let Some(end) = content_disposition[start..].find("\"") {
                        filename = content_disposition[start..start + end].to_string();
                    }
                }
                contents = content.to_vec();
                logger::debug(&format!(
                    "[HTTP API] File part found: filename={}, size={}",
                    filename,
                    contents.len()
                ));
            } else if content_disposition.contains("name=\"public\"") {
                public = std::str::from_utf8(content).unwrap_or("true").trim() == "true";
            } else if content_disposition.contains("name=\"encrypted\"") {
                encrypted = std::str::from_utf8(content).unwrap_or("false").trim() == "true";
            } else if content_disposition.contains("name=\"compressed\"") {
                compressed = std::str::from_utf8(content).unwrap_or("false").trim() == "true";
            } else if content_disposition.contains("name=\"auto_decompress\"") {
                auto_decompress = std::str::from_utf8(content).unwrap_or("false").trim() == "true";
            } else if content_disposition.contains("name=\"token\"") {
                token = std::str::from_utf8(content)
                    .unwrap_or("")
                    .trim()
                    .to_string();
            }
        }

        if contents.is_empty() {
            logger::debug("[HTTP API] No file content found in request");
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("No file content found in request"))
                .unwrap());
        }

        if filename.is_empty() {
            logger::debug("[HTTP API] No filename found in request");
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("No filename found in request"))
                .unwrap());
        }

        let request_id = Uuid::new_v4().to_string();
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(request_id.clone(), tx);

        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let file_hash = hex::encode(Sha256::digest(&contents));
        let mime = mime_guess::from_path(&filename)
            .first_or_text_plain()
            .to_string();

        logger::debug(&format!(
            "[HTTP API] Processing file upload: filename={}, size={} bytes, mime={}, hash={}",
            filename,
            contents.len(),
            mime,
            file_hash
        ));

        let packet = TransportPacket {
            act: "save_file".to_string(),
            to: None,
            data: Some(TransportData::PeerUploadFile(PeerUploadFile {
                filename,
                contents,
                peer_id: my_peer_id.clone(),
                token,
                file_hash: file_hash.clone(),
                mime,
                public,
                encrypted,
                compressed,
                auto_decompress,
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: request_id.clone(),
            nodes: vec![],
        };

        logger::debug(&format!(
            "[HTTP API] Sending save_file packet with request_id: {}",
            request_id
        ));

        if let Err(e) = self.api_tx.send(packet).await {
            logger::debug(&format!(
                "[HTTP API] Failed to send save_file packet: {}",
                e
            ));
            return Ok(Response::builder()
                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full(format!("Failed to send packet: {}", e)))
                .unwrap());
        }

        logger::debug(&format!("[HTTP API] Waiting for save_file response..."));
        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(_)) => {
                logger::debug(&format!(
                    "[HTTP API] File successfully saved with hash: {}",
                    file_hash
                ));
                Ok(Response::builder()
                    .status(hyper::StatusCode::OK)
                    .header("Content-Type", "application/json")
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full(format!(
                        "{{\"status\":\"success\",\"file_hash\":\"{}\"}}",
                        file_hash
                    )))
                    .unwrap())
            }
            _ => {
                logger::debug(&format!("[HTTP API] Save file request timed out"));
                Ok(Response::builder()
                    .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full("Request timeout"))
                    .unwrap())
            }
        }
    }

    async fn handle_update_file(
        &self,
        req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let content_type = req
            .headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("");

        if !content_type.starts_with("multipart/form-data") {
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("Only multipart/form-data is supported"))
                .unwrap());
        }

        let boundary = match content_type.split("boundary=").nth(1) {
            Some(b) => b,
            None => {
                return Ok(Response::builder()
                    .status(hyper::StatusCode::BAD_REQUEST)
                    .body(full("Missing boundary in multipart request"))
                    .unwrap());
            }
        };

        let boundary_bytes = format!("--{}", boundary).into_bytes();
        let whole_body = req.collect().await?.to_bytes();
        let mut file_hash = String::new();
        let mut contents = Vec::new();
        let mut public = true;
        let mut encrypted = false;
        let mut compressed = false;
        let mut auto_decompress = false;
        let mut token = String::new();

        let parts = whole_body.split(|&b| {
            boundary_bytes.iter().any(|&boundary_byte| b == boundary_byte)
        });
        for part in parts {
            if part.is_empty() || part == b"--\r\n" {
                continue;
            }

            let mut headers = Vec::new();
            let mut content = Vec::new();
            let mut is_content = false;

            let mut header_end = 0;
            for (i, window) in part.windows(4).enumerate() {
                if window == b"\r\n\r\n" {
                    header_end = i + 4;
                    break;
                }
            }

            let header_slice = &part[..header_end];
            for line in header_slice.split(|&b| b == b'\n') {
                if !line.is_empty() && line != b"\r" {
                    headers.push(line);
                }
            }

            content = part[header_end..].to_vec();

            // Удаляем завершающий \r\n если он есть
            if content.ends_with(b"\r\n") {
                content.truncate(content.len() - 2);
            }

            let content_disposition = headers
                .iter()
                .find(|h| h.starts_with(b"Content-Disposition:"))
                .and_then(|h| std::str::from_utf8(h).ok())
                .unwrap_or("");

            logger::debug(&format!(
                "[HTTP API] Processing part: disposition={}, content_length={}",
                content_disposition,
                content.len()
            ));

            if content_disposition.contains("name=\"file\"") {
                contents = content;
            } else if content_disposition.contains("name=\"file_hash\"") {
                file_hash = std::str::from_utf8(&content)
                    .unwrap_or("")
                    .trim()
                    .to_string();
            } else if content_disposition.contains("name=\"public\"") {
                public = std::str::from_utf8(&content).unwrap_or("true").trim() == "true";
            } else if content_disposition.contains("name=\"encrypted\"") {
                encrypted = std::str::from_utf8(&content).unwrap_or("false").trim() == "true";
            } else if content_disposition.contains("name=\"compressed\"") {
                compressed = std::str::from_utf8(&content).unwrap_or("false").trim() == "true";
            } else if content_disposition.contains("name=\"auto_decompress\"") {
                auto_decompress = std::str::from_utf8(&content).unwrap_or("false").trim() == "true";
            } else if content_disposition.contains("name=\"token\"") {
                token = std::str::from_utf8(&content)
                    .unwrap_or("")
                    .trim()
                    .to_string();
            }
        }

        let request_id = Uuid::new_v4().to_string();
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(request_id.clone(), tx);

        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let new_file_hash = hex::encode(Sha256::digest(&contents));

        logger::debug(&format!(
            "[HTTP API] Processing file update: old_hash={}, new_hash={}, size={} bytes",
            file_hash,
            new_file_hash,
            contents.len()
        ));

        let packet = TransportPacket {
            act: "update_file".to_string(),
            to: None,
            data: Some(TransportData::PeerFileUpdate(PeerFileUpdate {
                peer_id: my_peer_id.clone(),
                file_hash: file_hash.clone(),
                filename: "".to_string(),
                contents,
                token,
                mime: "".to_string(),
                public,
                encrypted,
                compressed,
                auto_decompress,
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: request_id.clone(),
            nodes: vec![],
        };

        logger::debug(&format!(
            "[HTTP API] Sending update_file packet with request_id: {}",
            request_id
        ));

        if let Err(e) = self.api_tx.send(packet).await {
            logger::debug(&format!(
                "[HTTP API] Failed to send update_file packet: {}",
                e
            ));
            return Ok(Response::builder()
                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full(format!("Failed to send packet: {}", e)))
                .unwrap());
        }

        logger::debug(&format!("[HTTP API] Waiting for update_file response..."));
        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(_)) => {
                logger::debug(&format!(
                    "[HTTP API] File successfully updated with hash: {}",
                    file_hash
                ));
                Ok(Response::builder()
                    .status(hyper::StatusCode::OK)
                    .header("Content-Type", "application/json")
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full(format!(
                        "{{\"status\":\"success\",\"file_hash\":\"{}\"}}",
                        file_hash
                    )))
                    .unwrap())
            }
            _ => {
                logger::debug(&format!("[HTTP API] Update file request timed out"));
                Ok(Response::builder()
                    .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full("Request timeout"))
                    .unwrap())
            }
        }
    }

    async fn handle_delete_file(
        &self,
        req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let path = req.uri().path();
        let file_hash = path.strip_prefix("/api/file/").unwrap_or("");

        if file_hash.is_empty() {
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("File hash is required"))
                .unwrap());
        }

        let request_id = Uuid::new_v4().to_string();
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(request_id.clone(), tx);

        let packet = TransportPacket {
            act: "delete_file".to_string(),
            to: None,
            data: Some(TransportData::FragmentSearchRequest(
                FragmentSearchRequest {
                    query: file_hash.to_string(),
                    request_id: request_id.clone(),
                },
            )),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: request_id.clone(),
            nodes: vec![],
        };

        if let Err(e) = self.api_tx.send(packet).await {
            return Ok(Response::builder()
                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full(format!("Failed to send packet: {}", e)))
                .unwrap());
        }

        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(_)) => Ok(Response::builder()
                .status(hyper::StatusCode::OK)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("File deleted successfully"))
                .unwrap()),
            _ => Ok(Response::builder()
                .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("Request timeout"))
                .unwrap()),
        }
    }

    async fn handle_change_file_access(
        &self,
        req: Request<Incoming>,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        let path = req.uri().path().to_string();
        let whole_body = req.collect().await?.to_bytes();
        let file_hash = path
            .strip_prefix("/api/file/")
            .and_then(|p| p.strip_suffix("/access"))
            .unwrap_or("");

        if file_hash.is_empty() {
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("File hash is required"))
                .unwrap());
        }

        let access_request: FileAccessRequest = match serde_json::from_slice(&whole_body) {
            Ok(r) => r,
            Err(e) => {
                return Ok(Response::builder()
                    .status(hyper::StatusCode::BAD_REQUEST)
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type")
                    .body(full(format!("Invalid request format: {}", e)))
                    .unwrap());
            }
        };

        let request_id = Uuid::new_v4().to_string();
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(request_id.clone(), tx);

        let packet = TransportPacket {
            act: "change_file_access".to_string(),
            to: None,
            data: Some(TransportData::FragmentSearchRequest(
                FragmentSearchRequest {
                    query: file_hash.to_string(),
                    request_id: request_id.clone(),
                },
            )),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: request_id.clone(),
            nodes: vec![],
        };

        if let Err(e) = self.api_tx.send(packet).await {
            return Ok(Response::builder()
                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full(format!("Failed to send packet: {}", e)))
                .unwrap());
        }

        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(_)) => Ok(Response::builder()
                .status(hyper::StatusCode::OK)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("File access changed successfully"))
                .unwrap()),
            _ => Ok(Response::builder()
                .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                .header("Access-Control-Allow-Origin", "*")
                .header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                .header("Access-Control-Allow-Headers", "Content-Type")
                .body(full("Request timeout"))
                .unwrap()),
        }
    }
}


=== ../src\http\http_proxy.rs ===
use crate::config::Config;
use crate::db::P2PDatabase;
use crate::packets::{
    FileRequest, FragmentSearchRequest, Protocol, ProxyMessage, TransportData, TransportPacket,
};
use bytes::Bytes;
use colored::Colorize;
use dashmap::DashMap;
use flate2::read::{GzDecoder, GzEncoder};
use flate2::Compression;
use http_body_util::{combinators::BoxBody, BodyExt, Full};
use hyper::server::conn::http1;
use hyper::service::service_fn;
use hyper::{body::Incoming, Request, Response};
use hyper_util::rt::tokio::TokioIo;
use std::io::{self, Read};
use std::time::{Duration, Instant};
use std::{convert::Infallible, net::SocketAddr, sync::Arc};
use tokio::net::TcpListener;
use tokio::sync::{mpsc, oneshot};
use uuid::Uuid;
use crate::logger;

#[derive(Clone, Debug)]
struct CachedFile {
    content: Vec<u8>,
    mime_type: String,
    expires_at: Instant,
}

#[derive(Clone, Debug)]
pub struct HttpProxy {
    db: Arc<P2PDatabase>,
    proxy_tx: mpsc::Sender<TransportPacket>,
    pending_responses: Arc<DashMap<String, oneshot::Sender<TransportPacket>>>,
    fragment_cache: Arc<DashMap<String, String>>,
    file_cache: Arc<DashMap<String, CachedFile>>,
    path_blobs: String,
}

impl HttpProxy {
    pub fn new(
        db: Arc<P2PDatabase>,
        proxy_tx: mpsc::Sender<TransportPacket>,
        path_blobs: String,
    ) -> Self {
        Self {
            db,
            proxy_tx,
            pending_responses: Arc::new(DashMap::new()),
            fragment_cache: Arc::new(DashMap::new()),
            file_cache: Arc::new(DashMap::new()),
            path_blobs: path_blobs,
        }
    }

    pub async fn set_response(&self, request_id: String, response: TransportPacket) {
        logger::info(&format!("[HTTP Proxy] Set response for request: {}", request_id));
        if let Some((_, sender)) = self.pending_responses.remove(&request_id) {
            let _ = sender.send(response);
        }
    }

    pub async fn start(self: Arc<Self>) {
        let config = Config::from_file("config.toml");
        let mut port = config.proxy_port;
        let mut listener = None;

        while listener.is_none() {
            let addr = SocketAddr::from(([0, 0, 0, 0], port));
            match TcpListener::bind(addr).await {
                Ok(l) => {
                    listener = Some(l);
                    logger::info(&format!("[HTTP Proxy] Listening on http://{}", addr));
                }
                Err(_) => {
                    logger::warning(&format!("[HTTP Proxy] Port {} is busy, trying {}", port, port + 1));
                    port += 1;
                }
            }
        }

        let listener = listener.unwrap();

        loop {
            let (stream, socket) = listener.accept().await.unwrap();
            let peer_ip = format!(
                "{}:{}",
                stream.peer_addr().unwrap().ip().to_string(),
                stream.peer_addr().unwrap().port()
            );
            logger::info(&format!("[HTTP Proxy] Peer IP: {}", peer_ip));
            let proxy = self.clone();

            tokio::spawn(async move {
                let service = service_fn(move |req: Request<Incoming>| {
                    let proxy = proxy.clone();
                    let peer_ip = peer_ip.clone();
                    logger::info(&format!("[HTTP Proxy] [thread] Peer IP: {}", peer_ip));
                    async move { proxy.handle(req, peer_ip).await }
                });

                if let Err(err) = http1::Builder::new()
                    .serve_connection(TokioIo::new(stream), service)
                    .await
                {
                    logger::error(&format!("[HTTP Proxy] Connection error: {:?}", err));
                }
            });
        }
    }

    fn extract_peer_id(req: &Request<Incoming>) -> Option<String> {
        logger::debug("[HTTP Proxy] Starting peer ID extraction");

        if let Some(host) = req.headers().get("host") {
            if let Ok(host_str) = host.to_str() {
                logger::debug(&format!("[HTTP Proxy] Checking host header: {}", host_str));
                if host_str.chars().all(|c| c.is_ascii_hexdigit()) {
                    logger::debug(&format!("[HTTP Proxy] Found valid peer ID in host: {}", host_str));
                    return Some(host_str.to_string());
                }
            }
        }

        let path = req.uri().path();
        logger::debug(&format!("[HTTP Proxy] Checking URI path: {}", path));

        for segment in path.split('/') {
            if !segment.is_empty() && segment.chars().all(|c| c.is_ascii_hexdigit()) {
                logger::debug(&format!("[HTTP Proxy] Found valid peer ID in URI path: {}", segment));
                return Some(segment.to_string());
            }
        }

        if let Some(query) = req.uri().query() {
            logger::debug(&format!("[HTTP Proxy] Checking query parameters: {}", query));
            for param in query.split('&') {
                let parts: Vec<&str> = param.split('=').collect();
                if parts.len() == 2 {
                    let value = parts[1];
                    if value.chars().all(|c| c.is_ascii_hexdigit()) {
                        logger::debug(&format!("[HTTP Proxy] Found valid peer ID in query: {}", value));
                        return Some(value.to_string());
                    }
                }
            }
        }

        logger::debug("[HTTP Proxy] No valid peer ID found in request");
        None
    }

    async fn get_hash_file_from_request(&self, req: &Request<Incoming>, client_ip: &str) -> String {
        logger::debug(&format!("[HTTP Proxy] Starting peer ID extraction for client IP: {}", client_ip));
        let mut peer_id = None;

        if peer_id.is_none() {
            if let Some(extracted) = Self::extract_peer_id(req) {
                logger::debug(&format!("[HTTP Proxy] Successfully extracted peer ID from request: {}", extracted));
                peer_id = Some(extracted);
            } else {
                logger::debug("[HTTP Proxy] No peer ID found in request, checking client mapping");
            }
        }

        let peer_id = peer_id.unwrap_or_else(|| {
            logger::debug("[HTTP Proxy] No peer ID found, using empty string");
            "".to_string()
        });

        peer_id
    }

    async fn handle(
        &self,
        req: Request<Incoming>,
        client_ip: String,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        logger::info(&format!("[HTTP Proxy] Request Method: {}", req.method()));
        logger::info(&format!("[HTTP Proxy] Request URI: {}", req.uri()));
        logger::info("[HTTP Proxy] Request Headers:");
        for (name, value) in req.headers() {
            logger::info(&format!("  {}: {}", name, value.to_str().unwrap_or("(invalid)")));
        }

        let mut hash_file = self.get_hash_file_from_request(&req, &client_ip).await;
        logger::info(&format!("[HTTP Proxy] Hash File: {}", hash_file));

        let mut request_str = String::new();
        request_str.push_str(&format!("{} {} HTTP/1.1\r\n", req.method(), req.uri()));

        for (name, value) in req.headers() {
            request_str.push_str(&format!(
                "{}: {}\r\n",
                name,
                value.to_str().unwrap_or("(invalid)")
            ));
        }

        request_str.push_str("\r\n");

        let whole_body = req.collect().await?.to_bytes();
        if !whole_body.is_empty() {
            request_str.push_str(&String::from_utf8_lossy(&whole_body));
        }

        let request_id = Uuid::new_v4().to_string();
        let mut this_peer_storage_file = false;
        let mut file_hash = None;
        let mut peer_id = None;
        let mut mime = None;

        let is_hash = hash_file.len() == 64 && hash_file.chars().all(|c| c.is_ascii_hexdigit());

        if !is_hash {
            logger::error("[HTTP Proxy] [ERROR] Invalid hash format or length. Expected 64 characters hex string");
            return Ok(Response::builder()
                .status(hyper::StatusCode::BAD_REQUEST)
                .body(full(
                    "Invalid hash format. Expected 64 characters hex string",
                ))
                .unwrap());
        }

        logger::debug("[HTTP Proxy] [DEBUG] Searching for fragments by hash");

        if let Some(cached_owner) = self.fragment_cache.get(&hash_file) {
            logger::debug(&format!("[HTTP Proxy] [DEBUG] Found cached owner for hash: {}", cached_owner.clone()));
            peer_id = Some(cached_owner.clone());
            this_peer_storage_file = *cached_owner == *self.db.get_or_create_peer_id().unwrap();
            if this_peer_storage_file {
                if let Ok(fragments) = self.db.search_fragment_in_virtual_storage(&hash_file, None)
                {
                    if let Some(fragment) = fragments.first() {
                        file_hash = Some(fragment.file_hash.clone());
                        mime = Some(fragment.mime.clone());
                    }
                }
            }
        } else {
            logger::debug("[HTTP Proxy] [DEBUG] No cached owner found, searching in storage");
            if let Ok(fragments) = self.db.search_fragment_in_virtual_storage(&hash_file, None) {
                if let Some(fragment) = fragments.first() {
                    logger::debug("[HTTP Proxy] [DEBUG] Found fragment in local storage");
                    peer_id = Some(fragment.storage_peer_key.clone());
                    this_peer_storage_file =
                        fragment.storage_peer_key == self.db.get_or_create_peer_id().unwrap();
                    file_hash = Some(fragment.file_hash.clone());
                    mime = Some(fragment.mime.clone());
                } else {
                    logger::debug(
                        "[HTTP Proxy] [DEBUG] No fragment found locally, sending search request"
                    );
                    let search_packet = TransportPacket {
                        act: "search_fragments".to_string(),
                        to: None,
                        data: Some(TransportData::FragmentSearchRequest(
                            FragmentSearchRequest {
                                query: hash_file.clone(),
                                request_id: request_id.clone(),
                            },
                        )),
                        protocol: Protocol::TURN,
                        peer_key: self.db.get_or_create_peer_id().unwrap(),
                        uuid: request_id.clone(),
                        nodes: vec![],
                    };

                    let (search_tx, search_rx) = oneshot::channel();
                    self.pending_responses.insert(request_id.clone(), search_tx);

                    logger::debug("[HTTP Proxy] [DEBUG] Sending search packet");
                    self.proxy_tx.send(search_packet).await.unwrap();
                    logger::debug("[HTTP Proxy] [DEBUG] Search packet sent, waiting for response");

                    if let Ok(search_response) =
                        tokio::time::timeout(tokio::time::Duration::from_secs(5), search_rx).await
                    {
                        logger::debug("[HTTP Proxy] [DEBUG] Got search response");
                        if let Ok(response_data) = search_response {
                            logger::debug(&format!("[HTTP Proxy] Search response: {:?}", response_data));
                            if let Some(TransportData::FragmentSearchResponse(response)) =
                                response_data.data
                            {
                                for fragment in response.fragments {
                                    if fragment.file_hash == hash_file {
                                        logger::debug("[HTTP Proxy] [DEBUG] Found matching fragment in search response");
                                        self.fragment_cache.insert(
                                            hash_file.clone(),
                                            fragment.storage_peer_key.clone(),
                                        );
                                        peer_id = Some(fragment.storage_peer_key.clone());
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        logger::debug("[HTTP Proxy] [DEBUG] Search response timeout");
                    }
                }
            }
        }

        let file_hash_clone = file_hash.clone();
        if file_hash.is_some() {
            let file_hash_str = file_hash.unwrap();
            logger::info(&format!("[HTTP PROXY] Processing file request for hash: {}", file_hash_str));

            if let Some((cached_content, cached_mime)) = self.get_cached_file(&file_hash_str) {
                logger::info(&format!("[HTTP PROXY] Serving file from cache: {}", file_hash_str));

                let mut decoder = GzDecoder::new(&cached_content[..]);
                let mut decompressed = Vec::new();
                decoder.read_to_end(&mut decompressed).unwrap();

                return Ok(Response::builder()
                    .status(hyper::StatusCode::OK)
                    .header("Content-Type", cached_mime)
                    .header("Cache-Control", "no-cache")
                    .body(Full::new(Bytes::from(decompressed)).boxed())
                    .unwrap());
            }

            if this_peer_storage_file {
                logger::info("[HTTP PROXY] File is stored locally, serving from disk");
                let file_hash_str = file_hash_clone.unwrap();

                let file_path = format!("{}/{}", self.path_blobs, file_hash_str);
                logger::info(&format!("[HTTP PROXY] File path: {}", file_path));

                if !std::path::Path::new(&file_path).exists() {
                    logger::info(&format!("[HTTP PROXY] File not found at path: {}", file_path));
                    return Ok(Response::builder()
                        .status(hyper::StatusCode::NOT_FOUND)
                        .body(full("File not found"))
                        .unwrap());
                }

                let file_content = std::fs::read(&file_path).unwrap();
                let mime_type = mime.unwrap_or("application/octet-stream".to_string());

                let mut encoder = GzEncoder::new(&file_content[..], Compression::best());
                let mut compressed = Vec::new();
                encoder.read_to_end(&mut compressed).unwrap();

                logger::info(&format!("[HTTP PROXY] Caching file with hash: {}", file_hash_str));
                self.cache_file(file_hash_str.clone(), compressed.clone(), mime_type.clone());

                return Ok(Response::builder()
                    .status(hyper::StatusCode::OK)
                    .header("Content-Type", mime_type)
                    .header("Content-Encoding", "gzip")
                    .header("Cache-Control", "no-cache")
                    .body(Full::new(Bytes::from(compressed)).boxed())
                    .unwrap());
            }
        }

        logger::debug("[HTTP Proxy] [DEBUG] Preparing to send file request packet");
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(request_id.clone(), tx);

        let packet = TransportPacket {
            act: "http_proxy_request".to_string(),
            to: peer_id.clone(),
            data: Some(TransportData::FileRequest(FileRequest {
                file_hash: hash_file.clone(),
                request_id: request_id.clone(),
                from_peer_id: self.db.get_or_create_peer_id().unwrap(),
                end_peer_id: peer_id.clone().unwrap_or_default(),
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: request_id.clone(),
            nodes: vec![],
        };

        logger::debug("[HTTP Proxy] [DEBUG] Sending file request packet");
        self.proxy_tx.send(packet).await.unwrap();
        logger::debug("[HTTP Proxy] [DEBUG] File request packet sent, waiting for response");

        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(packet)) => {
                logger::debug("[HTTP Proxy] [DEBUG] Got file response packet");
                if let Some(TransportData::ProxyMessage(msg)) = packet.data {
                    let file_content = msg.text;
                    let mime_type = msg.mime.clone();
                    let nonce = msg.nonce;

                    let decrypted = match self.db.decrypt_message(
                        &file_content,
                        nonce,
                        &peer_id.unwrap_or_default(),
                    ) {
                        Ok(d) => d,
                        Err(_) => {
                            return Ok(Response::builder()
                                .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                                .body(full("Failed to decrypt file content"))
                                .unwrap());
                        }
                    };

                    let mut decoder = GzDecoder::new(&decrypted[..]);
                    let mut decompressed = Vec::new();
                    if decoder.read_to_end(&mut decompressed).is_err() {
                        decompressed = decrypted.clone();
                    }

                    let mut response_builder = Response::builder()
                        .status(hyper::StatusCode::OK)
                        .header("Content-Type", &mime_type)
                        .header("Content-Length", decompressed.len().to_string())
                        .header("Cache-Control", "no-cache")
                        .header("X-Content-Type-Options", "nosniff");

                    if file_hash_clone.is_some() {
                        self.cache_file(
                            file_hash_clone.unwrap(),
                            decrypted.clone(),
                            mime_type.clone(),
                        );
                    }

                    Ok(response_builder
                        .body(Full::new(Bytes::from(decompressed)).boxed())
                        .unwrap())
                } else {
                    logger::error("[HTTP Proxy] Received invalid packet data");
                    return Ok(Response::builder()
                        .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                        .body(full("Invalid packet data"))
                        .unwrap());
                }
            }
            _ => Ok(Response::builder()
                .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                .body(full("Proxy timeout"))
                .unwrap()),
        }
    }

    fn cache_file(&self, file_hash: String, content: Vec<u8>, mime_type: String) {
        logger::info(&format!("[HTTP PROXY] Caching file with hash: {}", file_hash));
        let cached_file = CachedFile {
            content,
            mime_type,
            expires_at: Instant::now() + Duration::from_secs(60), //300
        };

        let cache = self.file_cache.clone();
        let file_hash_clone = file_hash.clone();

        tokio::spawn(async move {
            cache.insert(file_hash_clone, cached_file);
            logger::info(&format!("[HTTP PROXY] File cached successfully: {}", file_hash));
        });
    }

    fn get_cached_file(&self, file_hash: &str) -> Option<(Vec<u8>, String)> {
        logger::debug(&format!("[HTTP PROXY] Checking cache for file: {}", file_hash));
        match self.file_cache.get(file_hash) {
            Some(cached) => {
                if cached.expires_at > Instant::now() {
                    logger::debug(&format!("[HTTP PROXY] Cache hit for file: {}", file_hash));
                    return Some((cached.content.clone(), cached.mime_type.clone()));
                } else {
                    logger::debug(&format!("[HTTP PROXY] Cache expired for file: {}", file_hash));
                    let file_hash = file_hash.to_string();
                    let cache = self.file_cache.clone();

                    tokio::spawn(async move {
                        if cache.remove_if(&file_hash, |_, _| true).is_some() {
                            logger::debug(&format!("[HTTP PROXY] Cache removed for file: {}", file_hash));
                        } else {
                            logger::error(&format!("[HTTP PROXY] Failed to remove cache for file: {}", file_hash));
                        }
                    });
                }
            }
            None => {
                logger::debug(&format!("[HTTP PROXY] Cache miss for file: {}", file_hash));
            }
        }
        None
    }
}

fn full<T: Into<Bytes>>(chunk: T) -> BoxBody<Bytes, Infallible> {
    Full::new(chunk.into()).map_err(|_| unreachable!()).boxed()
}


=== ../src\http\mod.rs ===
pub mod proxy;
pub mod http_proxy;
pub mod http_api;
pub mod api;

=== ../src\http\proxy.rs ===
use std::sync::Arc;
use std::io::{self, Read};
use flate2::read::GzEncoder;
use flate2::Compression;

use crate::connection::Connection;
use crate::manager::ConnectionManager::ConnectionManager;
use crate::packets::{Protocol, ProxyMessage, TransportData, TransportPacket, FileRequest};

pub async fn handle_http_proxy_response(
    packet: TransportPacket,
    connection: &Connection,
    manager: Arc<ConnectionManager>,
    path_blobs: String,
) -> Result<(), String> {
    if let Some(TransportData::FileRequest(msg)) = packet.data {
        println!("[HTTP Proxy] Received file request: {:?}", msg);

        let file_hash = msg.file_hash;
        let file_path = format!("{}/{}", path_blobs, file_hash);
        println!("[HTTP Proxy] File path: {}", file_path);
        
        if !std::path::Path::new(&file_path).exists() {
            return Err("File not found".to_string());
        }

        let file_content = match std::fs::read(&file_path) {
            Ok(content) => content,
            Err(e) => {
                return Err(format!("Failed to read file: {}", e));
            }
        };

        let mime_type = match manager.db.search_fragment_in_virtual_storage(&file_hash, Some(true)) {
            Ok(fragments) => {
                if let Some(fragment) = fragments.first() {
                    fragment.mime.clone()
                } else {
                    "application/octet-stream".to_string()
                }
            },
            Err(_) => "application/octet-stream".to_string()
        };

        let mut encoder = GzEncoder::new(&file_content[..], Compression::best());
        let mut compressed = Vec::new();
        encoder.read_to_end(&mut compressed).unwrap();

        let (encrypted_response, nonce) = manager
            .db
            .encrypt_message(&compressed, &msg.from_peer_id)
            .map_err(|e| format!("Failed to encrypt message: {}", e))?;

        let response_packet = TransportPacket {
            act: "http_proxy_response".to_string(),
            to: Some(msg.from_peer_id.clone()),
            data: Some(TransportData::ProxyMessage(ProxyMessage {
                text: encrypted_response,
                nonce: nonce,
                mime: mime_type,
                from_peer_id: manager
                    .db
                    .get_or_create_peer_id()
                    .map_err(|e| format!("Failed to get peer ID: {}", e))?,
                end_peer_id: msg.from_peer_id.clone(),
                request_id: msg.request_id.clone(),
            })),
            protocol: Protocol::TURN,
            peer_key: manager
                .db
                .get_or_create_peer_id()
                .map_err(|e| format!("Failed to get peer ID: {}", e))?,
            uuid: manager
                .db
                .generate_uuid()
                .map_err(|e| format!("Failed to generate UUID: {}", e))?,
            nodes: vec![],
        };

        connection
            .send_packet(response_packet)
            .await
            .map_err(|e| e.to_string())
    } else {
        Ok(())
    }
}

=== ../src\http\api\cache.rs ===
use std::time::{Duration, Instant};
use dashmap::DashMap;

#[derive(Clone, Debug)]
pub struct CachedFile {
    pub content: Vec<u8>,
    pub mime_type: String,
    pub expires_at: Instant,
}

#[derive(Debug)]
pub struct FileCache {
    cache: DashMap<String, CachedFile>,
}

impl FileCache {
    pub fn new() -> Self {
        Self {
            cache: DashMap::new(),
        }
    }

    pub fn cache_file(&self, file_hash: String, content: Vec<u8>, mime_type: String) {
        let cached_file = CachedFile {
            content,
            mime_type,
            expires_at: Instant::now() + Duration::from_secs(300), // 5 minutes
        };
        self.cache.insert(file_hash, cached_file);
    }

    pub fn get_cached_file(&self, file_hash: &str) -> Option<(Vec<u8>, String)> {
        if let Some(cached) = self.cache.get(file_hash) {
            if cached.expires_at > Instant::now() {
                return Some((cached.content.clone(), cached.mime_type.clone()));
            } else {
                self.cache.remove(file_hash);
            }
        }
        None
    }
} 

=== ../src\http\api\mod.rs ===
mod models;
mod cache;
mod utils;

pub use models::*;
pub use cache::*;
pub use utils::*; 

=== ../src\http\api\models.rs ===
use serde::{Deserialize, Serialize};
use crate::packets::{Protocol, TransportData};

#[derive(Debug, Serialize, Deserialize)]
pub struct PacketRequest {
    pub to: Option<String>,
    pub data: Option<TransportData>,
    pub protocol: Protocol,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FileAccessRequest {
    pub public: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UploadRequest {
    pub filename: String,
    pub contents: Vec<u8>,
    pub public: bool,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
    pub token: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug)]
pub struct UpdateRequest {
    pub file_hash: String,
    pub contents: Vec<u8>,
    pub public: bool,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
    pub token: String,
}

#[derive(serde::Serialize)]
pub struct NodeInfo {
    pub node_id: String,
    pub host_type: String,
    pub status: String,
    pub connection_type: String,
    pub last_switch: String,
} 

=== ../src\http\api\utils.rs ===
use bytes::Bytes;
use http_body_util::{combinators::BoxBody, Full};
use std::convert::Infallible;
use http_body_util::BodyExt;

pub const SHOW_LOGS: bool = true;

pub fn log(message: &str) {
    if SHOW_LOGS {
        println!("{}", message);
    }
}

pub fn full<T: Into<Bytes>>(chunk: T) -> BoxBody<Bytes, Infallible> {
    Full::new(chunk.into()).map_err(|_| unreachable!()).boxed()
} 

=== ../src\logger\mod.rs ===
use colored::*;

static mut SHOW_DEBUG: bool = true;
static mut SHOW_INFO: bool = true;
static mut SHOW_WARNING: bool = true;
static mut SHOW_ERROR: bool = true;

pub fn set_debug(enabled: bool) {
    unsafe { SHOW_DEBUG = enabled; }
}

pub fn set_info(enabled: bool) {
    unsafe { SHOW_INFO = enabled; }
}

pub fn set_warning(enabled: bool) {
    unsafe { SHOW_WARNING = enabled; }
}

pub fn set_error(enabled: bool) {
    unsafe { SHOW_ERROR = enabled; }
}

pub fn debug(message: &str) {
    unsafe {
        if SHOW_DEBUG {
            println!("{}", format!("[DEBUG] {}", message).blue().bold());
        }
    }
}

pub fn info(message: &str) {
    unsafe {
        if SHOW_INFO {
            println!("{}", message);
        }
    }
}

pub fn warning(message: &str) {
    unsafe {
        if SHOW_WARNING {
            println!("{}", format!("[WARNING] {}", message).yellow().bold());
        }
    }
}

pub fn error(message: &str) {
    unsafe {
        if SHOW_ERROR {
            println!("{}", format!("[ERROR] {}", message).red().bold());
        }
    }
}

pub fn peer(message: &str) {
    unsafe {
        if SHOW_INFO {
            println!("{}", format!("[PEER] {}", message).cyan());
        }
    }
}

pub fn turn(message: &str) {
    unsafe {
        if SHOW_INFO {
            println!("{}", format!("[TURN] {}", message).green());
        }
    }
}

pub fn storage(message: &str) {
    unsafe {
        if SHOW_INFO {
            println!("{}", format!("[STORAGE] {}", message).magenta());
        }
    }
}

#[macro_export]
macro_rules! debug {
    ($($arg:tt)*) => {
        $crate::logger::debug(&format!($($arg)*))
    };
}

#[macro_export]
macro_rules! info {
    ($($arg:tt)*) => {
        $crate::logger::info(&format!($($arg)*))
    };
}

#[macro_export]
macro_rules! warn {
    ($($arg:tt)*) => {
        $crate::logger::warning(&format!($($arg)*))
    };
}

#[macro_export]
macro_rules! error {
    ($($arg:tt)*) => {
        $crate::logger::error(&format!($($arg)*))
    };
}

#[macro_export]
macro_rules! peer {
    ($($arg:tt)*) => {
        $crate::logger::peer(&format!($($arg)*))
    };
}

#[macro_export]
macro_rules! turn {
    ($($arg:tt)*) => {
        $crate::logger::turn(&format!($($arg)*))
    };
}

#[macro_export]
macro_rules! storage {
    ($($arg:tt)*) => {
        $crate::logger::storage(&format!($($arg)*))
    };
} 

=== ../src\manager\ConnectionManager.rs ===
use crate::commands::{create_base_commands, get_db_path, get_path_blobs};
use crate::connection::{Connection, Message};
use crate::db::P2PDatabase;
use crate::http::http_proxy::HttpProxy;
use crate::manager::types::{ConnectionTurnStatus, ConnectionType};
use crate::packets::{TransportData, TransportPacket};
use crate::peer::peer_api::PeerAPI;
use crate::tunnel::Tunnel;
use crate::ui::console_manager;
use dashmap::DashMap;
use std::sync::Arc;
use tokio::sync::{mpsc, oneshot, Mutex};

use super::types::PeerOpenNetInfo;

#[derive(Clone)]
pub struct ConnectionManager {
    pub connections: Arc<DashMap<String, Connection>>,
    pub tunnels: Arc<DashMap<String, Arc<Mutex<Tunnel>>>>,
    pub connections_stun: Arc<DashMap<String, PeerOpenNetInfo>>,

    pub incoming_packet_rx:
        Arc<Mutex<mpsc::Receiver<(ConnectionType, TransportPacket, Option<Arc<Connection>>)>>>,
    pub incoming_packet_tx:
        mpsc::Sender<(ConnectionType, TransportPacket, Option<Arc<Connection>>)>,

    pub connections_turn: Arc<DashMap<String, ConnectionTurnStatus>>,
    pub db: Arc<P2PDatabase>,
    pub http_proxy: Arc<HttpProxy>,
    pub proxy_http_tx: mpsc::Sender<TransportPacket>,

    pub proxy_http_tx_reciever: Arc<Mutex<mpsc::Sender<TransportPacket>>>,
    pub path_blobs: String,
}

impl ConnectionManager {
    pub async fn new(db: &P2PDatabase) -> Self {
        let (incoming_packet_tx, incoming_packet_rx) = mpsc::channel(4096);
        let (proxy_http_tx, mut proxy_http_rx) = mpsc::channel(4096);
        let (proxy_http_tx_reciever, mut proxy_http_rx_reciever) = mpsc::channel(4096);

        let connections_turn: Arc<DashMap<String, ConnectionTurnStatus>> = Arc::new(DashMap::new());

        let connections_stun = Arc::new(DashMap::new());

        let commands = create_base_commands();
        let path_blobs = get_path_blobs(&commands.get_matches());

        let db_arc = Arc::new(db.clone());
        let proxy_http_tx_clone = proxy_http_tx.clone();
        let proxy = Arc::new(HttpProxy::new(db_arc.clone(), proxy_http_tx_clone, path_blobs.clone()));

        let proxy_clone = Arc::clone(&proxy);
        let proxy_clone_for_spawn = proxy_clone.clone();

        let mut proxy_http_rx_reciever = proxy_http_rx_reciever;

        tokio::spawn(async move {
            proxy_clone_for_spawn.start().await;
        });

        let manager = ConnectionManager {
            connections: Arc::new(DashMap::new()),
            tunnels: Arc::new(DashMap::new()),
            connections_stun,

            incoming_packet_rx: Arc::new(Mutex::new(incoming_packet_rx)),
            incoming_packet_tx,

            connections_turn,

            db: db_arc,
            http_proxy: proxy,
            proxy_http_tx,

            proxy_http_tx_reciever: Arc::new(Mutex::new(proxy_http_tx_reciever)),
            path_blobs,
        };
        
        let manager_clone = manager.clone();
        let manager_clone_for_http = manager_clone.clone();
        tokio::spawn(async move {
            while let Some(packet) = proxy_http_rx.recv().await {
                println!(
                    "[HTTP Proxy] Getted request from http proxy: {:?}",
                    packet.to
                );
                manager_clone_for_http.auto_send_packet(packet).await;
            }
        });

        let proxy_clone_rx = proxy_clone.clone();
        tokio::spawn(async move {
            while let Some(packet) = proxy_http_rx_reciever.recv().await {
                println!(
                    "[HTTP Proxy] Getted request from http proxy: {:?}",
                    packet.to
                );
                let proxy = proxy_clone_rx.clone();
                tokio::spawn(async move {
                    let packet_clone = packet.clone();
                    match &packet_clone.data {
                        Some(TransportData::ProxyMessage(msg)) => {
                            println!(
                                "[HTTP Proxy] Getted request from http proxy: {:?}",
                                msg.from_peer_id
                            );
                            proxy
                                .set_response(msg.request_id.clone(), packet_clone)
                                .await;
                        }
                        Some(TransportData::FragmentSearchResponse(_)) => {
                            // println!(
                            //     "[HTTP Proxy] Getted FragmentSearchResponse from http proxy: {:?}",
                            //     packet_clone
                            // );
                            proxy
                                .set_response(packet_clone.uuid.clone(), packet_clone)
                                .await;
                        }
                        _ => {}
                    }
                });
            }
        });

        manager
    }

    pub async fn send_signaling_message(
        &self,
        server_address: &str,
        data: TransportPacket,
    ) -> Result<(), String> {
        if let Some(conn) = self.connections.get(server_address) {
            if let Err(e) = conn.tx.send(Message::SendData(data)).await {
                return Err(format!(
                    "Failed to send message to {}: {}",
                    server_address, e
                ));
            }
            Ok(())
        } else {
            Err(format!(
                "Signaling connection to {} not found",
                server_address
            ))
        }
    }

    pub async fn auto_send_packet(&self, packet: TransportPacket) {
        let mut sended_by_uuid = false;
        // println!("Auto send packet: {:?}", packet);

        // if let Some(to) = &packet.to {
        //     if let Some(tunnel) = self.tunnels.get(to) {
        //         match serde_json::to_string(&packet) {
        //             Ok(message) => {
        //                 tunnel.lock().await.send_message(&message).await;
        //                 println!("[DEBUG] Sended packet to tunnel {}", to);
        //                 sended_by_uuid = true;
        //             },
        //             Err(e) => println!("[ERROR] Failed to serialize packet: {}", e)
        //         }
        //     }
        // }

        if let Some(to) = &packet.to {
            if let Some(connection) = self.connections.get(to) {
                if let Err(e) = connection.send_packet(packet.clone()).await {
                    println!("[ERROR] Failed to send packet to connection {}: {}", to, e);
                } else {
                    println!(
                        "[HTTP Proxy] [AUTO SEND] Sended packet to connection {}: {:?}",
                        to, packet.to
                    );
                    sended_by_uuid = true;
                }
            }
        }

        if !sended_by_uuid {
            for entry in self.connections.iter() {
                if let Err(e) = entry.send_packet(packet.clone()).await {
                    println!(
                        "[ERROR] Failed to send packet to connection {}: {}",
                        entry.key(),
                        e
                    );
                } else {
                    println!(
                        "[HTTP Proxy] [BROADCAST] Sended packet to connection {}: {:?}",
                        entry.key(),
                        packet.to
                    );
                }
            }
        }
    }

    pub async fn add_connection(&self, id: String, connection: Arc<Connection>) {
        let tx = self.incoming_packet_tx.clone();

        self.connections_turn.insert(
            id.clone(),
            ConnectionTurnStatus {
                connected: true,
                turn_connection: true,
            },
        );

        let id_clone = id.clone();
        let connections_turn_clone = self.connections_turn.clone();

        let api = PeerAPI::new(connection.clone(), &self.db, &self);
        let api_clone = api.clone();
        let db_clone = self.db.clone();

        tokio::spawn({
            async move {
                loop {
                    console_manager(
                        Arc::new(api_clone.clone()),
                        connections_turn_clone.clone(),
                        &db_clone,
                    )
                    .await;
                }
            }
        });

        tokio::spawn({
            let tx_clone = tx.clone();
            let connection_clone = connection.clone();
            async move {
                while let Ok(response) = connection_clone.get_response().await {
                    let _ = tx_clone
                        .send((
                            ConnectionType::Signal(id_clone.clone()),
                            response,
                            Some(connection_clone.clone()),
                        ))
                        .await;
                }
            }
        });

        self.connections.insert(
            id,
            Arc::try_unwrap(connection).unwrap_or_else(|arc| (*arc).clone()),
        );
    }

    pub async fn get_tunnel(&self, id: String) -> Option<Arc<Mutex<Tunnel>>> {
        self.tunnels.get(&id).map(|t| t.clone())
    }

    pub async fn have_connection_with_peer(&self, id: String) -> bool {
        self.connections_turn
            .get(&id)
            .map(|status| status.connected)
            .unwrap_or(false)
    }

    pub async fn add_tunnel(&self, id: String, tunnel: Tunnel) {
        let tx = self.incoming_packet_tx.clone();
        let id_for_spawn = id.clone();

        let tunnel_clone = Arc::new(tokio::sync::Mutex::new(tunnel));
        let tunnel_clone_for_spawn = tunnel_clone.clone();

        tokio::spawn(async move {
            let (local_tx, mut local_rx) = mpsc::channel::<Vec<u8>>(1024);

            tokio::spawn(async move {
                while let Some(data) = local_rx.recv().await {
                    if let Ok(packet) = serde_json::from_slice(&data)
                        .map_err(|e| format!("Failed to parse TransportPacket: {}", e))
                    {
                        let _ = tx.send((ConnectionType::Signal(id_for_spawn.clone()), packet, None)).await;
                    } else {
                        println!("[ERROR] Failed to parse incoming data into TransportPacket");
                    }
                }
            });

            loop {
                let mut buf = vec![0u8; 1024];
                let mut tunnel = tunnel_clone_for_spawn.lock().await;
                if let Some(socket) = &tunnel.socket {
                    while let Ok((n, reply_addr)) = socket.recv_from(&mut buf).await {
                        let data = buf[..n].to_vec();
                        let _ = local_tx.send(data).await;
                    }
                }
            }
        });

        self.tunnels.insert(id.clone(), tunnel_clone);
    }
}


=== ../src\manager\file_handler.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::connection::Connection;
use crate::crypto::crypto::generate_uuid;
use crate::crypto::token::validate_signature_token;
use crate::db::{P2PDatabase, Storage};
use crate::packets::{
    EncryptedData, FileData, Message, PeerFileAccessChange, PeerFileDelete, PeerFileGet,
    PeerFileMove, PeerFileSaved, PeerFileUpdate, PeerUploadFile, Protocol, TransportData,
    TransportPacket,
};
use colored::*;
use hex;
use serde_json;
use sha2::{Digest, Sha256};
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

impl ConnectionManager {
    pub async fn handle_file_upload(
        &self,
        db: &P2PDatabase,
        data: PeerUploadFile,
        packet_id: String,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        println!("Get token for peer: {}", data.peer_id);

        let (token_info, token_hash, validated_token) = if data.public {
            // Для публичных файлов используем пустой токен
            (None, "".to_string(), None)
        } else {
            // Для приватных файлов проверяем токен
            let token_info = self.db.get_token(&data.peer_id)
                .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
                .ok_or_else(|| "Токен не найден в базе данных. Возможно, он был отозван или истек срок его действия".to_string())?;

            if token_info.token != data.token {
                println!(
                    "Token info: {}. Token in request: {}",
                    token_info.token, data.token
                );
                return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
            }

            let token_hash = hex::encode(Sha256::digest(data.token.as_bytes()));

            let validated_token = validate_signature_token(data.token.clone(), &self.db)
                .await
                .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

            (Some(token_info), token_hash, Some(validated_token))
        };

        let contents = data.contents;

        if let Some(token) = validated_token {
            if contents.len() as u64 > token.file_size {
                return Err(format!(
                    "Размер файла ({}) превышает разрешенный размер в токене ({})",
                    contents.len(),
                    token.file_size
                ));
            }
        }

        let free_space = self
            .db
            .get_storage_free_space()
            .await
            .map_err(|e| format!("Ошибка при получении свободного места: {:?}", e))?;

        if free_space < contents.len() as u64 {
            return Err(format!(
                "Недостаточно свободного места. Требуется: {}, Доступно: {}",
                contents.len(),
                free_space
            ));
        }

        let dir_path: String = format!("{}/blobs", self.db.path.as_str());
        if !std::path::Path::new(&dir_path).exists() {
            tokio::fs::create_dir_all(&dir_path)
                .await
                .map_err(|e| format!("Ошибка при создании директории: {}", e))?;
        }

        let final_contents = if data.compressed && data.auto_decompress {
            println!("Распаковка сжатых данных...");
            self.db
                .uncompress_data(&contents)
                .map_err(|e| format!("Ошибка распаковки: {}", e))?
        } else {
            contents
        };

        let path = format!("{}/{}", dir_path, data.file_hash);
        let mut file = File::create(&path)
            .await
            .map_err(|e| format!("Ошибка при создании файла: {}", e))?;
        file.write_all(&final_contents)
            .await
            .map_err(|e| format!("Ошибка при записи файла: {}", e))?;

        let peer_id = data.peer_id.clone();

        let file_is_compressed = if data.auto_decompress {
            false
        } else {
            data.compressed
        };

        self.db
            .add_storage_fragment(Storage {
                file_hash: data.file_hash.clone(),
                filename: data.filename.clone(),
                token: if data.public {
                    "".to_string()
                } else {
                    data.token.clone()
                },
                token_hash: if data.public {
                    None
                } else {
                    Some(token_hash.clone())
                },
                uploaded_via_token: if data.public {
                    None
                } else {
                    Some(data.token.clone())
                },
                owner_key: peer_id.clone(),
                storage_peer_key: self.db.get_or_create_peer_id().unwrap(),
                mime: data.mime.clone(),
                public: data.public,
                encrypted: data.encrypted,
                compressed: file_is_compressed,
                auto_decompress: data.auto_decompress,
                size: final_contents.len() as u64,
                tags: vec![],
                groups: vec![],
            })
            .map_err(|e| format!("Ошибка при добавлении информации о фрагменте: {}", e))?;

        println!("{}", "[Peer] Файл успешно сохранен".green());

        let packet_feedback = TransportPacket {
            act: "file_saved".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::PeerFileSaved(PeerFileSaved {
                filename: data.filename,
                token: if data.public {
                    "".to_string()
                } else {
                    data.token
                },
                token_hash: if data.public { None } else { Some(token_hash) },
                storage_peer_key: self.db.get_or_create_peer_id().unwrap(),
                owner_key: peer_id.clone(),
                hash_file: data.file_hash,
                encrypted: data.encrypted,
                compressed: file_is_compressed,
                auto_decompress: data.auto_decompress,
                public: data.public,
                size: final_contents.len() as u64,
                mime: data.mime,
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: packet_id,
            nodes: vec![],
        };

        connection
            .send_packet(packet_feedback)
            .await
            .map_err(|e| format!("Ошибка при отправке подтверждения: {}", e))?;

        connection
            .send_peer_info_request_self()
            .await
            .map_err(|e| {
                format!(
                    "Ошибка при отправке запроса на синхронизацию метаданных фрагментов: {}",
                    e
                )
            })?;
        Ok(())
    }

    pub async fn handle_file_saved(&self, data: PeerFileSaved) -> Result<(), String> {
        let token_clone = data.token.clone().to_string();
        let _ = self.db.add_storage_fragment(Storage {
            file_hash: data.hash_file.clone(),
            filename: data.filename.clone(),
            token: token_clone.clone(),
            token_hash: data.token_hash.clone(),
            uploaded_via_token: Some(data.token.clone()),
            owner_key: data.owner_key.clone(),
            storage_peer_key: data.storage_peer_key.clone(),
            mime: data.mime.clone(),
            public: data.public,
            encrypted: data.encrypted,
            compressed: data.compressed,
            auto_decompress: data.auto_decompress,
            size: data.size,
            tags: vec![],
            groups: vec![],
        });

        println!(
            "{}",
            format!("\x1b[32m[Peer] File saved. Hash: {}\x1b[0m", data.hash_file).green()
        );
        Ok(())
    }

    pub async fn handle_file_get(
        &self,
        request_id: String,
        data: PeerFileGet,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let contents = self
            .db
            .search_fragment_in_virtual_storage(&data.file_hash, None);

        if let Some(fragment) = contents.unwrap().first() {
            if !fragment.public
                && fragment.uploaded_via_token.is_some()
                && data.token.as_ref().map_or(false, |t| t != &fragment.token)
            {
                let packet_feedback = TransportPacket {
                    act: "file_get".to_string(),
                    to: Some(from_uuid.clone()),
                    data: Some(TransportData::Message(Message {
                        text: "Token is not valid".to_string(),
                        nonce: None,
                    })),
                    protocol: Protocol::TURN,
                    peer_key: self.db.get_or_create_peer_id().unwrap(),
                    uuid: generate_uuid(),
                    nodes: vec![],
                };

                connection
                    .send_packet(packet_feedback)
                    .await
                    .map_err(|e| e.to_string())?;
                return Err("Token is not valid".to_string());
            }

            let dir_path = format!("{}/blobs", self.db.path.as_str());
            let path = format!("{}/{}", dir_path, fragment.file_hash);
            let mut file = File::open(path).await.unwrap();
            let mut contents = vec![];
            file.read_to_end(&mut contents).await.unwrap();

            let packet_file = TransportPacket {
                act: "file".to_string(),
                to: Some(from_uuid.clone()),
                data: Some(TransportData::FileData(FileData {
                    filename: fragment.filename.clone().to_string(),
                    contents,
                    peer_id: self.db.get_or_create_peer_id().unwrap(),
                    hash_file: fragment.file_hash.clone(),
                    encrypted: fragment.encrypted,
                    compressed: fragment.compressed,
                    public: fragment.public,
                    mime: fragment.mime.clone(),
                    auto_decompress: fragment.auto_decompress,
                })),
                protocol: Protocol::TURN,
                peer_key: self.db.get_or_create_peer_id().unwrap(),
                uuid: request_id.clone(),
                nodes: vec![],
            };

            println!(
                "{}",
                format!("[Peer] Sending file: {}", fragment.filename.clone()).cyan()
            );
            connection
                .send_packet(packet_file)
                .await
                .map_err(|e| e.to_string())?;
        }
        Ok(())
    }

    pub async fn handle_file_data(&self, data: FileData) -> Result<(), String> {
        let dir_path: String = format!("{}/recive_files", self.db.path.as_str());
        if !std::path::Path::new(&dir_path).exists() {
            tokio::fs::create_dir_all(&dir_path).await.unwrap();
        }

        println!("Filename: {:?}", data.filename);
        println!("File hash: {:?}", data.hash_file);
        println!("File encrypted: {:?}", data.encrypted);
        println!("File compressed: {:?}", data.compressed);
        println!("File public: {:?}", data.public);

        let path = format!("{}/{}", dir_path, data.filename);
        let mut file = File::create(path).await.unwrap();

        let final_contents = if data.encrypted {
            let json_data: EncryptedData = serde_json::from_slice(&data.contents)
                .map_err(|e| format!("Ошибка десериализации зашифрованных данных: {}", e))?;

            let decrypted_contents = self
                .db
                .decrypt_data(&json_data.content, &json_data.nonce)
                .map_err(|e| format!("Ошибка расшифровки: {}", e))?;

            if data.compressed {
                self.db
                    .uncompress_data(&decrypted_contents)
                    .map_err(|e| format!("Ошибка распаковки: {}", e))?
            } else {
                decrypted_contents
            }
        } else {
            if data.compressed && data.auto_decompress {
                self.db
                    .uncompress_data(&data.contents)
                    .map_err(|e| format!("Ошибка распаковки: {}", e))?
            } else {
                data.contents
            }
        };

        file.write_all(&final_contents)
            .await
            .map_err(|e| format!("Ошибка записи файла: {}", e))?;

        println!(
            "{}",
            format!("[Peer] File saved: {}", data.filename).green()
        );
        Ok(())
    }

    pub async fn handle_file_access_change(
        &self,
        data: PeerFileAccessChange,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let fragments = self
            .db
            .search_fragment_in_virtual_storage(&data.file_hash, None)
            .map_err(|e| format!("Ошибка при поиске файла: {}", e))?;
        let fragment = fragments
            .first()
            .ok_or_else(|| "Файл не найден".to_string())?;

        if fragment.owner_key != from_uuid {
            return Err("У вас нет прав на изменение доступа к этому файлу".to_string());
        }

        let token_info = self
            .db
            .get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных".to_string())?;

        if token_info.token != data.token {
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        self.db
            .update_fragment_public_access(&data.file_hash, data.public)
            .map_err(|e| format!("Ошибка при обновлении доступа: {}", e))?;

        println!(
            "{}",
            format!(
                "[Peer] Доступ к файлу {} изменен на {}",
                data.file_hash,
                if data.public {
                    "публичный"
                } else {
                    "приватный"
                }
            )
            .green()
        );

        let packet_feedback = TransportPacket {
            act: "file_access_changed".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: format!(
                    "Доступ к файлу {} изменен на {}",
                    data.file_hash,
                    if data.public {
                        "публичный"
                    } else {
                        "приватный"
                    }
                ),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        connection.send_packet(packet_feedback).await
    }

    pub async fn handle_file_delete(
        &self,
        data: PeerFileDelete,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let fragments = self
            .db
            .search_fragment_in_virtual_storage(&data.file_hash, None)
            .map_err(|e| format!("Ошибка при поиске файла: {}", e))?;
        let fragment = fragments
            .first()
            .ok_or_else(|| "Файл не найден".to_string())?;

        if fragment.owner_key != from_uuid {
            return Err("У вас нет прав на удаление этого файла".to_string());
        }

        let token_info = self
            .db
            .get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных".to_string())?;

        if token_info.token != data.token {
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        // Удаляем физический файл
        let dir_path = format!("{}/blobs", self.db.path.as_str());
        let path = format!("{}/{}", dir_path, data.file_hash);
        if std::path::Path::new(&path).exists() {
            tokio::fs::remove_file(&path)
                .await
                .map_err(|e| format!("Ошибка при удалении файла: {}", e))?;
        }

        // Удаляем запись из базы данных
        self.db
            .remove_fragment(&data.file_hash)
            .map_err(|e| format!("Ошибка при удалении записи из базы данных: {}", e))?;

        println!(
            "{}",
            format!("[Peer] Файл {} успешно удален", data.file_hash).green()
        );

        let packet_feedback = TransportPacket {
            act: "file_deleted".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: format!("Файл {} успешно удален", data.file_hash),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        connection.send_packet(packet_feedback).await
    }

    pub async fn handle_file_move(
        &self,
        data: PeerFileMove,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let fragments = self
            .db
            .search_fragment_in_virtual_storage(&data.file_hash, None)
            .map_err(|e| format!("Ошибка при поиске файла: {}", e))?;
        let fragment = fragments
            .first()
            .ok_or_else(|| "Файл не найден".to_string())?;

        if fragment.owner_key != from_uuid {
            return Err("У вас нет прав на перемещение этого файла".to_string());
        }

        let token_info = self
            .db
            .get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных".to_string())?;

        if token_info.token != data.token {
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        // Обновляем путь к файлу
        self.db
            .update_fragment_path(&data.file_hash, &data.new_path)
            .map_err(|e| format!("Ошибка при обновлении пути: {}", e))?;

        println!(
            "{}",
            format!(
                "[Peer] Файл {} перемещен в {}",
                data.file_hash, data.new_path
            )
            .green()
        );

        let packet_feedback = TransportPacket {
            act: "file_moved".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: format!(
                    "Файл {} успешно перемещен в {}",
                    data.file_hash, data.new_path
                ),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        connection.send_packet(packet_feedback).await
    }

    pub async fn handle_file_update(
        &self,
        data: PeerFileUpdate,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let fragments = self
            .db
            .search_fragment_in_virtual_storage(&data.file_hash, None)
            .map_err(|e| format!("Ошибка при поиске файла: {}", e))?;
        let fragment = fragments
            .first()
            .ok_or_else(|| "Файл не найден".to_string())?;

        if fragment.owner_key != from_uuid {
            return Err("У вас нет прав на обновление этого файла".to_string());
        }

        let token_info = self
            .db
            .get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных".to_string())?;

        if token_info.token != data.token {
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        // Удаляем старый файл
        let dir_path = format!("{}/blobs", self.db.path.as_str());
        let old_path = format!("{}/{}", dir_path, data.file_hash);
        if std::path::Path::new(&old_path).exists() {
            tokio::fs::remove_file(&old_path)
                .await
                .map_err(|e| format!("Ошибка при удалении старого файла: {}", e))?;
        }

        // Создаем новый файл
        let contents = data.contents;

        let final_contents = if data.compressed && data.auto_decompress {
            println!("Распаковка сжатых данных...");
            self.db
                .uncompress_data(&contents)
                .map_err(|e| format!("Ошибка распаковки: {}", e))?
        } else {
            contents
        };

        let new_path = format!("{}/{}", dir_path, data.file_hash);
        let mut file = File::create(&new_path)
            .await
            .map_err(|e| format!("Ошибка при создании нового файла: {}", e))?;
        file.write_all(&final_contents)
            .await
            .map_err(|e| format!("Ошибка при записи нового файла: {}", e))?;

        // Обновляем информацию в базе данных
        self.db
            .update_fragment_metadata(
                &data.file_hash,
                data.filename.clone(),
                data.mime.clone(),
                data.encrypted,
                data.compressed,
                data.auto_decompress,
                data.public,
                final_contents.len() as u64,
            )
            .map_err(|e| format!("Ошибка при обновлении метаданных: {}", e))?;

        println!(
            "{}",
            format!("[Peer] Файл {} успешно обновлен", data.file_hash).green()
        );

        let packet_feedback = TransportPacket {
            act: "file_updated".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: format!("Файл {} успешно обновлен", data.file_hash),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        connection.send_packet(packet_feedback).await
    }
}


=== ../src\manager\ManagerPorts.rs ===
use super::ConnectionManager::ConnectionManager;

impl ConnectionManager {

    
}


=== ../src\manager\message_handler.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::{
    connection::Connection, crypto::crypto::generate_uuid, packets::{Message, Protocol, TransportData, TransportPacket}
};
use colored::*;

impl ConnectionManager {
    pub async fn handle_message(
        &self,
        data: Message,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        println!("{}", format!("[Peer] Message: {}", data.text).green());

        let response_packet = TransportPacket {
            act: "message_response".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: "Message received".to_string(),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        connection
            .send_packet(response_packet)
            .await
            .map_err(|e| e.to_string())
    }

    pub async fn handle_message_response(&self) -> Result<(), String> {
        println!("{}", "[Peer] Message sent successfully".green());
        Ok(())
    }
}


=== ../src\manager\mod.rs ===
pub mod ConnectionManager;
pub mod ProcessPackets;
pub mod StunManager;
pub mod types;
pub mod ManagerPorts;
pub mod storage_handler;
pub mod file_handler;
pub mod message_handler;

pub use types::ConnectionTurnStatus;

=== ../src\manager\ProcessPackets.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::crypto::crypto::generate_uuid;
use crate::http::proxy::handle_http_proxy_response;
use crate::logger::{debug, error, peer, storage, turn};
use crate::manager::types::{ConnectionTurnStatus, ConnectionType};
use crate::packets::{Message, Protocol, StorageToken, TransportData, TransportPacket};
use crate::peer::turn_tunnel;
use crate::connection::Connection;
use colored::Colorize;
use hex;
use serde_json;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Semaphore;
use futures::stream::{StreamExt, FuturesUnordered};

impl ConnectionManager {
    pub async fn handle_incoming_packets(&self) {
        let incoming_packet_rx = self.incoming_packet_rx.clone();
        let mut rx = incoming_packet_rx.lock().await;
        debug("Starting to handle incoming packets...");
        
        // Создаем семафор для ограничения количества одновременных задач
        let semaphore = Arc::new(Semaphore::new(32)); // Максимум 32 одновременных задачи
        let mut tasks = FuturesUnordered::new();

        loop {
            if let Some((connection_type, packet, connection)) = rx.recv().await {
                let semaphore = semaphore.clone();
                let self_clone = Arc::new(self.clone());
                
                // Создаем новую задачу для обработки пакета
                let task = tokio::spawn(async move {
                    let _permit = semaphore.acquire().await.unwrap();
                    self_clone.process_packet(connection_type, packet, connection).await;
                });
                
                tasks.push(task);
                
                // Очищаем завершенные задачи
                while let Some(result) = tasks.next().await {
                    if let Err(e) = result {
                        error(&format!("Task error: {}", e));
                    }
                }
            } else {
                debug("No messages received, sleeping...");
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            }
        }
    }

    async fn process_packet(&self, connection_type: ConnectionType, packet: TransportPacket, connection: Option<Arc<Connection>>) {
        match connection_type {
            ConnectionType::Signal(id) => {
                if let Some(connection) = connection {
                    debug(&format!("Received signal packet: {:?}", packet));
                    let from_peer_key = packet.peer_key.clone();
                    let packet_clone = packet.clone();
                    let protocol_connection = packet.protocol.clone();

                    if let Some(data) = &packet.data {
                        match data {
                            TransportData::PeerUploadFile(data) => {
                                if let Err(e) = self
                                    .handle_file_upload(
                                        &self.db,
                                        data.clone(),
                                        packet.uuid.clone(),
                                        &connection,
                                        from_peer_key.clone(),
                                    )
                                    .await
                                {
                                    let formatted_error =
                                        format!("Failed to handle file upload: {}", e);
                                    error(&formatted_error);

                                    let packet_error = TransportPacket {
                                        act: "message".to_string(),
                                        to: Some(from_peer_key.clone()),
                                        data: Some(TransportData::Message(Message {
                                            text: formatted_error,
                                            nonce: None,
                                        })),
                                        protocol: Protocol::TURN,
                                        peer_key: self.db.get_or_create_peer_id().unwrap(),
                                        uuid: generate_uuid(),
                                        nodes: vec![],
                                    };

                                    let _ = connection.send_packet(packet_error).await;
                                }
                            }
                            TransportData::PeerFileUpdate(data) => {
                                if let Err(e) = self
                                    .handle_file_update(
                                        data.clone(),
                                        &connection,
                                        from_peer_key.clone(),
                                    )
                                    .await
                                {
                                    error(&format!(
                                        "Failed to handle file update: {}",
                                        e
                                    ));
                                }
                            }
                            TransportData::ProxyMessage(data) => {
                                let _ = self
                                    .proxy_http_tx_reciever
                                    .lock()
                                    .await
                                    .send(packet.clone())
                                    .await;
                            }
                            TransportData::FragmentSearchResponse(response) => {
                                let _ = self
                                    .proxy_http_tx_reciever
                                    .lock()
                                    .await
                                    .send(packet.clone())
                                    .await;
                            }
                            TransportData::StorageReservationRequest(request) => {
                                if let Err(e) = self
                                    .handle_storage_reservation_request(
                                        request.clone(),
                                        &connection,
                                    )
                                    .await
                                {
                                    error(&format!(
                                        "Failed to handle storage reservation request: {}",
                                        e
                                    ));
                                }
                            }
                            TransportData::StorageValidTokenRequest(token) => {
                                if let Err(e) = self
                                    .handle_storage_valid_token_request(
                                        token.token.clone(),
                                        &connection,
                                        from_peer_key.clone(),
                                    )
                                    .await
                                {
                                    error(&format!(
                                        "Failed to handle storage valid token request: {}",
                                        e
                                    ));
                                }
                            }
                            TransportData::PeerFileGet(data) => {
                                if let Err(e) = self
                                    .handle_file_get(
                                        packet.uuid.clone(),
                                        data.clone(),
                                        &connection,
                                        from_peer_key.clone(),
                                    )
                                    .await
                                {
                                    error(&format!(
                                        "Failed to handle file get: {}",
                                        e
                                    ));
                                }
                            }
                            TransportData::FileData(data) => {
                                let peer_id = data.peer_id.clone();
                                if let Err(e) = self.handle_file_data(data.clone()).await {
                                    error(&format!(
                                        "Failed to handle file data: {}",
                                        e
                                    ));
                                } else {
                                    if let Ok(free_space) =
                                        self.db.get_storage_free_space().await
                                    {
                                        if let Err(e) = self
                                            .db
                                            .update_token_free_space(&peer_id, free_space)
                                        {
                                            error(&format!(
                                                "Failed to update token free space: {}",
                                                e
                                            ));
                                        }
                                    }
                                }
                            }
                            TransportData::PeerFileDelete(data) => {
                                if let Err(e) = self
                                    .handle_file_delete(
                                        data.clone(),
                                        &connection,
                                        from_peer_key.clone(),
                                    )
                                    .await
                                {
                                    error(&format!(
                                        "Failed to handle file delete: {}",
                                        e
                                    ));
                                }
                            }
                            TransportData::PeerFileMove(data) => {
                                if let Err(e) = self
                                    .handle_file_move(
                                        data.clone(),
                                        &connection,
                                        from_peer_key.clone(),
                                    )
                                    .await
                                {
                                    error(&format!(
                                        "Failed to handle file move: {}",
                                        e
                                    ));
                                }
                            }
                            TransportData::PeerFileAccessChange(data) => {
                                if let Err(e) = self
                                    .handle_file_access_change(
                                        data.clone(),
                                        &connection,
                                        from_peer_key.clone(),
                                    )
                                    .await
                                {
                                    error(&format!(
                                        "Failed to handle file access change: {}",
                                        e
                                    ));
                                }
                            }
                            TransportData::StorageValidTokenResponse(response) => {
                                storage("\n╔════════════════════════════════════════════════════════════╗");
                                storage("║                    ВАЛИДАЦИЯ ТОКЕНА ХРАНИЛИЩА                  ║");
                                storage("╠════════════════════════════════════════════════════════════╣");
                                storage(&format!(
                                    "║ Статус: {} ║",
                                    if response.status {
                                        "✅ ТОКЕН ВАЛИДЕН"
                                    } else {
                                        "❌ ТОКЕН НЕВАЛИДЕН"
                                    }
                                ));
                                storage("╚════════════════════════════════════════════════════════════╝\n");
                            }
                            TransportData::PeerSearchResponse(response) => {
                                peer("\n╔════════════════════════════════════════════════════════════╗");
                                peer("║                      РЕЗУЛЬТАТЫ ПОИСКА ПИРА                    ║");
                                peer("╠════════════════════════════════════════════════════════════╣");
                                peer(&format!(
                                    "║ {} ║",
                                    format!("Статус: {}", "✅ ПИР НАЙДЕН").yellow()
                                ));
                                peer(&format!(
                                    "║ {} ║",
                                    format!("UUID пира: {}", response.peer_id).cyan()
                                ));
                                peer(&format!(
                                    "║ {} ║",
                                    format!(
                                        "Адрес ноды: {}:{}",
                                        response.public_ip, response.public_port
                                    )
                                    .cyan()
                                ));
                                peer(&format!(
                                    "║ {} ║",
                                    format!("Прыжков: {}", response.hops).cyan()
                                ));
                                peer("╚════════════════════════════════════════════════════════════╝\n");
                            }
                            TransportData::StorageReservationResponse(response) => {
                                storage(&format!("\n{}", "=".repeat(80).yellow()));
                                storage(&format!("{}", "ВНИМАНИЕ! ВЫ ПОЛУЧИЛИ УНИКАЛЬНЫЙ ТОКЕН ДЛЯ ХРАНЕНИЯ И ПОЛУЧЕНИЯ ДАННЫХ С P2P ПИРА".red().bold()));
                                storage(&format!("{}", "ЕСЛИ ВЫ ПОТЕРЯЕТЕ КЛЮЧ ВЫ НЕ СМОЖЕТЕ ПОЛУЧИТЬ ДОСТУП К ДАННЫМ".red().bold()));
                                storage(&format!("{}", "=".repeat(80).yellow()));

                                if let Ok(token_bytes) = base64::decode(&response.token) {
                                    if let Ok(token_str) = String::from_utf8(token_bytes) {
                                        if let Ok(token) =
                                            serde_json::from_str::<StorageToken>(&token_str)
                                        {
                                            storage(&format!(
                                                "\n{}",
                                                "ДЕТАЛИ ТОКЕНА:".cyan().bold()
                                            ));
                                            storage(&format!(
                                                "{} {}",
                                                "Размер файла:".yellow(),
                                                format!("{} байт", token.file_size).white()
                                            ));
                                            storage(&format!(
                                                "{} {}",
                                                "Провайдер хранилища:".yellow(),
                                                token.storage_provider.white()
                                            ));
                                            storage(&format!(
                                                "{} {}",
                                                "Временная метка:".yellow(),
                                                format!("{}", token.timestamp).white()
                                            ));
                                            storage(&format!(
                                                "{} {}",
                                                "Подпись:".yellow(),
                                                hex::encode(&token.signature).white()
                                            ));

                                            if let Err(e) = self.db.add_token(
                                                &response.peer_id,
                                                &response.token,
                                                token.file_size,
                                            ) {
                                                error(&format!(
                                                    "Failed to save token to database: {}",
                                                    e
                                                ));
                                            }
                                        }
                                    }
                                }

                                storage(&format!("\n{}", "=".repeat(80).yellow()));
                                storage(&format!(
                                    "{}",
                                    "ТОКЕН В BASE64:".cyan().bold()
                                ));
                                storage(&format!("{}", response.token.white()));
                                storage(&format!("{}", "=".repeat(80).yellow()));
                            }
                            _ => {}
                        }
                    }

                    if packet.act == "http_proxy_request" {
                        debug("Received http proxy request");
                        let connection = connection.clone();
                        let manager = Arc::new(self.clone());
                        let packet_clone = packet.clone();
                        let path_blobs = self.path_blobs.clone().to_string();
                        tokio::spawn(async move {
                            let _ = handle_http_proxy_response(
                                packet_clone,
                                &connection,
                                manager,
                                path_blobs,
                            )
                            .await;
                        });
                    } else if packet.act == "request_fragments" {
                        let _ = self.handle_fragments_request(packet, &connection).await;
                    } else if packet.act == "peer_list" {
                        if let Some(TransportData::SyncPeerInfoData(peer_info_data)) =
                            packet.data
                        {
                            peer("Received peer list:");
                            for peer_info in peer_info_data.peers {
                                peer(&format!("Peer - KEY: {}", peer_info.uuid));
                            }
                        } else {
                            error("Peer list data is missing.");
                        }
                    } else if protocol_connection == Protocol::STUN {
                        debug("Processing STUN packet");
                        match packet.act.as_str() {
                            "wait_connection" => {
                                debug(&format!(
                                    "Received wait_connection from {}",
                                    from_peer_key
                                ));
                                let result = async {
                                    self.send_wait_connection(
                                        packet.peer_key.clone(),
                                        &connection,
                                        self.db.get_or_create_peer_id().unwrap(),
                                    )
                                    .await
                                }
                                .await;

                                if let Err(e) = result {
                                    error(&format!(
                                        "Failed to send wait_connection: {}",
                                        e
                                    ));
                                } else {
                                    debug("Successfully sent wait_connection");
                                }
                            }
                            "accept_connection" => {
                                debug(&format!(
                                    "Received accept_connection from {}",
                                    from_peer_key
                                ));
                                let result = self
                                    .receive_accept_connection(
                                        packet,
                                        self.db.get_or_create_peer_id().unwrap(),
                                    )
                                    .await;

                                match result {
                                    Ok(_) => {
                                        debug("Connection established successfully");
                                        self.connections_turn.insert(
                                            from_peer_key.clone(),
                                            ConnectionTurnStatus {
                                                connected: true,
                                                turn_connection: false,
                                            },
                                        );
                                    }
                                    Err(e) => {
                                        error(&format!(
                                            "Failed to establish connection: {}",
                                            e
                                        ));
                                        self.connections_turn.insert(
                                            from_peer_key.clone(),
                                            ConnectionTurnStatus {
                                                connected: false,
                                                turn_connection: true,
                                            },
                                        );
                                    }
                                }
                            }
                            _ => {
                                debug(&format!("Unknown STUN act: {}", packet.act));
                            }
                        }
                    } else if protocol_connection == Protocol::TURN
                        && packet.act == "wait_connection"
                    {
                        self.connections_turn.insert(
                            from_peer_key.clone(),
                            ConnectionTurnStatus {
                                connected: false,
                                turn_connection: true,
                            },
                        );
                    }

                    debug(&format!("From peer_key: {}", from_peer_key.clone()));
                    if let Some(mut status) = self.connections_turn.get_mut(&from_peer_key)
                    {
                        if status.turn_connection && !status.connected {
                            let result_turn_tunnel =
                                turn_tunnel(packet_clone, &connection, &self.db).await;
                            tokio::time::sleep(Duration::from_millis(100)).await;
                            debug(&format!(
                                "Result turn tunnel {:?}",
                                result_turn_tunnel
                            ));
                            match result_turn_tunnel {
                                Ok(r) => {
                                    if r == "successful_connection" {
                                        turn("Connection established!");
                                        status.connected = true;
                                        status.turn_connection = false;

                                        let packet_hello = TransportPacket {
                                            act: "test_turn".to_string(),
                                            to: Some(from_peer_key.clone()),
                                            data: None,
                                            protocol: Protocol::TURN,
                                            peer_key: self
                                                .db
                                                .get_or_create_peer_id()
                                                .unwrap(),
                                            uuid: generate_uuid(),
                                            nodes: vec![],
                                        };
                                        debug("Sending accept connection");
                                        let _ = connection.send_packet(packet_hello).await;
                                    } else if r == "send_wait_connection" {
                                        peer("Wait answer acceptation connection...");
                                    }
                                }
                                Err(e) => {
                                    status.connected = false;
                                    status.turn_connection = true;
                                    error(&format!("Fail: {}", e));
                                }
                            }
                            debug("Wait new packets...");
                        } else {
                            let packet_file_clone = packet_clone.clone();
                            match packet_clone.act.as_str() {
                                "file_saved" => {
                                    if let Some(TransportData::PeerFileSaved(data)) =
                                        packet_file_clone.data
                                    {
                                        if let Err(e) = self.handle_file_saved(data).await {
                                            println!(
                                                "[Peer] Failed to handle file saved: {}",
                                                e
                                            );
                                        }
                                    }
                                }
                                "message_response" => {
                                    if let Err(e) = self.handle_message_response().await {
                                        error(&format!(
                                            "Failed to handle message response: {}",
                                            e
                                        ));
                                    }
                                }
                                "message" => {
                                    if let Some(TransportData::Message(data)) =
                                        packet_file_clone.data
                                    {
                                        if let Err(e) = self
                                            .handle_message(
                                                data,
                                                &connection,
                                                from_peer_key.clone(),
                                            )
                                            .await
                                        {
                                            error(&format!(
                                                "Failed to handle message: {}",
                                                e
                                            ));
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    } else {
                        error("[Turn] Connection not found");
                    }
                }
            }
            ConnectionType::Stun => {
                debug(&format!("Received message from Tunnel: {:?}", packet));
            }
        }
    }
}


=== ../src\manager\storage_handler.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::connection::Connection;
use crate::crypto::crypto::generate_uuid;
use crate::packets::{
    FragmentMetadata, FragmentMetadataSync, Protocol, StorageReservationRequest, StorageReservationResponse, StorageToken, StorageValidTokenResponse, TransportData, TransportPacket
};
use base64;
use hex;
use k256;
use k256::ecdsa::signature::SignerMut;
use serde_json;

impl ConnectionManager {
    pub async fn handle_storage_reservation_request(
        &self,
        request: StorageReservationRequest,
        connection: &Connection,
    ) -> Result<(), String> {
        let free_space = self.db.get_storage_free_space().await.unwrap();
        println!("[Peer] Free space: {}", free_space);

        if free_space < request.size_in_bytes {
            println!("[Peer] Not enough storage space available");
            return Err("Not enough storage space".to_string());
        }

        let mut signing_key = self.db.get_private_signing_key().unwrap();
        let pub_key = signing_key.verifying_key().to_sec1_bytes();
        let pub_key_hex = hex::encode(pub_key);

        let storage_token = StorageToken {
            file_size: request.size_in_bytes as u64,
            storage_provider: pub_key_hex,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            signature: Vec::new(),
        };

        let mut token_bytes = serde_json::to_vec(&storage_token).unwrap();
        let signature: k256::ecdsa::Signature = signing_key.sign(&token_bytes);

        let mut final_token = storage_token;
        final_token.signature = signature.to_bytes().to_vec();

        let token_base64 = base64::encode(serde_json::to_vec(&final_token).unwrap());

        if let Err(e) = self.db.add_token(&request.peer_id, &token_base64, free_space) {
            println!("[Peer] Failed to save token to database: {}", e);
            return Err(format!("Failed to save token: {}", e));
        }

        let response = TransportPacket {
            act: "reserve_storage_response".to_string(),
            to: Some(request.peer_id.clone()),
            data: Some(TransportData::StorageReservationResponse(
                StorageReservationResponse {
                    peer_id: request.peer_id,
                    token: token_base64,
                    size_in_bytes: request.size_in_bytes,
                },
            )),
            protocol: Protocol::SIGNAL,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        connection.send_packet(response).await.map_err(|e| e.to_string())
    }

    pub async fn handle_storage_valid_token_request(
        &self,
        token: String,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let token_bytes = base64::decode(&token).unwrap();
        let token_str = String::from_utf8(token_bytes).unwrap();
        let token: StorageToken = serde_json::from_str(&token_str).unwrap();
        
        let mut signing_key = self.db.get_private_signing_key().unwrap();
        let pub_key = signing_key.verifying_key().to_sec1_bytes();
        let pub_key_hex = hex::encode(pub_key);

        let status = pub_key_hex == token.storage_provider;

        let response = TransportPacket {
            act: "storage_valid_token_response".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::StorageValidTokenResponse(
                StorageValidTokenResponse {
                    peer_id: self.db.get_or_create_peer_id().unwrap(),
                    status,
                },
            )),
            protocol: Protocol::SIGNAL,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        connection.send_packet(response).await.map_err(|e| e.to_string())
    }

    pub async fn handle_fragments_request(
        &self,
        packet_request: TransportPacket,
        connection: &Connection,
    ) -> Result<(), String> {
        let mut fragments = self.db.get_my_fragments()
            .map_err(|e| format!("Ошибка при получении фрагментов: {}", e))?;
        let storage_fragments = self.db.get_storage_fragments()
            .map_err(|e| format!("Ошибка при получении фрагментов: {}", e))?;
        
        fragments.extend(storage_fragments);

        let metadata_fragments: Vec<FragmentMetadata> = fragments
            .into_iter()
            .map(|f| FragmentMetadata {
                file_hash: f.file_hash,
                mime: f.mime,
                public: f.public,
                encrypted: f.encrypted,
                compressed: f.compressed,
                auto_decompress: f.auto_decompress,
                owner_key: f.owner_key,
                storage_peer_key: f.storage_peer_key,
                size: f.size,
            })
            .collect();

        let sync_data = FragmentMetadataSync {
            fragments: metadata_fragments,
            peer_id: self.db.get_or_create_peer_id().unwrap(),
        };

        let packet = TransportPacket {
            act: "sync_fragments".to_string(),
            to: Some(packet_request.peer_key.clone()),
            data: Some(TransportData::FragmentMetadataSync(sync_data)),
            protocol: Protocol::SIGNAL,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        let to_peer = packet.to.clone().unwrap();
        println!("[Peer] Send fragments to {}", to_peer);
        connection.send_packet(packet).await.map_err(|e| e.to_string())
    }
} 

=== ../src\manager\StunManager.rs ===
use crate::connection::Connection;
use crate::crypto::crypto::generate_uuid;
use crate::packets::{PeerWaitConnection, Protocol, TransportData, TransportPacket};
use crate::tunnel::Tunnel;
use anyhow::Result;

use super::types::PeerOpenNetInfo;
use super::ConnectionManager::ConnectionManager;

impl ConnectionManager {
    pub async fn send_wait_connection(
        &self,
        target_uuid: String,
        server_conn: &Connection,
        my_key: String,
    ) -> Result<(), String> {
        println!("[DEBUG] Starting send_wait_connection");
        println!("[DEBUG] Target UUID: {}", target_uuid);
        println!("[DEBUG] My Key: {}", my_key);

        let tunnel = Tunnel::new().await;
        println!("[DEBUG] Created new tunnel with IP: {} and Port: {}", tunnel.public_ip, tunnel.public_port);

        let net_info = PeerWaitConnection {
            connect_peer_id: target_uuid.clone(),
            public_ip: tunnel.public_ip.clone(),
            public_port: tunnel.public_port,
        };

        println!("[DEBUG] Created net_info: {:?}", net_info);

        self.connections_stun.insert(
            target_uuid.clone(),
            PeerOpenNetInfo {
                ip: net_info.public_ip.clone(),
                port: net_info.public_port,
            },
        );

        println!("[DEBUG] Added connection to STUN connections map");

        self.add_tunnel(target_uuid.clone(), tunnel).await;
        println!("[DEBUG] Added tunnel to tunnels map");

        let packet = TransportPacket {
            act: "accept_connection".to_string(),
            to: Some(target_uuid.clone()),
            data: Some(TransportData::PeerWaitConnection(net_info)),
            protocol: Protocol::STUN,
            peer_key: my_key.clone(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        println!("[DEBUG] Sending accept_connection packet: {:?}", packet);

        server_conn
            .send_packet(packet)
            .await
            .map_err(|e| e.to_string())
    }

    pub async fn receive_accept_connection(
        &self,
        packet: TransportPacket,
        my_key: String,
    ) -> Result<(), String> {
        println!("[DEBUG] Starting receive_accept_connection");
        println!("[DEBUG] Received packet: {:?}", packet);
        println!("[DEBUG] My Key: {}", my_key);

        if let Some(TransportData::PeerWaitConnection(data)) = packet.data {
            let ip = data.public_ip.clone();
            let port = data.public_port;
            println!("[DEBUG] Target IP: {}, Port: {}", ip, port);

            let tunnel_opt = self.get_tunnel(packet.peer_key.clone()).await;
            println!("[DEBUG] Got tunnel for peer_key {}: {:?}", packet.peer_key, tunnel_opt.is_some());

            if let Some(tunnel_arc) = tunnel_opt {
                println!("[DEBUG] Attempting connection to {}:{}", ip, port);
                
                let mut tunnel_guard = tunnel_arc.lock().await;
                
                match tunnel_guard.make_connection(&ip, port, 3).await {
                    Ok(()) => {
                        tunnel_guard.backlife_cycle(3);
                        drop(tunnel_guard);
                        println!("[DEBUG] Successfully established connection");
                        Ok(())
                    }
                    Err(e) => {
                        println!("[DEBUG] Connection failed: {}", e);
                        Err("[STUN] Fail connection".to_string())
                    }
                }
            } else {
                println!("[DEBUG] No tunnel found for peer_key: {}", packet.peer_key);
                Err("[STUN] error get tunnel".to_string())
            }
        } else {
            println!("[DEBUG] Invalid packet data format");
            Err("[STUN] Invalid accept_connection packet".to_string())
        }
    }
}


=== ../src\manager\types.rs ===
#[derive(Debug, Clone)]
pub struct ConnectionTurnStatus {
    pub connected: bool,
    pub turn_connection: bool,
}

pub enum ConnectionType {
    Signal(String),
    Stun,
}

#[derive(Debug, Clone)]
pub struct PeerOpenNetInfo {
    pub ip: String,
    pub port: u16,
}


=== ../src\packets\mod.rs ===
pub mod packets;
pub use packets::*;

=== ../src\packets\packets.rs ===
use crate::db::Storage;

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerInfo {
    pub is_signal_server: bool,
    pub total_space: u64,
    pub free_space: u64,
    pub stored_files: Vec<String>,
    pub public_key: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerWaitConnection {
    pub connect_peer_id: String,
    pub public_ip: String,
    pub public_port: u16
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileSaved {
    pub filename: String,
    pub token: String,
    pub token_hash: Option<String>,
    pub storage_peer_key: String,
    pub owner_key: String,
    pub hash_file: String,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
    pub public: bool,
    pub size: u64,
    pub mime: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileGet {
    pub peer_id: String,
    pub file_hash: String,
    pub token: Option<String>,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerUploadFile {
    pub peer_id: String,
    pub file_hash: String,
    pub filename: String,
    pub contents: Vec<u8>,
    pub token: String,
    pub mime: String,
    pub public: bool,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct SyncPeerInfo {
    pub uuid: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct SyncPeerInfoData {
    pub peers: Vec<SyncPeerInfo>,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone, PartialEq)]
pub enum Protocol {
    TURN,
    STUN,
    SIGNAL,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub enum Status {
    ERROR,
    SUCCESS,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct Message {
    pub text: String,
    pub nonce: Option<String>,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct ProxyMessage {
    pub text: Vec<u8>,
    pub nonce: [u8; 12],
    pub from_peer_id: String,
    pub end_peer_id: String,
    pub request_id: String,
    pub mime: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct FileData {
    pub filename: String,
    pub contents: Vec<u8>,
    pub peer_id: String,
    pub hash_file: String,
    pub encrypted: bool,
    pub mime: String,
    pub compressed: bool,
    pub public: bool,
    pub auto_decompress: bool,
}


#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StunSyncPubAddr {
    pub public_addr: String
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageValidTokenRequest {
    pub token: String,
    pub peer_id: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageValidTokenResponse {
    pub peer_id: String,
    pub status: bool,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageReservationRequest {
    pub peer_id: String,
    pub size_in_bytes: u64,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageToken {
    pub file_size: u64,                  // Размер файла
    pub storage_provider: String,      // Паблик-ключ (или крипто-адрес) хранителя
    pub timestamp: u64,                  // Unix-время создания токена
    pub signature: Vec<u8>,              // Подпись хранителя, подтверждающая согласие
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageReservationResponse {
    pub peer_id: String,
    pub token: String,  // base64 encoded StorageToken
    pub size_in_bytes: u64,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct PeerSearchRequest {
    pub search_id: String, // id поиска
    pub peer_id: String, // id пира инициатора поиска
    pub max_hops: u32, // максимальное количество прыжков
    pub path: Vec<SearchPathNode>, // путь поиска от инициатора до текущего узла
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct SearchPathNode {
    pub uuid: String,        // UUID узла
    pub public_ip: String, // Публичный адрес узла
    pub public_port: i64,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct PeerSearchResponse {
    pub search_id: String,     // id поиска
    pub peer_id: String,       // id пира инициатора поиска
    pub found_peer_id: String, // id пира найденного
    pub public_ip: String,   // публичный адрес ноды пира
    pub public_port: i64,
    pub hops: u32,            // количество прыжков
    pub path: Vec<SearchPathNode>, // путь поиска от инициатора до нашедшего пира
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct SignalServerInfo {
    pub public_key: String,
    pub public_ip: String,
    pub port: i64,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileMove {
    pub file_hash: String,
    pub peer_id: String,
    pub token: String,
    pub new_path: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct GetFragmentsMetadata {
    pub token_hash: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FragmentSearchRequest {
    pub query: String,
    pub request_id: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FragmentSearchResponse {
    pub fragments: Vec<Storage>,
    pub request_id: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileUpdate {
    pub peer_id: String,
    pub file_hash: String,
    pub filename: String,
    pub contents: Vec<u8>,
    pub token: String,
    pub mime: String,
    pub public: bool,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct FileRequest {
    pub file_hash: String,
    pub request_id: String,
    pub from_peer_id: String,
    pub end_peer_id: String,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub enum TransportData {
    Message(Message),
    ProxyMessage(ProxyMessage),
    FileRequest(FileRequest),
    PeerInfo(PeerInfo),
    PeerWaitConnection(PeerWaitConnection),
    PeerFileGet(PeerFileGet),
    PeerUploadFile(PeerUploadFile),
    SyncPeerInfoData(SyncPeerInfoData),
    StorageReservationRequest(StorageReservationRequest),
    StorageReservationResponse(StorageReservationResponse),
    StorageValidTokenRequest(StorageValidTokenRequest),
    StorageValidTokenResponse(StorageValidTokenResponse),
    PeerFileSaved(PeerFileSaved),
    StunSyncPubAddr(StunSyncPubAddr),
    FileData(FileData),
    PeerSearchRequest(PeerSearchRequest),
    PeerSearchResponse(PeerSearchResponse),
    SignalServerInfo(SignalServerInfo),
    PeerFileAccessChange(PeerFileAccessChange),
    PeerFileDelete(PeerFileDelete),
    PeerFileMove(PeerFileMove),
    FragmentMetadataSync(FragmentMetadataSync),
    GetFragmentsMetadata(GetFragmentsMetadata),
    FragmentSearchRequest(FragmentSearchRequest),
    FragmentSearchResponse(FragmentSearchResponse),
    PeerFileUpdate(PeerFileUpdate),
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct TransportPacket {
    pub act: String,         //info, answer, wait_connection,
    pub to: Option<String>,  //кому отправляем данный пакет
    pub data: Option<TransportData>,
    pub protocol: Protocol,     // TURN, STUN, SIGNAL
    pub peer_key: String,
    pub uuid: String,
    pub nodes: Vec<SearchPathNode>, // ноды через которых прошел пакет
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct EncryptedData {
    pub content: Vec<u8>,
    pub nonce: [u8; 12],
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileAccessChange {
    pub file_hash: String,
    pub public: bool,
    pub peer_id: String,
    pub token: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileDelete {
    pub file_hash: String,
    pub peer_id: String,
    pub token: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct FragmentMetadata {
    pub file_hash: String,
    pub mime: String,
    pub public: bool,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
    pub owner_key: String,
    pub storage_peer_key: String,
    pub size: u64,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct FragmentMetadataSync {
    pub fragments: Vec<FragmentMetadata>,
    pub peer_id: String,
}

impl std::fmt::Display for TransportPacket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TransportPacket {{ act: {}, to: {:?}, protocol: {:?}, uuid: {} }}",
            self.act, self.to, self.protocol, format!("{:?}...{:?}", &self.uuid[0..5], &self.uuid[30..])
        )
    }
}

=== ../src\peer\mod.rs ===
mod turn;
pub mod peer;
pub mod peer_api;
mod types;
mod virtual_storage;

pub use turn::turn_tunnel;
pub use peer::Peer;
pub use types::ConnectionTurnStatus;
pub use peer_api::PeerAPI;
pub use virtual_storage::FileGroup;

=== ../src\peer\peer.rs ===
use std::sync::Arc;
use crate::logger;

use crate::config::Config;
use crate::connection::Connection;
use crate::manager::ConnectionManager::ConnectionManager;
use crate::db::P2PDatabase;

pub struct Peer {
    connection_manager: Arc<ConnectionManager>,
    connection: Arc<Connection>,
    db: Arc<P2PDatabase>,
}

impl Peer {
    pub async fn new(config: &Config, db: &P2PDatabase) -> Self {
        let connection_manager = Arc::new(ConnectionManager::new(db).await);

        let connection = Arc::new(
            Connection::new(
                config.signal_server_ip.clone(),
                config.signal_server_port,
                db,
            )
            .await,
        );

        connection_manager
            .add_connection(
                format!("{}:{}", config.signal_server_ip, config.signal_server_port),
                connection.clone(),
            )
            .await;

        Peer {
            connection_manager,
            connection,
            db: Arc::new(db.clone()),
        }
    }

    pub async fn run(&self) {
        let peer_id = self.db.get_or_create_peer_id().unwrap();
        logger::info(&format!("[Peer] Your UUID: {}", peer_id));

        logger::info("[Peer] Starting peer...");

        self.connection_manager.handle_incoming_packets().await;
    }
}


=== ../src\peer\peer_api.rs ===
use crate::connection::Connection;
use crate::crypto::crypto::generate_uuid;
use crate::crypto::token::get_metadata_from_token;
use crate::db::P2PDatabase;
use crate::manager::ConnectionManager::ConnectionManager;
use crate::packets::{
    EncryptedData, FragmentMetadata, FragmentMetadataSync, GetFragmentsMetadata, Message, PeerFileAccessChange, PeerFileDelete, PeerFileGet, PeerFileMove, PeerSearchRequest, PeerUploadFile, PeerWaitConnection, Protocol, SearchPathNode, StorageReservationRequest, StorageValidTokenRequest, TransportData, TransportPacket, PeerFileUpdate
};
use crate::tunnel::Tunnel;
use colored::Colorize;
use hex;
use mime_guess;
use sha2::{Digest, Sha256};
use std::sync::Arc;
use tokio::io::AsyncReadExt;

use flate2::write::GzEncoder;
use flate2::Compression;
use std::io::Write;
use std::path::Path;

#[derive(Debug)]
pub enum UploadError {
    FileNotFound(String),
    NoTokensAvailable,
    InsufficientSpace { required: u64, available: u64 },
    DatabaseError(String),
    IoError(String),
}

impl std::fmt::Display for UploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UploadError::FileNotFound(path) => write!(f, "Файл не найден: {}", path),
            UploadError::NoTokensAvailable => write!(f, "Нет доступных токенов для загрузки. Используйте команду reserve для получения нового токена."),
            UploadError::InsufficientSpace { required, available } => write!(
                f,
                "Недостаточно места для загрузки файла. Требуется: {} байт, Доступно: {} байт. Используйте команду reserve для получения дополнительного места.",
                required, available
            ),
            UploadError::DatabaseError(e) => write!(f, "Ошибка базы данных: {}", e),
            UploadError::IoError(e) => write!(f, "Ошибка ввода/вывода: {}", e),
        }
    }
}

impl std::error::Error for UploadError {}

#[derive(Clone)]
pub struct PeerAPI {
    connection: Arc<Connection>,
    pub db: Arc<P2PDatabase>,
    manager: Arc<ConnectionManager>,
}

impl PeerAPI {
    pub fn new(connection: Arc<Connection>, db: &P2PDatabase, manager: &ConnectionManager) -> Self {
        PeerAPI {
            connection,
            db: Arc::new(db.clone()),
            manager: Arc::new(manager.clone()),
        }
    }

    pub async fn get_file(&self, identifier: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files
            .iter()
            .find(|f| f.filename == identifier || f.file_hash == identifier);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", identifier));
        }
        let file = file.unwrap();
        let token = file.token.clone();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "get_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileGet(PeerFileGet {
                token: Some(token),
                peer_id: my_peer_id.clone(),
                file_hash: file.file_hash.clone(),
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    fn clean_file_path(path: &str, root_dir: &str) -> String {
        let path = Path::new(path);
        let root = Path::new(root_dir);

        if let Ok(relative) = path.strip_prefix(root) {
            relative.to_string_lossy().replace('\\', "/")
        } else {
            path.file_name()
                .unwrap_or_else(|| path.as_os_str())
                .to_string_lossy()
                .to_string()
        }
    }

    pub async fn upload_file(
        &self,
        file_path: String,
        encrypt: bool,
        public: bool,
        auto_decompress: bool,
        root_dir: &str,
    ) -> Result<(), UploadError> {
        println!("Uploading file: {}", file_path);
        let file_size = tokio::fs::metadata(&file_path)
            .await
            .map_err(|e| UploadError::FileNotFound(e.to_string()))?
            .len();

        println!("File size: {}", file_size);

        let (owner_peer_id, token_info) = self
            .db
            .get_best_token(file_size)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?
            .ok_or(UploadError::NoTokensAvailable)?;

        let used_space = self
            .db
            .get_token_used_space(&owner_peer_id)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        if used_space + file_size > token_info.free_space && !public {
            return Err(UploadError::InsufficientSpace {
                required: file_size,
                available: token_info.free_space - used_space,
            });
        }

        println!("Owner peer id: {}", owner_peer_id);
        println!("Token info: {}", token_info.token);
        println!("Used space: {} / {}", used_space, token_info.free_space);

        let metadata = get_metadata_from_token(token_info.token.clone()).await;

        let token_provider = metadata.unwrap().storage_provider;

        if !self
            .manager
            .have_connection_with_peer(token_provider.clone())
            .await
        {
            self.connect_to_peer(token_provider.clone())
                .await
                .map_err(|e| UploadError::IoError(format!("Failed to connect to peer: {}", e)))?;

            let mut attempts = 0;
            let max_attempts = 30;

            while attempts < max_attempts {
                if self
                    .manager
                    .have_connection_with_peer(token_provider.clone())
                    .await
                {
                    break;
                }
                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                attempts += 1;
            }

            if attempts >= max_attempts {
                return Err(UploadError::IoError(
                    "Failed to establish connection with peer".to_string(),
                ));
            }
        }

        // ⏬ Сжатие файла
        let contents = tokio::fs::read(&file_path)
            .await
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder
            .write_all(&contents)
            .map_err(|e| UploadError::IoError(e.to_string()))?;
        let compressed_contents = encoder
            .finish()
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        println!("Compressed size: {}", compressed_contents.len());

        let (final_content, encrypted) = if encrypt {
            // ⏬ Шифрование файла
            let encrypted_contents = self
                .db
                .encrypt_data(&compressed_contents)
                .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

            let content = serde_json::to_string(&EncryptedData {
                nonce: encrypted_contents.1,
                content: encrypted_contents.0,
            })
            .unwrap();
            (content.into_bytes(), true)
        } else {
            (compressed_contents, false)
        };

        let my_peer_id = self
            .db
            .get_or_create_peer_id()
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        let file_hash = hex::encode(Sha256::digest(&final_content));
        let mime = mime_guess::from_path(file_path.clone()).first_or_text_plain();

        let packet = TransportPacket {
            act: "save_file".to_string(),
            to: Some(token_provider),
            data: Some(TransportData::PeerUploadFile(PeerUploadFile {
                filename: Self::clean_file_path(&file_path, root_dir),
                contents: final_content,
                peer_id: my_peer_id.clone(),
                token: token_info.token,
                file_hash: file_hash,
                mime: mime.to_string(),
                public,
                encrypted,
                compressed: true,
                auto_decompress,
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection
            .send_packet(packet)
            .await
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        self.db
            .update_token_used_space(&owner_peer_id, used_space + file_size)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        Ok(())
    }

    pub async fn upload_file_default(&self, file_path: String) -> Result<(), UploadError> {
        self.upload_file(file_path, true, false, false, "").await
    }

    pub async fn send_message(&self, peer_id: String, message: String) -> Result<(), String> {
        let packet = TransportPacket {
            act: "message".to_string(),
            to: Some(peer_id),
            data: Some(TransportData::Message(Message {
                text: message,
                nonce: None,
            })),
            protocol: Protocol::TURN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn connect_to_peer(&self, peer_id: String) -> Result<(), String> {
        let tunnel = Tunnel::new().await;
        let tunnel_ip = tunnel.public_ip.clone();
        let tunnel_port = tunnel.public_port.clone();
        self.manager.add_tunnel(peer_id.to_string(), tunnel).await;
        let packet = TransportPacket {
            act: "wait_connection".to_string(),
            to: None,
            data: Some(TransportData::PeerWaitConnection(PeerWaitConnection {
                connect_peer_id: peer_id,
                public_port: tunnel_port,
                public_ip: tunnel_ip,
            })),
            protocol: Protocol::STUN,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn request_peer_list(&self) -> Result<(), String> {
        let packet = TransportPacket {
            act: "peer_list".to_string(),
            to: None,
            data: None,
            protocol: Protocol::SIGNAL,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };
        println!("{}", format!("[Peer] Sending peer list to signal server"));
        self.connection.send_packet(packet).await
    }

    pub async fn reserve_storage(&self, size_in_bytes: u64) -> Result<(), String> {
        let packet = TransportPacket {
            act: "reserve_storage".to_string(),
            to: None,
            data: Some(TransportData::StorageReservationRequest(
                StorageReservationRequest {
                    peer_id: self.db.get_or_create_peer_id().unwrap(),
                    size_in_bytes,
                },
            )),
            protocol: Protocol::SIGNAL,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn valid_token(&self, token: String) -> Result<(), String> {
        let metadata = get_metadata_from_token(token.clone().to_string()).await;

        if let Ok(metadata) = metadata {
            let packet = TransportPacket {
                act: "valid_token".to_string(),
                to: Some(metadata.storage_provider),
                data: Some(TransportData::StorageValidTokenRequest(
                    StorageValidTokenRequest {
                        token: token.clone(),
                        peer_id: self.db.get_or_create_peer_id().unwrap(),
                    },
                )),
                protocol: Protocol::SIGNAL,
                peer_key: self.db.get_or_create_peer_id().unwrap(),
                uuid: generate_uuid(),
                nodes: vec![],
            };

            self.connection.send_packet(packet).await
        } else {
            Err("Invalid token".to_string())
        }
    }

    pub async fn search_peer(&self, peer_id: String) -> Result<(), String> {
        let packet = TransportPacket {
            act: "search_peer".to_string(),
            to: None,
            data: Some(TransportData::PeerSearchRequest(PeerSearchRequest {
                peer_id: self.db.get_or_create_peer_id().unwrap(),
                search_id: peer_id,
                max_hops: 3,
                path: vec![SearchPathNode {
                    uuid: self.db.get_or_create_peer_id().unwrap(),
                    public_ip: self.connection.ip.clone(),
                    public_port: self.connection.port.clone(),
                }],
            })),
            protocol: Protocol::SIGNAL,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn change_file_public_access(
        &self,
        file_hash: String,
        public: bool,
    ) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "change_file_access".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileAccessChange(PeerFileAccessChange {
                file_hash,
                public,
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn delete_file(&self, file_hash: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "delete_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileDelete(PeerFileDelete {
                file_hash,
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn move_file(&self, file_hash: String, new_path: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        // Получаем имя файла из текущего пути
        let current_filename = std::path::Path::new(&file.filename)
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or(&file.filename);

        // Формируем новый путь с сохранением имени файла
        let new_path = if new_path.ends_with('/') || new_path.ends_with('\\') {
            format!("{}{}", new_path, current_filename)
        } else {
            format!("{}/{}", new_path, current_filename)
        };

        let packet = TransportPacket {
            act: "move_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileMove(PeerFileMove {
                file_hash: file_hash.clone(),
                new_path: new_path.clone(),
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await?;

        self.db
            .update_fragment_path(&file_hash, &new_path)
            .map_err(|e| format!("Ошибка при обновлении метаданных: {}", e))?;

        Ok(())
    }

    fn collect_files_recursively(
        &self,
        dir_path: &std::path::Path,
        files: &mut Vec<String>,
    ) -> Result<(), UploadError> {
        for entry in std::fs::read_dir(dir_path).map_err(|e| UploadError::IoError(e.to_string()))? {
            let entry = entry.map_err(|e| UploadError::IoError(e.to_string()))?;
            let path = entry.path();

            if path.is_file() {
                files.push(path.to_string_lossy().to_string());
            } else if path.is_dir() {
                self.collect_files_recursively(&path, files)?;
            }
        }
        Ok(())
    }

    pub async fn upload_directory(
        &self,
        dir_path: String,
        encrypt: bool,
        public: bool,
        auto_decompress: bool,
    ) -> Result<(), UploadError> {
        let path = std::path::Path::new(&dir_path);
        if !path.is_dir() {
            return Err(UploadError::FileNotFound(
                "Указанный путь не является директорией".to_string(),
            ));
        }

        let mut files = Vec::new();
        self.collect_files_recursively(path, &mut files)?;

        if files.is_empty() {
            return Err(UploadError::FileNotFound("Директория пуста".to_string()));
        }

        println!(
            "{}",
            format!("Найдено файлов для загрузки: {}", files.len()).cyan()
        );

        for (i, file) in files.iter().enumerate() {
            println!(
                "{}",
                format!("Загрузка файла {}/{}: {}", i + 1, files.len(), file).yellow()
            );
            if let Err(e) = self
                .upload_file(file.clone(), encrypt, public, auto_decompress, &dir_path)
                .await
            {
                println!(
                    "{}",
                    format!("Ошибка при загрузке файла {}: {}", file, e).red()
                );
            } else {
                println!("{}", format!("Файл {} успешно загружен", file).green());
            }
        }

        Ok(())
    }

    pub async fn get_fragments_metadata(&self, token_hash: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let packet = TransportPacket {
            act: "get_fragments_metadata".to_string(),
            to: None,
            data: Some(TransportData::GetFragmentsMetadata(GetFragmentsMetadata {
                token_hash,
            })),
            protocol: Protocol::SIGNAL,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn sync_fragment_metadata(&self) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let fragments = self
            .db
            .get_my_fragments()
            .map_err(|e| format!("Ошибка при получении фрагментов: {}", e))?;

        let metadata_fragments: Vec<FragmentMetadata> = fragments
            .into_iter()
            .map(|f| FragmentMetadata {
                file_hash: f.file_hash,
                mime: f.mime,
                public: f.public,
                encrypted: f.encrypted,
                compressed: f.compressed,
                auto_decompress: f.auto_decompress,
                owner_key: f.owner_key,
                storage_peer_key: f.storage_peer_key,
                size: f.size,
            })
            .collect();

        let sync_data = FragmentMetadataSync {
            fragments: metadata_fragments,
            peer_id: my_peer_id.clone(),
        };

        let packet = TransportPacket {
            act: "sync_fragments".to_string(),
            to: None,
            data: Some(TransportData::FragmentMetadataSync(sync_data)),
            protocol: Protocol::SIGNAL,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        println!(
            "{}",
            "[Peer] Отправка метаданных фрагментов на сигнальную ноду".cyan()
        );
        self.connection.send_packet(packet).await
    }

    pub async fn update_file(
        &self,
        file_hash: String,
        new_file_path: String,
        encrypt: bool,
        public: bool,
        auto_decompress: bool,
    ) -> Result<(), String> {
        println!("Обновление файла: {}", new_file_path);
        let file_size = tokio::fs::metadata(&new_file_path)
            .await
            .map_err(|e| format!("Ошибка при получении метаданных файла: {}", e))?
            .len();

        println!("Размер файла: {}", file_size);

        // Получаем информацию о текущем файле
        let fragments = self.db.get_my_fragments()
            .map_err(|e| format!("Ошибка при получении фрагментов: {}", e))?;
        
        let fragment = fragments.iter()
            .find(|f| f.file_hash == file_hash)
            .ok_or_else(|| format!("Файл с хешем {} не найден", file_hash))?;

        let token_info = self.db.get_token(&fragment.storage_peer_key)
            .map_err(|e| format!("Ошибка при получении токена: {}", e))?
            .ok_or_else(|| "Токен не найден".to_string())?;

        let used_space = self.db.get_token_used_space(&fragment.storage_peer_key)
            .map_err(|e| format!("Ошибка при получении использованного места: {}", e))?;

        if used_space + file_size > token_info.free_space && !public {
            return Err(format!(
                "Недостаточно места. Требуется: {}, Доступно: {}",
                file_size,
                token_info.free_space - used_space
            ));
        }

        // Читаем содержимое нового файла
        let mut file = tokio::fs::File::open(&new_file_path)
            .await
            .map_err(|e| format!("Ошибка при открытии файла: {}", e))?;
        let mut contents = Vec::new();
        file.read_to_end(&mut contents)
            .await
            .map_err(|e| format!("Ошибка при чтении файла: {}", e))?;

        // Сжимаем содержимое
        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder.write_all(&contents)
            .map_err(|e| format!("Ошибка при сжатии файла: {}", e))?;
        let compressed_contents = encoder.finish()
            .map_err(|e| format!("Ошибка при завершении сжатия: {}", e))?;

        // Шифруем содержимое если нужно
        let (final_content, encrypted) = if encrypt {
            let encrypted_contents = self.db.encrypt_data(&compressed_contents)
                .map_err(|e| format!("Ошибка при шифровании: {}", e))?;

            let content = serde_json::to_string(&EncryptedData {
                nonce: encrypted_contents.1,
                content: encrypted_contents.0,
            })
            .map_err(|e| format!("Ошибка при сериализации: {}", e))?;
            (content.into_bytes(), true)
        } else {
            (compressed_contents, false)
        };

        let my_peer_id = self.db.get_or_create_peer_id()
            .map_err(|e| format!("Ошибка при получении peer_id: {}", e))?;

        let mime = mime_guess::from_path(new_file_path.clone()).first_or_text_plain();

        let packet = TransportPacket {
            act: "update_file".to_string(),
            to: Some(fragment.storage_peer_key.clone()),
            data: Some(TransportData::PeerFileUpdate(PeerFileUpdate {
                peer_id: my_peer_id.clone(),
                file_hash: file_hash.clone(),
                filename: fragment.filename.clone(),
                contents: final_content,
                token: token_info.token,
                mime: mime.to_string(),
                public,
                encrypted,
                compressed: true,
                auto_decompress,
            })),
            protocol: Protocol::TURN,
            peer_key: my_peer_id,
            uuid: generate_uuid(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await?;

        // Обновляем информацию об использованном месте
        self.db.update_token_used_space(&fragment.storage_peer_key, used_space + file_size)
            .map_err(|e| format!("Ошибка при обновлении использованного места: {}", e))?;

        Ok(())
    }
}


=== ../src\peer\turn.rs ===
use anyhow::Result;
use colored::*;

use crate::connection::Connection;
use crate::crypto::crypto::generate_uuid;
use crate::packets::{Protocol, TransportPacket};
use crate::db::P2PDatabase;

pub async fn turn_tunnel(
    packet: TransportPacket,
    signal: &Connection,
    db: &P2PDatabase,
) -> Result<String, String> {

    println!(
        "{}",
        format!("[TURN] Turn tunnel creating, sending packets.. {}", packet.act).yellow()
    );
    if packet.act == "wait_connection" {
        let packet_hello = TransportPacket {
            act: "try_turn_connection".to_string(),
            to: Some(packet.peer_key.clone().to_string()),
            data: None,
            protocol: Protocol::TURN,
            peer_key: db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };
        let result = signal.send_packet(packet_hello).await;
        println!(
            "{}",
            format!("[TURN] [try_turn_connection] Result sending socket {:?}", result).yellow()
        );
        match result {
            Ok(_) => {
                return Ok("send_wait_connection".to_string());
            }
            Err(e) => {
                return Err(e);
            }
        }
    } else if packet.act == "accept_connection" || packet.act == "try_turn_connection" {
        let packet_hello = TransportPacket {
            act: "accept_connection".to_string(),
            to: Some(packet.peer_key.to_string()),
            data: None,
            protocol: Protocol::TURN,
            peer_key: db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };
        println!("{}", "[TURN] [accept_connection] Sending accept connection".yellow());
        let result = signal.send_packet(packet_hello).await;
        match result {
            Ok(_) => {
                return Ok("successful_connection".to_string());
            }
            Err(e) => {
                return Err(e);
            }
        }
    }
    return Err("[TURN] Peer didn't give the connection agreement".to_string());
}


=== ../src\peer\types.rs ===
#[derive(Debug, Clone)]
pub struct ConnectionTurnStatus {
    pub connected: bool,
    pub turn_connection: bool,
} 

=== ../src\peer\virtual_storage.rs ===
use super::peer_api::PeerAPI;
use std::collections::HashMap;
use colored::Colorize;

#[derive(Debug, Clone)]
pub struct FileGroup {
    pub name: String,
    pub files: Vec<String>,
    pub tags: Vec<String>,
}

impl PeerAPI {
    fn display_storage(&self) -> Result<(), String> {
        let files = self.db.get_my_fragments().map_err(|e| e.to_string())?;
        let groups = self.db.get_all_groups().map_err(|e| e.to_string())?;

        let mut file_tree: HashMap<String, Vec<(String, String)>> = HashMap::new();
        let mut group_tree: HashMap<String, Vec<(String, String)>> = HashMap::new();

        for file in files {
            let path = std::path::Path::new(&file.filename);
            let parent = path.parent().and_then(|p| p.to_str()).unwrap_or("/");

            file_tree
                .entry(parent.to_string())
                .or_insert_with(Vec::new)
                .push((
                    path.file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or(&file.filename)
                        .to_string(),
                    file.file_hash,
                ));
        }

        for group_name in groups {
            let group_files = self.db.get_files_by_group(&group_name).map_err(|e| e.to_string())?;
            group_tree
                .entry(group_name)
                .or_insert_with(Vec::new)
                .extend(group_files.iter().map(|file| {
                    (file.filename.clone(), file.file_hash.clone())
                }));
        }

        println!(
            "\n{}",
            "╔════════════════════════════════════════════════════════════╗".cyan()
        );
        println!(
            "{}",
            "║                    ВИРТУАЛЬНОЕ ХРАНИЛИЩЕ                   ║".cyan()
        );
        println!(
            "{}",
            "╠════════════════════════════════════════════════════════════╣".cyan()
        );

        println!("{}", "║ 📁 ФАЙЛЫ ПО ПАПКАМ:".cyan());
        for (path, files) in file_tree.iter() {
            println!("{}", format!("║ 📁 {}", path).cyan());
            for (filename, hash) in files {
                println!("{}", format!("║   └─ {} ({})", filename, hash).white());
            }
        }

        if !group_tree.is_empty() {
            println!("{}", "║ 📁 ГРУППЫ ФАЙЛОВ:".cyan());
            for (group_name, files) in group_tree.iter() {
                println!("{}", format!("║ 📁 Группа: {}", group_name).cyan());
                for (filename, hash) in files {
                    println!("{}", format!("║   └─ {} ({})", filename, hash).white());
                }
            }
        }

        println!(
            "{}",
            "╚════════════════════════════════════════════════════════════╝".cyan()
        );
        println!("\n{}", "Доступные команды:".yellow());
        println!("{}", "  • move <hash> <new_path> - переместить файл".white());
        println!("{}", "  • delete <hash> - удалить файл".white());
        println!("{}", "  • public <hash> - сделать файл публичным".white());
        println!("{}", "  • private <hash> - сделать файл приватным".white());
        println!("{}", "  • group add <group_name> <hash> [tags...] - добавить файл в группу".white());
        println!("{}", "  • group remove <group_name> <hash> - удалить файл из группы".white());
        println!("{}", "  • group list - показать все группы".white());
        println!("{}", "  • exit - выйти из виртуального хранилища".white());

        Ok(())
    }

    fn add_to_group(&self, group_name: &str, file_hash: &str, tags: Vec<String>) -> Result<(), String> {
        let files = self.db.get_my_fragments().map_err(|e| e.to_string())?;
        
        if !files.iter().any(|f| f.file_hash == file_hash) {
            return Err(format!("Файл с хешем {} не найден", file_hash));
        }

        self.db.add_file_to_group(group_name, file_hash, tags).map_err(|e| e.to_string())?;
        
        Ok(())
    }

    fn remove_from_group(&self, group_name: &str, file_hash: &str) -> Result<(), String> {
        self.db.remove_file_from_group(group_name, file_hash).map_err(|e| e.to_string())?;
        Ok(())
    }

    fn list_groups(&self) -> Result<(), String> {
        let groups = self.db.get_all_groups().map_err(|e| e.to_string())?;
        
        if groups.is_empty() {
            println!("{}", "Нет созданных групп".yellow());
            return Ok(());
        }

        println!("\n{}", "Список групп:".cyan());
        for group_name in groups {
            let files = self.db.get_files_by_group(&group_name).map_err(|e| e.to_string())?;
            println!("{}", format!("📁 Группа: {}", group_name).cyan());
            println!("{}", format!("   Количество файлов: {}", files.len()).white());
        }

        Ok(())
    }

    fn get_group_files(&self, group_name: &str) -> Result<Vec<String>, String> {
        let files = self.db.get_files_by_group(group_name).map_err(|e| e.to_string())?;
        Ok(files.into_iter().map(|f| f.file_hash).collect())
    }
    
    pub async fn virtual_storage_interactive(&self) -> Result<(), String> {
        use std::io::{self, Write};

        loop {
            self.display_storage();

            print!("\n{}", "virtual_storage> ".green());
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut input = String::new();
            io::stdin()
                .read_line(&mut input)
                .map_err(|e| e.to_string())?;
            let input = input.trim();

            if input == "exit" {
                break;
            }

            let parts: Vec<&str> = input.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }

            match parts[0] {
                "move" => {
                    if parts.len() != 3 {
                        println!("{}", "Использование: move <hash> <new_path>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .move_file(parts[1].to_string(), parts[2].to_string())
                        .await
                    {
                        println!("{}", format!("Ошибка при перемещении файла: {}", e).red());
                    } else {
                        println!("{}", "Файл успешно перемещен".green());
                    }
                }
                "delete" => {
                    if parts.len() != 2 {
                        println!("{}", "Использование: delete <hash>".red());
                        continue;
                    }
                    if let Err(e) = self.delete_file(parts[1].to_string()).await {
                        println!("{}", format!("Ошибка при удалении файла: {}", e).red());
                    } else {
                        println!("{}", "Файл успешно удален".green());
                    }
                }
                "public" => {
                    if parts.len() != 2 {
                        println!("{}", "Использование: public <hash>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .change_file_public_access(parts[1].to_string(), true)
                        .await
                    {
                        println!("{}", format!("Ошибка при изменении доступа: {}", e).red());
                    } else {
                        println!("{}", "Файл сделан публичным".green());
                    }
                }
                "private" => {
                    if parts.len() != 2 {
                        println!("{}", "Использование: private <hash>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .change_file_public_access(parts[1].to_string(), false)
                        .await
                    {
                        println!("{}", format!("Ошибка при изменении доступа: {}", e).red());
                    } else {
                        println!("{}", "Файл сделан приватным".green());
                    }
                }
                "group" => {
                    if parts.len() < 2 {
                        println!("{}", "Использование: group <add|remove|list> [параметры...]".red());
                        continue;
                    }
                    match parts[1] {
                        "add" => {
                            if parts.len() < 4 {
                                println!("{}", "Использование: group add <group_name> <hash> [tags...]".red());
                                continue;
                            }
                            let group_name = parts[2];
                            let file_hash = parts[3];
                            let tags: Vec<String> = parts[4..].iter().map(|&s| s.to_string()).collect();
                            
                            if let Err(e) = self.add_to_group(group_name, file_hash, tags) {
                                println!("{}", format!("Ошибка при добавлении в группу: {}", e).red());
                            } else {
                                println!("{}", "Файл успешно добавлен в группу".green());
                            }
                        }
                        "remove" => {
                            if parts.len() != 4 {
                                println!("{}", "Использование: group remove <group_name> <hash>".red());
                                continue;
                            }
                            if let Err(e) = self.remove_from_group(parts[2], parts[3]) {
                                println!("{}", format!("Ошибка при удалении из группы: {}", e).red());
                            } else {
                                println!("{}", "Файл успешно удален из группы".green());
                            }
                        }
                        "list" => {
                            if let Err(e) = self.list_groups() {
                                println!("{}", format!("Ошибка при получении списка групп: {}", e).red());
                            }
                        }
                        _ => {
                            println!("{}", "Неизвестная команда группы. Используйте: add, remove или list".red());
                        }
                    }
                }
                _ => {
                    println!(
                        "{}",
                        "Неизвестная команда. Используйте help для списка команд.".red()
                    );
                }
            }
        }

        Ok(())
    }
} 

=== ../src\signal\client.rs ===
use crate::config::Config;
use crate::crypto::crypto::generate_uuid;
use crate::db::P2PDatabase;
use crate::packets::{PeerInfo, Protocol, TransportData, TransportPacket};
use anyhow::Result;
use std::sync::Arc;
use tokio::io::{split, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::{mpsc, RwLock};

#[derive(Debug)]
struct Peer {
    socket: Arc<RwLock<TcpStream>>,
    info: String,
}

type PeersSender = mpsc::Sender<Peer>;
type PeersReceiver = mpsc::Receiver<Peer>;

#[derive(Debug)]
pub struct SignalClient {
    writer: Option<Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>>,
    reader: Option<Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>>,
    db: Arc<P2PDatabase>,
    message_tx: mpsc::Sender<TransportPacket>,
    message_rx: Option<mpsc::Receiver<TransportPacket>>,
    pub signal_server_ip: String,
    pub signal_server_port: u16,
    pub public_key: String,
}

impl SignalClient {
    pub fn new(db: &P2PDatabase) -> Self {
        let (message_tx, message_rx) = mpsc::channel(1024);
        SignalClient {
            writer: None,
            reader: None,
            db: Arc::new(db.clone()),
            message_tx,
            message_rx: Some(message_rx),
            signal_server_ip: "".to_string(),
            signal_server_port: 0,
            public_key: "".to_string(),
        }
    }

    pub fn get_message_receiver(&mut self) -> Option<mpsc::Receiver<TransportPacket>> {
        self.message_rx.take()
    }

    pub async fn connect(
        &mut self,
        signal_server_ip: &str,
        signal_server_port: i64,
        public_ip: &str,
        public_port: u16,
        public_key: &str,
    ) -> Result<(), String> {
        println!(
            "[SignalClient] Connecting to signal server {}:{}",
            signal_server_ip, signal_server_port
        );

        self.signal_server_ip = signal_server_ip.to_string();
        self.signal_server_port = signal_server_port as u16;
        self.public_key = public_key.to_string();
        match TcpStream::connect(format!("{}:{}", signal_server_ip, signal_server_port)).await {
            Ok(socket) => {
                let (reader, writer) = split(socket);
                self.writer = Some(Arc::new(RwLock::new(writer)));
                self.reader = Some(Arc::new(RwLock::new(reader)));

                // Запускаем обработчик входящих сообщений
                let reader = self.reader.as_ref().unwrap().clone();
                let db = self.db.clone();
                let message_tx = self.message_tx.clone();
                tokio::spawn(async move {
                    let mut buffer = [0; 1024];
                    loop {
                        let mut reader_guard = reader.write().await;
                        
                        // Читаем длину сообщения (4 байта)
                        let mut len_bytes = [0u8; 4];
                        match reader_guard.read_exact(&mut len_bytes).await {
                            Ok(_) => {
                                let message_len = u32::from_be_bytes(len_bytes) as usize;
                                
                                // Читаем само сообщение
                                let mut message_bytes = vec![0u8; message_len];
                                match reader_guard.read_exact(&mut message_bytes).await {
                                    Ok(_) => {
                                        let message = String::from_utf8_lossy(&message_bytes);
                                        println!("[SignalClient] Received message: {}", message);
                                        if let Ok(packet) = serde_json::from_str::<TransportPacket>(&message) {
                                            println!("[SignalClient] Parsed packet: {:?}", packet);
                                            
                                            // Отправляем пакет в канал для обработки
                                            if let Err(e) = message_tx.send(packet).await {
                                                println!("[SignalClient] Failed to send packet to handler: {}", e);
                                                break;
                                            }
                                        } else {
                                            println!("[SignalClient] Failed to parse packet: {}", message);
                                        }
                                    }
                                    Err(e) => {
                                        println!("[SignalClient] Error reading message: {}", e);
                                        break;
                                    }
                                }
                            }
                            Err(e) => {
                                if e.kind() == std::io::ErrorKind::ConnectionReset {
                                    println!("[SignalClient] Connection closed by server");
                                    break;
                                }
                                println!("[SignalClient] Error reading message length: {}", e);
                                break;
                            }
                        }
                    }
                });

                let fragments = self.db.get_storage_fragments().unwrap();
                let mut stored_files = Vec::new();
                for fragment in fragments {
                    stored_files.push(fragment.file_hash.clone());
                }

                let connect_packet = TransportPacket {
                    act: "info".to_string(),
                    to: None,
                    data: Some(TransportData::PeerInfo(PeerInfo {
                        public_key: self.db.get_or_create_peer_id().unwrap(),
                        total_space: self.db.get_total_space().unwrap_or(0),
                        free_space: self.db.get_storage_free_space().await.unwrap_or(0),
                        stored_files: stored_files,
                        is_signal_server: true,
                    })),
                    protocol: Protocol::SIGNAL,
                    peer_key: self.db.get_or_create_peer_id().unwrap(),
                    uuid: generate_uuid(),
                    nodes: vec![],
                };

                self.send_packet(connect_packet).await?;

                Ok(())
            }
            Err(e) => {
                println!("[SignalClient] Failed to connect to signal server: {}", e);
                Err(e.to_string())
            }
        }
    }

    pub async fn send_packet(&self, packet: TransportPacket) -> Result<(), String> {
        let string_packet = serde_json::to_string(&packet).unwrap();
        let message_len = string_packet.len() as u32;
        let len_bytes = message_len.to_be_bytes();

        if let Some(writer) = &self.writer {
            // println!(
            //     "[SignalClient] Sending packet to signal server: {}",
            //     string_packet
            // );

            let mut writer_guard = writer.write().await;
            
            // Отправляем длину сообщения
            match writer_guard.write_all(&len_bytes).await {
                Ok(_) => {
                    // Отправляем само сообщение
                    match writer_guard.write_all(string_packet.as_bytes()).await {
                        Ok(_) => {
                            println!("[SignalClient] Successfully sent packet");
                            Ok(())
                        }
                        Err(e) => {
                            println!("[SignalClient] Failed to send packet: {}", e);
                            Err(e.to_string())
                        }
                    }
                }
                Err(e) => {
                    println!("[SignalClient] Failed to send packet length: {}", e);
                    Err(e.to_string())
                }
            }
        } else {
            println!("[SignalClient] Writer is not connected");
            Err("[SignalClient] Writer is not connected".to_string())
        }
    }
}


=== ../src\signal\mod.rs ===
pub mod server;
mod peer;
pub mod peer_search;
mod signal_servers;
pub mod client;

pub use self::server::SignalServer;
pub use self::peer::Peer;

=== ../src\signal\peer.rs ===
use dashmap::DashMap;
use std::sync::Arc;
use tokio::io::{split, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::{mpsc, RwLock};
use crate::logger;

#[derive(Clone, Debug)]
pub struct InfoPeer {
    pub wait_connection: Arc<RwLock<bool>>,
    pub public_addr: Arc<RwLock<String>>,
    pub local_addr: String,
    pub is_signal_server: Arc<RwLock<bool>>,
    pub peer_key: Arc<RwLock<Option<String>>>,
}

#[derive(Debug, Clone)]
pub struct PeerOpenNetInfo {
    pub ip: String,
    pub port: u16,
}

#[derive(Debug, Clone)]
pub struct Peer {
    reader: Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>, // Добавляем reader
    writer: Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>, // Добавляем writer
    pub info: InfoPeer,                                  // Peer information (ip:port)
    tx: mpsc::Sender<String>,                            // Добавляем Sender для отправки сообщений

    open_tunnels: Arc<DashMap<String, PeerOpenNetInfo>>,
}

impl Peer {
    pub fn new(socket: TcpStream, info: Option<InfoPeer>) -> Arc<Self> {
        let mut info = info;

        if info.is_none() {
            info = Some(InfoPeer {
                wait_connection: Arc::new(RwLock::new(false)),
                public_addr: Arc::new(RwLock::new("".to_string())),
                local_addr: socket.peer_addr().unwrap().to_string(),
                peer_key: Arc::new(RwLock::new(None)),
                is_signal_server: Arc::new(RwLock::new(false)),
            });
        }

        let open_tunnels = Arc::new(DashMap::new());

        let (reader, writer) = split(socket);
        let reader = Arc::new(RwLock::new(reader));
        let writer = Arc::new(RwLock::new(writer));
        let (tx, _) = mpsc::channel(1024);

        Arc::new(Self {
            reader,
            writer,
            info: info.unwrap(),
            tx,
            open_tunnels,
        })
    }

    pub async fn send_data(&self, message: &str) {
        let message_len = message.len() as u32;
        let len_bytes = message_len.to_be_bytes();

        let mut writer = self.writer.write().await;

        // Отправляем длину сообщения (4 байта)
        if let Err(e) = writer.write_all(&len_bytes).await {
            logger::debug(&format!(
                "Failed to send message length to peer {}: {}",
                self.info.local_addr, e
            ));
            return;
        }

        // Отправляем само сообщение
        if let Err(e) = writer.write_all(message.as_bytes()).await {
            logger::debug(&format!(
                "Failed to send message to peer {}: {}",
                self.info.local_addr, e
            ));
        } else {
            logger::debug(&format!(
                "[SendData] Message sent to peer {}: {}",
                self.info.local_addr, message
            ));
        }
    }

    pub async fn receive_message(&self) -> Result<String, String> {
        let mut reader = self.reader.write().await;

        // Читаем длину сообщения (4 байта)
        let mut len_bytes = [0u8; 4];
        match reader.read_exact(&mut len_bytes).await {
            Ok(_) => {}
            Err(e) => {
                if e.kind() == std::io::ErrorKind::ConnectionReset {
                    logger::debug(&format!("Peer {} disconnected", self.info.local_addr));
                    return Err("Peer disconnected".to_string());
                }
                logger::debug(&format!(
                    "Error reading message length from peer {}: {}",
                    self.info.local_addr, e
                ));
                return Err(e.to_string());
            }
        }

        let message_len = u32::from_be_bytes(len_bytes) as usize;

        // Читаем само сообщение
        let mut message_bytes = vec![0u8; message_len];
        match reader.read_exact(&mut message_bytes).await {
            Ok(_) => {}
            Err(e) => {
                logger::debug(&format!(
                    "Error reading message from peer {}: {}",
                    self.info.local_addr, e
                ));
                return Err(e.to_string());
            }
        }

        match String::from_utf8(message_bytes) {
            Ok(message) => Ok(message),
            Err(e) => {
                logger::debug(&format!(
                    "Error converting message to string from peer {}: {}",
                    self.info.local_addr, e
                ));
                Err(e.to_string())
            }
        }
    }

    pub async fn is_signal_server(&self) -> bool {
        self.info.is_signal_server.read().await.clone()
    }

    pub async fn set_is_signal_server(&self, is_signal_server: bool) {
        let mut guard = self.info.is_signal_server.write().await;
        *guard = is_signal_server;
    }

    pub async fn add_open_tunnel(&self, peer_id: &str, ip: String, port: u16) {
        self.open_tunnels.insert(peer_id.to_string(), PeerOpenNetInfo { ip, port });
    }

    pub async fn get_open_tunnel(&self, peer_id: &str) -> Option<PeerOpenNetInfo> {
        self.open_tunnels.get(peer_id).map(|v| v.clone())
    }

    pub async fn get_key(&self) -> Option<String> {
        return self.info.peer_key.read().await.clone();
    }

    pub async fn set_wait_connection(&self, wait_connection_new: bool) {
        let mut wait_connection = self.info.wait_connection.write().await;
        *wait_connection = wait_connection_new;
    }

    pub async fn set_public_addr(&self, public_addr: String) {
        let mut public_addr_now = self.info.public_addr.write().await;
        *public_addr_now = public_addr;
    }

    pub async fn set_peer_key(&self, peer_key: String) {
        let mut current_peer_key = self.info.peer_key.write().await;
        *current_peer_key = Some(peer_key);
    }

    pub async fn send(&self, packet: String) -> Result<(), String> {
        self.send_data(&packet).await;
        Ok(())
    }

    pub async fn receive(&self) -> Result<String, String> {
        self.receive_message().await
    }
}


=== ../src\signal\peer_search.rs ===
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{mpsc, RwLock};
use uuid::Uuid;

use crate::crypto::crypto::generate_uuid;
use crate::packets::{
    PeerInfo, PeerSearchRequest, PeerSearchResponse, Protocol, SearchPathNode, TransportData, TransportPacket,
};
use crate::signal::client::SignalClient;

use super::{peer, Peer};

#[derive(Debug)]
struct SearchCache {
    found_peer_id: String,
    public_ip: String,
    public_port: i64,
    expires_at: Instant,
}

#[derive(Debug)]
pub struct PeerSearchManager {
    peers: Arc<RwLock<Vec<Arc<Peer>>>>,
    public_key: String,
    public_ip: String,
    public_port: i64,
    connected_servers: Arc<RwLock<Vec<Arc<SignalClient>>>>,
    active_searches: Arc<RwLock<HashMap<String, mpsc::Sender<PeerSearchResponse>>>>,
    search_cache: Arc<RwLock<HashMap<String, SearchCache>>>,
}

impl PeerSearchManager {
    pub fn new(
        public_key: String,
        public_ip: String,
        public_port: i64,
        peers: Arc<RwLock<Vec<Arc<Peer>>>>,
        connected_servers: Arc<RwLock<Vec<Arc<SignalClient>>>>,
    ) -> Arc<Self> {
        Arc::new(Self {
            peers,
            public_key,
            public_ip,
            public_port,
            connected_servers,
            active_searches: Arc::new(RwLock::new(HashMap::new())),
            search_cache: Arc::new(RwLock::new(HashMap::new())),
        })
    }

    pub async fn handle_search_request(&self, request: PeerSearchRequest) -> Result<(), String> {
        let peer_id = request.peer_id.clone(); // id пира инициатора поиска
        let search_id = request.search_id.clone(); // id поиска

        println!(
            "[PeerSearch] Starting search for peer {} (request from {})",
            search_id, peer_id
        );

        // Проверяем кэш
        if let Some(cache) = self.search_cache.read().await.get(&search_id) {
            if cache.expires_at > Instant::now() {
                println!("[PeerSearch] Found peer {} in cache", search_id);
                let mut path = request.path.clone();
                path.push(SearchPathNode {
                    uuid: self.public_key.clone(),
                    public_ip: self.public_ip.clone(),
                    public_port: self.public_port,
                });
                let path_clone = path.clone();
                
                let response = PeerSearchResponse {
                    search_id: search_id.clone(),               // id поиска
                    peer_id: peer_id.clone(),                   // id пира инициатора поиска
                    found_peer_id: cache.found_peer_id.clone(), // id пира найденного
                    public_ip: self.public_ip.clone(),   // публичный адрес ноды пира
                    public_port: self.public_port.clone(),
                    hops: 0,                                    // количество прыжков
                    path,                                       // путь поиска
                };

                // Сначала проверяем локальных пиров
                let peers = self.peers.read().await;
                for peer in peers.iter() {
                    let peer_uuid = peer.info.peer_key.read().await;
                    if peer_uuid.as_ref() == Some(&peer_id) {
                        println!("[PeerSearch] Found initiator peer {} locally, sending response directly", peer_id);
                        let packet = TransportPacket {
                            act: "search_response".to_string(),
                            to: Some(peer_id.clone()),
                            data: Some(TransportData::PeerSearchResponse(response)),
                            protocol: Protocol::SIGNAL,
                            peer_key: self.public_key.clone(),
                            uuid: generate_uuid(),
                            nodes: path_clone.clone(),
                        };
                        peer.send_data(&serde_json::to_string(&packet).unwrap())
                            .await;
                        println!("[PeerSearch] Sent search response to peer");
                        return Ok(());
                    }
                }
                println!(
                    "[PeerSearch] Initiator peer {} not found locally, forwarding response",
                    peer_id
                );
            }
        }

        let peers = self.peers.read().await;
        println!("[PeerSearch] Checking {} local peers", peers.len());
        for peer in peers.iter() {
            let peer_uuid = peer.info.peer_key.read().await;
            if peer_uuid.as_ref() == Some(&search_id) {
                println!("[PeerSearch] Found peer {} locally", search_id);
                let mut path = request.path.clone();
                path.push(SearchPathNode {
                    uuid: self.public_key.clone(),
                    public_ip: self.public_ip.clone(),
                    public_port: self.public_port.clone(),
                });
                let path_clone = path.clone();
                
                let response = PeerSearchResponse {
                    search_id: search_id.clone(),             // id поиска
                    peer_id: peer_id.clone(),                 // id пира инициатора поиска
                    found_peer_id: search_id.clone(),         // id пира найденного
                    public_ip: self.public_ip.clone(), // публичный адрес ноды пира
                    public_port: self.public_port.clone(),
                    hops: 0,                                  // количество прыжков
                    path,                                     // путь поиска
                };

                // Кэшируем результат
                let search_id_clone = search_id.clone();
                let found_peer_id = search_id_clone.clone();
                self.search_cache.write().await.insert(
                    search_id_clone.clone(),
                    SearchCache {
                        found_peer_id,
                        public_ip: self.public_ip.clone(),
                        public_port: self.public_port.clone(),
                        expires_at: Instant::now() + Duration::from_secs(300), // 5 минут
                    },
                );

                // Сначала проверяем локальных пиров
                for initiator_peer in peers.iter() {
                    let initiator_uuid = initiator_peer.info.peer_key.read().await;
                    if initiator_uuid.as_ref() == Some(&peer_id) {
                        println!("[PeerSearch] Found initiator peer {} locally, sending response directly", peer_id);
                        let packet = TransportPacket {
                            act: "search_response".to_string(),
                            to: Some(peer_id.clone()),
                            data: Some(TransportData::PeerSearchResponse(response)),
                            protocol: Protocol::SIGNAL,
                            peer_key: self.public_key.clone(),
                            uuid: generate_uuid(),
                            nodes: path_clone,
                        };
                        initiator_peer.send_data(&serde_json::to_string(&packet).unwrap())
                            .await;
                        println!("[PeerSearch] Sent search response to peer");
                        return Ok(());
                    }
                }
                println!(
                    "[PeerSearch] Initiator peer {} not found locally, forwarding response",
                    peer_id
                );
            }
        }

        // Если не нашли локально и есть еще ходы
        if request.max_hops > 0 {
            println!(
                "[PeerSearch] Peer not found locally, forwarding search request (hops left: {})",
                request.max_hops - 1
            );
            
            // Добавляем себя в путь поиска
            let mut path = request.path.clone();
            path.push(SearchPathNode {
                uuid: self.public_key.clone(),
                public_ip: self.public_ip.clone(),
                public_port: self.public_port.clone(),
            });
            let path_clone = path.clone();
            
            let new_request = PeerSearchRequest {
                search_id: search_id.clone(),
                peer_id: request.peer_id,
                max_hops: request.max_hops - 1,
                path, // Передаем обновленный путь
            };

            let packet = TransportPacket {
                act: "search_peer".to_string(),
                to: None,
                data: Some(TransportData::PeerSearchRequest(new_request)),
                protocol: Protocol::SIGNAL,
                peer_key: peer_id,
                uuid: generate_uuid(),
                nodes: path_clone,
            };

            let servers = self.connected_servers.read().await;
            for server in servers.iter() {
                if let Err(e) = server.send_packet(packet.clone()).await {
                    println!(
                        "[PeerSearch] Failed to forward search request to server: {}",
                        e
                    );
                } else {
                    println!("[PeerSearch] Successfully forwarded search request to server");
                }
            }
        } else {
            println!("[PeerSearch] Search failed - max hops reached");
        }

        Ok(())
    }

    pub async fn handle_search_response(&self, response: PeerSearchResponse) -> Result<(), String> {
        println!(
            "[PeerSearch] Received search response for peer {} (from {})",
            response.search_id, response.peer_id
        );

        // Находим свой индекс в пути поиска
        let my_index = response.path.iter().position(|node| node.uuid == self.public_key);
        
        if let Some(index) = my_index {
            // Если мы последний узел в пути, значит мы инициатор поиска
            if index == response.path.len() - 1 {
                println!("[PeerSearch] We are the initiator, processing response");
                // Сначала проверяем локальных пиров
                let peers = self.peers.read().await;
                for peer in peers.iter() {
                    if let Some(peer_key) = peer.info.peer_key.read().await.clone() {
                        if peer_key == response.peer_id {
                            println!("[PeerSearch] Found initiator peer {} locally, sending response directly", response.peer_id);
                            let path_clone = response.path.clone();
                            let packet = TransportPacket {
                                act: "search_response".to_string(),
                                to: Some(response.peer_id.clone()),
                                data: Some(TransportData::PeerSearchResponse(response.clone())),
                                protocol: Protocol::SIGNAL,
                                peer_key: self.public_key.clone(),
                                uuid: generate_uuid(),
                                nodes: path_clone,
                            };
                            peer.send_data(&serde_json::to_string(&packet).unwrap())
                                .await;
                            println!("[PeerSearch] Sent search response to initiator peer");
                            return Ok(());
                        }
                    }
                }
                println!("[PeerSearch] Initiator peer {} not found locally", response.peer_id);
            } else {
                // Мы промежуточный узел, сначала проверяем локальных пиров
                let my_index = response.path.iter().position(|node| node.uuid == self.public_key).unwrap();
                let next_node = &response.path[my_index - 1];
                println!("[PeerSearch] Looking for next node {} in path", next_node.uuid);
                
                // Проверяем локальных пиров
                let peers = self.peers.read().await;
                for peer in peers.iter() {
                    if let Some(peer_key) = peer.info.peer_key.read().await.clone() {
                        if peer_key == next_node.uuid {
                            println!("[PeerSearch] Found next node {} locally, sending response directly", next_node.uuid);
                            let path_clone = response.path.clone();
                            let packet = TransportPacket {
                                act: "search_response".to_string(),
                                to: Some(next_node.uuid.clone()),
                                data: Some(TransportData::PeerSearchResponse(response.clone())),
                                protocol: Protocol::SIGNAL,
                                peer_key: self.public_key.clone(),
                                uuid: generate_uuid(),
                                nodes: path_clone,
                            };
                            peer.send_data(&serde_json::to_string(&packet).unwrap())
                                .await;
                            println!("[PeerSearch] Sent search response to next node");
                            return Ok(());
                        }
                    }
                }
                
                // Если не нашли локально, отправляем через сигнальный сервер
                println!("[PeerSearch] Next node {} not found locally, forwarding through signal server", next_node.uuid);
                let path_clone = response.path.clone();
                let packet = TransportPacket {
                    act: "search_response".to_string(),
                    to: Some(next_node.uuid.clone()),
                    data: Some(TransportData::PeerSearchResponse(response.clone())),
                    protocol: Protocol::SIGNAL,
                    peer_key: self.public_key.clone(),
                    uuid: generate_uuid(),
                    nodes: path_clone,
                };

                let servers = self.connected_servers.read().await;
                let mut forwarded = false;
                for server in servers.iter() {
                    if let Err(e) = server.send_packet(packet.clone()).await {
                        println!("[PeerSearch] Failed to forward response to server: {}", e);
                    } else {
                        forwarded = true;
                        println!("[PeerSearch] Successfully forwarded response to server");
                        break;
                    }
                }

                if !forwarded {
                    println!("[PeerSearch] Failed to forward response to any server");
                }
            }
        } else {
            println!("[PeerSearch] We are not in the search path, ignoring response");
        }

        Ok(())
    }
}




=== ../src\signal\server.rs ===
use async_std::sync::Mutex;
use dashmap::DashMap;
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpListener;
use tokio::sync::broadcast;
use tokio::sync::oneshot;
use tokio::sync::{mpsc, RwLock};

use super::peer_search::PeerSearchManager;
use super::Peer;
use crate::commands::create_base_commands;
use crate::commands::get_path_blobs;
use crate::config::Config;
use crate::crypto::crypto::generate_uuid;
use crate::db::{P2PDatabase, Storage};
use crate::http::http_api::HttpApi;
use crate::http::http_proxy::HttpProxy;
use crate::packets::{
    FragmentSearchResponse, PeerWaitConnection, Protocol, SearchPathNode, SyncPeerInfo,
    SyncPeerInfoData, TransportData, TransportPacket,
};
use crate::signal::client::SignalClient;
use crate::signal::signal_servers::{
    SignalServerInfo as StoredSignalServerInfo, SignalServersList,
};
use crate::tunnel::Tunnel;

const SHOW_LOGS: bool = true;

fn log(message: &str) {
    if SHOW_LOGS {
        println!("{}", message);
    }
}

#[derive(Debug)]
pub struct SignalServer {
    pub peers: Arc<RwLock<Vec<Arc<Peer>>>>,
    pub connected_servers: Arc<RwLock<Vec<Arc<SignalClient>>>>,
    peer_search_manager: Arc<PeerSearchManager>,
    port: i64,
    ip: String,
    message_tx: mpsc::Sender<(Arc<Peer>, String)>,
    pub response_tx: mpsc::Sender<TransportPacket>,
    pub proxy_http_tx: mpsc::Sender<TransportPacket>,
    pub api_http_tx: mpsc::Sender<TransportPacket>,
    my_public_addr: Arc<String>,
    my_public_key: Arc<String>,
    pub db: Arc<P2PDatabase>,
    pub http_proxy: Arc<HttpProxy>,
    pub http_api: Arc<HttpApi>,
    pending_responses: Arc<DashMap<String, oneshot::Sender<TransportPacket>>>,
}

impl SignalServer {
    pub async fn new(config: &Config, db: &P2PDatabase) -> Arc<Self> {
        let (message_tx, mut message_rx) = mpsc::channel(4096);
        let (response_tx, mut response_rx) = mpsc::channel(4096);
        let (proxy_http_tx, mut proxy_http_rx) = mpsc::channel(4096);
        let (api_http_tx, mut api_http_rx) = mpsc::channel(4096);

        let tunnel = Tunnel::new().await;
        let public_ip = tunnel.get_public_ip();
        let my_public_addr = Arc::new(format!("{}:{}", public_ip, config.signal_server_port));
        let my_public_key = db.get_or_create_peer_id().unwrap();

        let commands = create_base_commands();
        let path_blobs = get_path_blobs(&commands.get_matches());

        let peers = Arc::new(RwLock::new(Vec::new()));
        let connected_servers = Arc::new(RwLock::new(Vec::new()));
        let peer_search_manager = PeerSearchManager::new(
            db.get_or_create_peer_id().unwrap(),
            public_ip.to_string().clone(),
            config.signal_server_port.clone(),
            peers.clone(),
            connected_servers.clone(),
        );

        let proxy_http_tx_clone = proxy_http_tx.clone();
        let api_http_tx_clone = api_http_tx.clone();
        let proxy = Arc::new(HttpProxy::new(
            Arc::new(db.clone()),
            proxy_http_tx_clone,
            path_blobs.clone(),
        ));
        let proxy_clone = Arc::clone(&proxy);
        let proxy_http_clone = Arc::clone(&proxy);

        let pending_responses = Arc::new(DashMap::new());

        let http_api = Arc::new(
            HttpApi::new(
                Arc::new(db.clone()),
                public_ip.clone(),
                api_http_tx_clone,
                path_blobs.clone(),
            )
            .await,
        );
        let http_api_clone = Arc::clone(&http_api);
        let http_api_clone2 = Arc::clone(&http_api);

        let server = SignalServer {
            peers,
            connected_servers,
            peer_search_manager,
            port: config.signal_server_port,
            message_tx,
            response_tx,
            proxy_http_tx,
            api_http_tx,
            ip: public_ip,
            my_public_addr,
            my_public_key: Arc::new(my_public_key),
            db: Arc::new(db.clone()),
            http_proxy: proxy,
            http_api,
            pending_responses,
        };

        tokio::spawn(async move {
            proxy_clone.start().await;
        });

        tokio::spawn(async move {
            http_api_clone.start().await;
        });

        let server_arc = Arc::new(server);

        let server_clone = Arc::clone(&server_arc);
        tokio::spawn(async move {
            loop {
                server_clone.sync_fragments_with_peers().await;
                tokio::time::sleep(tokio::time::Duration::from_secs(300)).await;
            }
        });

        if let Ok(mut servers_list) = SignalServersList::load_or_create() {
            log(&format!("Servers list: {:?}", servers_list));
            for server_info in servers_list.servers.iter() {
                log(&format!("Server info: {:?}", server_info));
                if ((server_info.public_ip == "127.0.0.1"
                    && server_info.port != config.signal_server_port)
                    || server_info.public_ip != "127.0.0.1")
                    && server_info.public_ip != tunnel.get_public_ip()
                {
                    let server_addr = format!("{}:{}", server_info.public_ip, server_info.port);
                    let server_clone = Arc::clone(&server_arc);
                    let public_key = server_info.public_key.clone();
                    tokio::spawn(async move {
                        if let Err(e) = server_clone
                            .connect_to_signal_server(&server_addr, &public_key)
                            .await
                        {
                            log(&format!(
                                "[SignalServer] Failed to connect to signal server {}: {}",
                                server_addr, e
                            ));
                        }
                    });
                }
            }
        }

        let server_clone = Arc::clone(&server_arc);
        let server_clone_for_proxy = Arc::clone(&server_arc);
        let server_clone_for_proxy_http = Arc::clone(&server_arc);

        tokio::spawn(async move {
            while let Some((peer, message)) = message_rx.recv().await {
                let server_clone = server_clone.clone();
                let peer_clone = peer.clone();
                tokio::spawn(async move {
                    server_clone
                        .handle_message(&server_clone, peer_clone, message)
                        .await;
                });
            }
        });

        tokio::spawn(async move {
            while let Some(packet) = proxy_http_rx.recv().await {
                let server_clone = server_clone_for_proxy.clone();
                tokio::spawn(async move {
                    server_clone.auto_send_packet(packet).await;
                });
            }
        });

        tokio::spawn(async move {
            while let Some(packet) = api_http_rx.recv().await {
                let server_clone = server_clone_for_proxy_http.clone();
                tokio::spawn(async move {
                    if packet.to.is_some() {
                        server_clone.auto_send_packet(packet).await;
                    } else {
                        let target_peer = server_clone.db.get_peer_with_most_space();
                        let mut packet_clone = packet.clone();
                        packet_clone.to = target_peer;
                        server_clone.auto_send_packet(packet_clone).await;
                    }
                });
            }
        });

        let proxy_clone_rx = proxy_http_clone.clone();
        tokio::spawn(async move {
            while let Some(packet) = response_rx.recv().await {
                println!(
                    "[HTTP Proxy] Getted request from http proxy: {:?}",
                    packet.to
                );
                let proxy = proxy_clone_rx.clone();
                let http_api = http_api_clone2.clone();
                tokio::spawn(async move {
                    let packet_clone = packet.clone();
                    match &packet_clone.data {
                        Some(TransportData::ProxyMessage(msg)) => {
                            println!(
                                "[HTTP Proxy] Getted request from http proxy: {:?}",
                                msg.from_peer_id
                            );
                            http_api
                                .set_response(msg.request_id.clone(), packet_clone.clone())
                                .await;
                            proxy
                                .set_response(msg.request_id.clone(), packet_clone)
                                .await;
                        }
                        Some(TransportData::FragmentSearchResponse(_)) => {
                            println!(
                                "[HTTP Proxy] Getted request from http proxy: {:?}",
                                packet_clone.peer_key.clone()
                            );
                            http_api
                                .set_response(packet_clone.uuid.clone(), packet_clone.clone())
                                .await;
                            proxy
                                .set_response(packet_clone.uuid.clone(), packet_clone)
                                .await;
                        }
                        _ => {
                            http_api
                                .set_response(packet_clone.uuid.clone(), packet_clone.clone())
                                .await;
                            proxy
                                .set_response(packet_clone.uuid.clone(), packet_clone)
                                .await;
                        }
                    }
                });
            }
        });

        server_arc
    }

    pub async fn run(self: Arc<Self>) {
        let addr = format!("0.0.0.0:{}", self.port);
        let listener = TcpListener::bind(addr.clone()).await.unwrap();
        log(&format!("[SignalServer] Running on {}", addr));

        loop {
            let (socket, _) = listener.accept().await.unwrap();
            log(&format!(
                "[SignalServer] New connection: {}",
                socket.peer_addr().unwrap()
            ));

            let peer = Peer::new(socket, None);

            self.add_peer(peer.clone(), false).await.unwrap();

            let self_clone: Arc<SignalServer> = Arc::clone(&self);
            tokio::spawn(async move {
                self_clone.handle_connection(peer.clone()).await;
            });
        }
    }

    async fn connect_to_signal_server(
        self: Arc<Self>,
        server_addr: &str,
        public_key: &str,
    ) -> Result<(), String> {
        let parts: Vec<&str> = server_addr.split(':').collect();
        if parts.len() != 2 {
            return Err(format!("Invalid server address format: {}", server_addr));
        }

        let ip = parts[0];
        let port: i64 = parts[1].parse::<i64>().map_err(|e| e.to_string())?;

        let mut client = SignalClient::new(&self.db);
        client
            .connect(ip, port, &self.ip, self.port as u16, public_key)
            .await?;

        let message_rx = client.get_message_receiver();
        let client_arc = Arc::new(client);
        self.connected_servers
            .write()
            .await
            .push(client_arc.clone());

        let self_clone: Arc<SignalServer> = Arc::clone(&self);
        if let Some(mut message_rx) = message_rx {
            tokio::spawn(async move {
                while let Some(packet) = message_rx.recv().await {
                    log(&format!(
                        "[SignalServer] Received packet from signal server",
                    ));
                    self_clone.handle_signal_server_packet(packet).await;
                }
            });
        }

        Ok(())
    }

    async fn handle_signal_server_packet(&self, packet: TransportPacket) {
        match packet.protocol {
            Protocol::SIGNAL => {
                if let Some(data) = &packet.data {
                    match data {
                        TransportData::PeerSearchRequest(request) => {
                            log(&format!(
                                "[SignalServer] Received search request from signal server for peer {} (from {})",
                                request.search_id, request.peer_id
                            ));
                            if let Err(e) = self
                                .peer_search_manager
                                .handle_search_request(request.clone())
                                .await
                            {
                                log(&format!(
                                    "[SignalServer] Failed to handle search request: {}",
                                    e
                                ));
                            }
                        }
                        TransportData::PeerSearchResponse(response) => {
                            log(&format!(
                                "[SignalServer] Received search response from signal server for peer {} (from {})",
                                response.search_id, response.peer_id
                            ));
                            log(&format!(
                                "[SignalServer] Response details - found_peer: {}, public_ip: {}, public_port: {}, hops: {}",
                                response.found_peer_id, response.public_ip, response.public_port, response.hops
                            ));
                            if let Err(e) = self
                                .peer_search_manager
                                .handle_search_response(response.clone())
                                .await
                            {
                                log(&format!(
                                    "[SignalServer] Failed to handle search response: {}",
                                    e
                                ));
                            }
                        }
                        _ => {
                            log(&format!(
                                "[SignalServer] Received unknown packet: {:?}",
                                packet.act
                            ));
                            self.auto_send_packet(packet).await;
                        }
                    }
                }
            }
            _ => {
                log(&format!(
                    "[SignalServer] Received unknown packet: {:?}",
                    packet.act
                ));
                self.auto_send_packet(packet).await;
            }
        }
    }

    async fn handle_connection(self: Arc<Self>, peer: Arc<Peer>) {
        loop {
            let message = match peer.receive().await {
                Ok(msg) => msg,
                Err(e) => {
                    log(&format!(
                        "[SignalServer] Failed to receive message from peer {}: {}",
                        peer.info.local_addr, e
                    ));
                    self.remove_peer(&peer).await;
                    break;
                }
            };
            log(&format!("[SignalServer] Received message"));

            if let Err(e) = self.message_tx.send((peer.clone(), message)).await {
                log(&format!(
                    "[SignalServer] Failed to send message to handler: {}",
                    e
                ));
                self.remove_peer(&peer).await;
                break;
            }
        }
        log(&format!(
            "[SignalServer] Connection handler finished for peer: {}",
            peer.info.local_addr
        ));
    }

    async fn remove_peer(self: Arc<Self>, peer: &Arc<Peer>) -> bool {
        let peer_addr = peer.info.local_addr.clone();
        let peer_key = peer.info.peer_key.read().await.clone();
        
        let mut peers = self.peers.write().await;
        let peer_index = peers
            .iter()
            .position(|p| p.info.local_addr == peer_addr);

        if let Some(index) = peer_index {
            peers.remove(index);
            
            if let Some(key) = &peer_key {
                self.pending_responses.remove(key);
            }
            
            log(&format!(
                "[SignalServer] Successfully removed peer {} with key {:?}",
                peer_addr, peer_key
            ));
            true
        } else {
            log(&format!(
                "[SignalServer] Peer {} not found in the list",
                peer_addr
            ));
            false
        }
    }

    async fn sync_peers(self: Arc<Self>, peer: Arc<Peer>) {
        let peers_info: Vec<SyncPeerInfo> = {
            let peers_guard = self.peers.read().await;
            let mut peers_info = Vec::new();
            for p in peers_guard.iter() {
                let uuid = p
                    .info
                    .peer_key
                    .read()
                    .await
                    .clone()
                    .unwrap_or_else(|| "Not set".to_string());
                peers_info.push(SyncPeerInfo { uuid: uuid });
            }
            peers_info
        };

        let peer_uuid = peer
            .info
            .peer_key
            .read()
            .await
            .clone()
            .unwrap_or_else(|| "Not set".to_string());
        let peer_uuid_clone = peer_uuid.clone();

        let packet = TransportPacket {
            act: "peer_list".to_string(),
            to: Some(peer_uuid.clone().to_string()),
            data: Some(TransportData::SyncPeerInfoData(SyncPeerInfoData {
                peers: peers_info,
            })),
            protocol: Protocol::SIGNAL,
            peer_key: self.db.get_or_create_peer_id().unwrap(),
            uuid: generate_uuid(),
            nodes: vec![],
        };

        let packet = serde_json::to_string(&packet).unwrap();
        if let Err(e) = peer.send(packet).await {
            log(&format!(
                "[SignalServer] Failed to send peer list to peer {}: {}",
                peer_uuid_clone.clone().as_str(),
                e
            ));
        } else {
            log(&format!(
                "[SignalServer] Successfully sent peer list to peer {}",
                peer_uuid
            ));
        }
    }

    async fn handle_message(&self, server: &Arc<SignalServer>, peer: Arc<Peer>, message: String) {
        log(&format!(
            "[SignalServer] Handling message from peer {}",
            peer.info.local_addr
        ));
        let message: TransportPacket = match serde_json::from_str(&message) {
            Ok(msg) => msg,
            Err(e) => {
                log(&format!(
                    "[SignalServer] Failed to parse message from peer {}: {}. Message: {}",
                    peer.info.local_addr, e, message
                ));
                return;
            }
        };

        if let Some((_uuid, sender)) = self.pending_responses.remove(&message.uuid) {
            let _ = sender.send(message.clone());
        }

        if message.act == "http_proxy_response" {
            if let Some(target_peer_id) = &message.to {
                if *target_peer_id != *self.my_public_key {
                    log(&format!("Sending response to peer: {:?}", message.to));
                    self.auto_send_packet(message).await;
                } else {
                    log("Sending response to channel response");
                    self.response_tx.send(message).await;
                }
            }
            return;
        }

        let peer_key = &message.peer_key;
        let is_peer_wait_connection = message.act == "wait_connection";
        let is_peer_accept_connection = message.act == "accept_connection";

        peer.set_wait_connection(is_peer_wait_connection || is_peer_accept_connection)
            .await;
        peer.set_peer_key(peer_key.clone()).await;

        if message.act == "info" {
            let packet_request_sync_fragments = TransportPacket {
                act: "request_fragments".to_string(),
                to: Some(peer_key.clone()),
                data: None,
                protocol: Protocol::SIGNAL,
                peer_key: self.db.get_or_create_peer_id().unwrap(),
                uuid: generate_uuid(),
                nodes: vec![],
            };
            self.auto_send_packet(packet_request_sync_fragments).await;
        } else if message.act == "file" {
            self.response_tx.send(message.clone()).await;
        }

        if let Some(data) = &message.data {
            match data {
                TransportData::SignalServerInfo(server_info) => {
                    log(&format!(
                        "[SignalServer] Received signal server info from peer {}: {:?}",
                        peer_key, server_info
                    ));

                    let stored_info = StoredSignalServerInfo {
                        public_key: server_info.public_key.clone(),
                        public_ip: server_info.public_ip.clone(),
                        port: server_info.port,
                    };

                    if let Ok(mut servers_list) = SignalServersList::load_or_create() {
                        if let Err(e) = servers_list.add_server(stored_info.clone()) {
                            log(&format!(
                                "[SignalServer] Failed to add signal server to list: {}",
                                e
                            ));
                        } else if stored_info.public_ip != self.ip.to_string() {
                            let server_addr =
                                format!("{}:{}", stored_info.public_ip, stored_info.port);
                            let server_clone = Arc::clone(server);
                            tokio::spawn(async move {
                                if let Err(e) = server_clone
                                    .connect_to_signal_server(&server_addr, &stored_info.public_key)
                                    .await
                                {
                                    log(&format!(
                                        "[SignalServer] Failed to connect to signal server {}: {}",
                                        server_addr, e
                                    ));
                                }
                            });
                        }
                    }
                }
                TransportData::PeerSearchRequest(request) => {
                    log(&format!(
                        "[SignalServer] Received search request for peer {} from {}",
                        request.search_id, request.peer_id
                    ));
                    if let Err(e) = self
                        .peer_search_manager
                        .handle_search_request(request.clone())
                        .await
                    {
                        log(&format!(
                            "[SignalServer] Failed to handle search request: {}",
                            e
                        ));
                    }
                }
                TransportData::PeerSearchResponse(response) => {
                    log(&format!(
                        "[SignalServer] Received search response for peer {} from {}",
                        response.search_id, response.peer_id
                    ));
                    if let Err(e) = self
                        .peer_search_manager
                        .handle_search_response(response.clone())
                        .await
                    {
                        log(&format!(
                            "[SignalServer] Failed to handle search response: {}",
                            e
                        ));
                    }
                }
                TransportData::PeerInfo(info) => {
                    log(&format!(
                        "[SignalServer] Setting peer UUID: {}",
                        info.public_key
                    ));
                    peer.set_peer_key(info.public_key.clone()).await;
                }
                TransportData::PeerWaitConnection(data) => {
                    peer.add_open_tunnel(
                        &data.connect_peer_id,
                        data.public_ip.clone(),
                        data.public_port,
                    )
                    .await;
                }
                TransportData::StorageReservationRequest(request) => {
                    // Отправляем запрос всем пирам
                    let peers = self.peers.read().await;
                    for p in peers.iter() {
                        if p.get_key().await.as_ref() != Some(&request.peer_id) {
                            log(&format!(
                                "[SignalServer] Forwarding storage reservation request to peer: {}",
                                p.get_key().await.unwrap_or_default()
                            ));
                            let packet = TransportPacket {
                                act: "reserve_storage".to_string(),
                                to: Some(p.get_key().await.unwrap_or_default()),
                                data: Some(TransportData::StorageReservationRequest(
                                    request.clone(),
                                )),
                                protocol: Protocol::SIGNAL,
                                peer_key: self.db.get_or_create_peer_id().unwrap(),
                                uuid: generate_uuid(),
                                nodes: vec![SearchPathNode {
                                    uuid: self.db.get_or_create_peer_id().unwrap(),
                                    public_ip: self.ip.clone(),
                                    public_port: self.port,
                                }],
                            };
                            if let Err(e) = p.send(serde_json::to_string(&packet).unwrap()).await {
                                log(&format!("[SignalServer] Failed to forward storage reservation request: {}", e));
                            }
                        }
                    }
                }
                TransportData::StorageReservationResponse(response) => {
                    let packet = TransportPacket {
                        act: "reserve_storage_response".to_string(),
                        to: Some(response.peer_id.clone()),
                        data: Some(TransportData::StorageReservationResponse(response.clone())),
                        protocol: Protocol::SIGNAL,
                        peer_key: self.db.get_or_create_peer_id().unwrap(),
                        uuid: generate_uuid(),
                        nodes: vec![],
                    };
                    self.auto_send_packet(packet).await;
                }
                TransportData::FragmentMetadataSync(data) => {
                    log(&format!(
                        "[SignalServer] Получены метаданные фрагментов от пира {}",
                        data.peer_id
                    ));

                    for fragment in data.fragments.clone() {
                        let storage = Storage {
                            file_hash: fragment.file_hash,
                            filename: String::new(),
                            token: String::new(),
                            token_hash: None,
                            uploaded_via_token: None,
                            owner_key: fragment.owner_key,
                            storage_peer_key: fragment.storage_peer_key,
                            mime: fragment.mime,
                            public: fragment.public,
                            encrypted: fragment.encrypted,
                            compressed: fragment.compressed,
                            auto_decompress: fragment.auto_decompress,
                            size: fragment.size,
                            tags: vec![],
                            groups: vec![],
                        };

                        if let Err(e) = self.db.add_storage_fragment(storage) {
                            log(&format!(
                                "[SignalServer] Ошибка при сохранении метаданных фрагмента: {}",
                                e
                            ));
                        }
                    }

                    log("[SignalServer] Метаданные фрагментов успешно сохранены");

                    let packet = TransportPacket {
                        act: "sync_fragments".to_string(),
                        to: None,
                        data: Some(TransportData::FragmentMetadataSync(data.clone())),
                        protocol: Protocol::SIGNAL,
                        peer_key: self.db.get_or_create_peer_id().unwrap(),
                        uuid: generate_uuid(),
                        nodes: vec![],
                    };
                    self.broadcast_to_servers(packet).await;
                }
                TransportData::FragmentSearchRequest(request) => {
                    log(&format!(
                        "[SignalServer] Get fragment search request: {}",
                        request.query
                    ));

                    match self.search_fragments(&request.query).await {
                        Ok(fragments) => {
                            println!(
                                "[SignalServer] [DEBUG] Found fragments: {:?}",
                                fragments.len()
                            );
                            let response = TransportPacket {
                                act: "search_fragments_response".to_string(),
                                to: Some(message.peer_key.clone()),
                                data: Some(TransportData::FragmentSearchResponse(
                                    FragmentSearchResponse {
                                        fragments,
                                        request_id: request.request_id.clone(),
                                    },
                                )),
                                protocol: Protocol::SIGNAL,
                                peer_key: self.db.get_or_create_peer_id().unwrap(),
                                uuid: message.uuid.clone(),
                                nodes: vec![],
                            };

                            self.auto_send_packet(response).await;
                        }
                        Err(e) => {
                            log(&format!(
                                "[SignalServer] Ошибка при поиске фрагментов: {}",
                                e
                            ));
                        }
                    }
                }
                _ => {}
            }
        }

        if message.act == "info" {
            if let Some(TransportData::PeerInfo(info)) = &message.data {
                peer.set_is_signal_server(info.is_signal_server).await;

                if let Err(e) = self.db.update_peer_stats(
                    &info.public_key.clone(),
                    info.total_space,
                    info.free_space,
                    info.stored_files.clone(),
                ) {
                    log(&format!("[SignalServer] Failed to sync peer stats: {}", e));
                }
            }

            log("[SignalServer] =================");
            log("[SignalServer] CONNECTED PEER INFO:");
            log(&format!("[SignalServer] PUBLIC ADDRESS: {}", peer_key));
            log(&format!(
                "[SignalServer] LOCAL ADDRESS: {}",
                peer.info.local_addr
            ));
            log(&format!(
                "[SignalServer] IS SIGNAL SERVER: {}",
                peer.is_signal_server().await
            ));
            if let Some(uuid) = peer.info.peer_key.read().await.clone() {
                log(&format!("[SignalServer] PEER UUID: {}", uuid));
            } else {
                log("[SignalServer] PEER UUID: Not set");
            }
            log("[SignalServer] =================");

            server.clone().sync_peers(peer.clone()).await;
        }

        match message.protocol {
            Protocol::STUN => {
                if is_peer_wait_connection {
                    log(&format!(
                        "[SignalServer] Peer is ready to connect: {}",
                        peer_key
                    ));
                    if let Some(TransportData::PeerWaitConnection(data)) = message.data {
                        log(&format!(
                            "[SignalServer] Looking for peer with UUID: {}",
                            data.connect_peer_id
                        ));
                        let peers_guard = server.peers.read().await;
                        for target_peer in peers_guard.iter() {
                            if let Some(uuid) = target_peer.info.peer_key.read().await.clone() {
                                let open_tunnel =
                                    target_peer.get_open_tunnel(&data.connect_peer_id).await;
                                if uuid == data.connect_peer_id {
                                    log(&format!(
                                        "[SignalServer] Found peer with matching UUID: {}",
                                        data.connect_peer_id
                                    ));
                                    log("peer finded");
                                    if open_tunnel.is_some() {
                                        log("[SignalServer] Peer have open tunnel. Start connect peers");
                                        let server_clone = Arc::clone(server);
                                        server_clone
                                            .connect_peers(peer.clone(), target_peer.clone())
                                            .await;
                                    } else {
                                        log("[SignalServer] Peer without open tunnel, send wait connection");
                                        let packet = TransportPacket {
                                            act: message.act.to_string(),
                                            to: message.to.clone(),
                                            data: Some(TransportData::PeerWaitConnection(
                                                data.clone(),
                                            )),
                                            protocol: Protocol::STUN,
                                            peer_key: message.peer_key.to_string(),
                                            uuid: message.peer_key.to_string(),
                                            nodes: vec![],
                                        };
                                        let packet_json = serde_json::to_string(&packet).unwrap();
                                        target_peer.send(packet_json).await;
                                        log("sended packet json");
                                    }
                                    return;
                                }
                            }
                        }
                        log(&format!(
                            "[SignalServer] Peer with UUID {} not found",
                            data.connect_peer_id
                        ));
                    }
                } else if is_peer_accept_connection {
                    if let Some(TransportData::PeerWaitConnection(data)) = message.data.clone() {
                        let peers_guard = server.peers.read().await;
                        for target_peer in peers_guard.iter() {
                            if let Some(uuid) = target_peer.info.peer_key.read().await.clone() {
                                if uuid == data.connect_peer_id {
                                    let open_tunnel_a = peer.get_open_tunnel(&uuid).await;
                                    let open_tunnel_b =
                                        target_peer.get_open_tunnel(&peer_key).await;
                                    if open_tunnel_a.is_some() && open_tunnel_b.is_some() {
                                        log("[SignalServer] Both peers have open tunnels. Connecting");
                                        server
                                            .connect_peers(peer.clone(), target_peer.clone())
                                            .await;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Protocol::TURN => {
                if let Some(to) = &message.to {
                    log(&format!(
                        "[SignalServer] Received turn packet: {:?}",
                        message
                    ));
                    if to.clone() == *self.my_public_key.clone() {
                        if let Some(TransportData::PeerFileSaved(data)) = &message.data {
                            self.response_tx.send(message.clone()).await;
                        }
                    } else {
                        let peers_guard = server.peers.read().await;
                        for item in peers_guard.iter() {
                            if *item.info.peer_key.read().await == Some(to.clone()) {
                                log(&format!(
                                    "[SignalServer] Send turn packet: {} {:?}",
                                    peer.info.local_addr, message
                                ));

                                let turn_packet = TransportPacket {
                                    act: message.act.to_string(),
                                    to: message.to.clone(),
                                    data: message.data.clone(),
                                    protocol: Protocol::TURN,
                                    peer_key: message.peer_key.to_string(),
                                    uuid: message.peer_key.to_string(),
                                    nodes: vec![],
                                };
                                let turn_packet = serde_json::to_string(&turn_packet).unwrap();
                                if let Err(e) = item.send(turn_packet).await {
                                    log(&format!(
                                        "[SignalServer] Failed to send turn packet to peer {}: {}",
                                        item.info.local_addr, e
                                    ));
                                } else {
                                    log(&format!(
                                        "[SignalServer] Successfully send turn packet to peer {}",
                                        item.info.local_addr
                                    ));
                                }
                                break;
                            }
                        }
                    }
                }
            }
            Protocol::SIGNAL => {
                if message.act == "peer_list" {
                    server.clone().sync_peers(peer.clone()).await;
                } else if message.protocol == Protocol::STUN && message.act == "wait_connection" {
                    if let Some(TransportData::SyncPeerInfoData(data)) = &message.data {
                        log("[SignalServer] Processing peers for wait_connection:");
                        for peer in &data.peers {
                            // println!("  - Public Address: {}", peer.public_addr);
                            log(&format!("    UUID: {}", peer.uuid));
                        }
                    } else {
                        log("[SignalServer] No peers found in the data for wait_connection.");
                    }
                } else if message.to.is_some() {
                    if message.to != Some((*self.my_public_key).clone()) {
                        log(&format!(
                            "[SignalServer] Sending packet to peer: {}",
                            message.to.clone().unwrap()
                        ));
                        self.auto_send_packet(message.clone()).await;
                    }
                }
            }
        }
    }

    pub async fn auto_send_packet(&self, message: TransportPacket) {
        if message.to.is_some() {
            let target_peer_id = message.to.clone().unwrap();
            let from_peer_id = message.peer_key.clone();
            let mut sended = false;

            if from_peer_id == *target_peer_id {
                return;
            }

            for peer in self.peers.read().await.iter() {
                if peer.info.peer_key.read().await.clone().unwrap() == target_peer_id
                    || peer.is_signal_server().await
                {
                    peer.send(serde_json::to_string(&message).unwrap()).await;
                    sended = true;
                }
            }
            let len_connected_servers = self.connected_servers.read().await.len();
            if !sended && len_connected_servers > 0 {
                for server in self.connected_servers.read().await.iter() {
                    if server.public_key != from_peer_id {
                        log(&format!(
                            "[SignalServer] Sending packet to signal server: {:?}. from uuid: {}",
                            server.public_key, from_peer_id
                        ));
                        server.send_packet(message.clone()).await;
                    }
                }
            }
        }
    }

    async fn send_to_peer_by_packet(&self, message: TransportPacket) {
        for peer in self.peers.read().await.iter() {
            if peer.info.peer_key.read().await.clone().unwrap() == message.to.clone().unwrap() {
                peer.send(serde_json::to_string(&message).unwrap()).await;
            }
        }
    }

    async fn connect_peers(&self, first_peer: Arc<Peer>, second_peer: Arc<Peer>) {
        log("[SignalServer] Connecting peers");

        {
            log(&format!(
                "[SignalServer] Sending packet to: {}",
                second_peer.info.local_addr
            ));
            SignalServer::send_peer_info(second_peer.clone(), first_peer.clone()).await;
            log(&format!(
                "[SignalServer] Sent packet to peer: {}",
                second_peer.info.local_addr
            ));
        }
        second_peer.set_wait_connection(false).await;
        tokio::time::sleep(Duration::from_millis(500)).await;
        {
            log(&format!(
                "[SignalServer] Sending packet to: {}",
                first_peer.info.local_addr
            ));
            SignalServer::send_peer_info(first_peer.clone(), second_peer.clone()).await;
            log(&format!(
                "[SignalServer] Sent packet to peer: {}",
                first_peer.info.local_addr
            ));
        }
        first_peer.set_wait_connection(false).await;
    }

    async fn add_peer(
        &self,
        peer: Arc<Peer>,
        is_peer_wait_connection: bool,
    ) -> Result<Arc<Peer>, String> {
        let mut peers_guard = self.peers.write().await;
        let mut peer_added = false;
        let mut peer_res: Option<Arc<Peer>> = None;
        for item in peers_guard.iter() {
            if *item.info.local_addr == peer.info.local_addr {
                log(&format!(
                    "Peer already in the list: {}",
                    peer.info.local_addr
                ));
                peer_added = true;
                if is_peer_wait_connection {
                    let mut wait_connection = item.info.wait_connection.write().await;
                    *wait_connection = true;
                }
                peer_res = Some(item.clone());
                break;
            }
        }
        if !peer_added {
            peer_res = Some(peer.clone());
            peers_guard.push(peer.clone());
        }
        if peer_res.is_none() {
            return Err("Failed to add peer to the list".to_string());
        }
        return Ok(peer_res.clone().unwrap());
    }

    async fn send_peer_info(to_peer: Arc<Peer>, about_peer: Arc<Peer>) {
        let pub_id = about_peer.info.peer_key.read().await.clone().unwrap();
        if let Some(key_peer) = to_peer.get_key().await {
            let data_open_tunnel = about_peer.get_open_tunnel(&key_peer.to_string()).await;
            if let Some(open_tunnel) = data_open_tunnel {
                let wait_packet = TransportPacket {
                    act: "accept_connection".to_string(), // TODO: было wait_connection
                    to: Some(pub_id.clone()),             // UUID кому отправляем данный пакет
                    data: Some(TransportData::PeerWaitConnection(PeerWaitConnection {
                        connect_peer_id: pub_id.clone(),
                        public_ip: open_tunnel.ip,
                        public_port: open_tunnel.port,
                    })),
                    protocol: Protocol::STUN,
                    peer_key: about_peer.info.peer_key.read().await.clone().unwrap(),
                    uuid: generate_uuid(),
                    nodes: vec![],
                };
                let wait_packet = serde_json::to_string(&wait_packet).unwrap();

                log(&format!(
                    "[SignalServer] Sending wait packet to peer: {}",
                    to_peer.info.local_addr
                ));
                let result = to_peer.send(wait_packet).await;

                match result {
                    Ok(_) => log(&format!(
                        "[SignalServer] Successfully sent packet to peer: {}. Peer connecting to: {}",
                        key_peer,
                        pub_id,
                    )),
                    Err(e) => log(&format!("[SignalServer] Failed to send peer to peer info: {}", e)),
                }
            }
        }
    }

    async fn broadcast_to_servers(&self, packet: TransportPacket) {
        let servers = self.connected_servers.read().await;
        for server in servers.iter() {
            if let Err(e) = server.send_packet(packet.clone()).await {
                log(&format!(
                    "[SignalServer] Failed to broadcast to server: {}",
                    e
                ));
            }
        }
    }

    async fn sync_fragments_with_peers(&self) {
        log("[SignalServer] Начинаем синхронизацию фрагментов с пирами");

        let peers = self.peers.read().await;
        for peer in peers.iter() {
            if let Some(peer_id) = peer.get_key().await {
                let packet = TransportPacket {
                    act: "request_fragments".to_string(),
                    to: Some(peer_id.clone()),
                    data: None,
                    protocol: Protocol::SIGNAL,
                    peer_key: self.db.get_or_create_peer_id().unwrap(),
                    uuid: generate_uuid(),
                    nodes: vec![],
                };

                if let Err(e) = peer.send(serde_json::to_string(&packet).unwrap()).await {
                    log(&format!(
                        "[SignalServer] Ошибка при запросе фрагментов у пира {}: {}",
                        peer_id, e
                    ));
                } else {
                    log(&format!(
                        "[SignalServer] Запрос фрагментов отправлен пиру {}",
                        peer_id
                    ));
                }
            }
        }
    }

    pub async fn wait_for_response(
        &self,
        uuid: String,
        timeout: Duration,
    ) -> Result<TransportPacket, String> {
        let (tx, rx) = oneshot::channel();
        self.pending_responses.insert(uuid.clone(), tx);

        match tokio::time::timeout(timeout, rx).await {
            Ok(Ok(packet)) => Ok(packet),
            Ok(Err(_)) => Err("Channel closed before receiving response".to_string()),
            Err(_) => {
                self.pending_responses.remove(&uuid);
                Err("Timeout waiting for response".to_string())
            }
        }
    }

    pub async fn search_fragments(&self, query: &str) -> Result<Vec<Storage>, String> {
        self.db
            .search_fragment_in_virtual_storage(query, None)
            .map_err(|e| e.to_string())
    }
}


=== ../src\signal\signal_servers.rs ===
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SignalServerInfo {
    pub public_key: String,
    pub public_ip: String,
    pub port: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SignalServersList {
    pub servers: Vec<SignalServerInfo>,
}

impl SignalServersList {
    pub fn new() -> Self {
        SignalServersList {
            servers: Vec::new(),
        }
    }

    pub fn load_or_create() -> Result<Self, String> {
        let path = Path::new("signal_servers.json");
        if path.exists() {
            let content = fs::read_to_string(path)
                .map_err(|e| format!("Failed to read signal_servers.json: {}", e))?;
            serde_json::from_str(&content)
                .map_err(|e| format!("Failed to parse signal_servers.json: {}", e))
        } else {
            let list = SignalServersList::new();
            list.save()?;
            Ok(list)
        }
    }

    pub fn save(&self) -> Result<(), String> {
        let content = serde_json::to_string_pretty(self)
            .map_err(|e| format!("Failed to serialize signal servers list: {}", e))?;
        fs::write("signal_servers.json", content)
            .map_err(|e| format!("Failed to write signal_servers.json: {}", e))
    }

    pub fn add_server(&mut self, server: SignalServerInfo) -> Result<(), String> {
        // Проверяем, нет ли уже такого сервера
        if !self.servers.iter().any(|s| s.public_key == server.public_key) {
            self.servers.push(server);
            self.save()?;
        }
        Ok(())
    }
} 

=== ../src\simulation\mod.rs ===
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::config::Config;
use crate::signal::SignalServer;
use crate::peer::Peer;
use crate::db::P2PDatabase;
use std::path::PathBuf;
use std::collections::HashMap;

pub struct NetworkSimulation {
    signal_servers: HashMap<String, Arc<SignalServer>>,
    peers: HashMap<String, Arc<Mutex<Peer>>>,
    db_paths: HashMap<String, PathBuf>,
}

impl NetworkSimulation {
    pub fn new() -> Self {
        Self {
            signal_servers: HashMap::new(),
            peers: HashMap::new(),
            db_paths: HashMap::new(),
        }
    }

    pub async fn add_signal_server(&mut self, config: &Config, id: String, db_path: PathBuf) -> Result<(), Box<dyn std::error::Error>> {
        if !db_path.exists() {
            std::fs::create_dir_all(&db_path)?;
        }
        let db = P2PDatabase::new(db_path.to_str().unwrap())?;
        let signal_server = SignalServer::new(config, &db).await;
        self.signal_servers.insert(id.clone(), signal_server);
        self.db_paths.insert(id, db_path);
        Ok(())
    }

    pub async fn add_peer(&mut self, config: &Config, id: String, db_path: PathBuf) -> Result<(), Box<dyn std::error::Error>> {
        if !db_path.exists() {
            std::fs::create_dir_all(&db_path)?;
        }
        let db = P2PDatabase::new(db_path.to_str().unwrap())?;
        let peer = Peer::new(config, &db).await;
        self.peers.insert(id.clone(), Arc::new(Mutex::new(peer)));
        self.db_paths.insert(id, db_path);
        Ok(())
    }

    pub async fn run_simulation(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut handles = vec![];

        // Запускаем сигнальные серверы
        for (id, server) in &self.signal_servers {
            let server = server.clone();
            let id = id.clone();
            handles.push(tokio::spawn(async move {
                println!("Starting signal server: {}", id);
                server.run().await;
            }));
        }

        // Запускаем пиры
        for (id, peer) in &self.peers {
            let peer = peer.clone();
            let id = id.clone();
            handles.push(tokio::spawn(async move {
                println!("Starting peer: {}", id);
                peer.lock().await.run().await;
            }));
        }

        // Ждем завершения всех задач
        for handle in handles {
            handle.await?;
        }

        Ok(())
    }

    pub fn get_peer(&self, id: &str) -> Option<&Arc<Mutex<Peer>>> {
        self.peers.get(id)
    }
} 

=== ../src\tunnel\mod.rs ===
mod tunnel;

pub use self::tunnel::Tunnel;

=== ../src\tunnel\tunnel.rs ===
use async_std::net::{SocketAddr, UdpSocket, IpAddr};
use async_std::sync::RwLock;
use async_std::{fs, task};
use rand::Rng;
use serde::{Deserialize, Serialize};
use serde_json::Number;
use std::sync::Arc;
use std::time::Duration;
use std::{str, thread};
use stun_client::*;
use tokio::time::timeout;
use std::net::Ipv4Addr;

#[derive(Serialize, Deserialize)]
struct Message {
    text: String,
}

#[derive(Serialize, Deserialize)]
struct FileMessage {
    filename: String,
    data: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct Tunnel {
    pub local_port: u16,
    pub public_ip: String,
    pub public_port: u16,
    pub socket: Option<Arc<UdpSocket>>,
    client: Option<SocketAddr>,
    pub is_connected: Arc<RwLock<bool>>,
}

impl Tunnel {
    pub async fn new() -> Self {
        let local_port = rand::thread_rng().gen_range(16000..65535);
        let (public_ip, public_port) = Self::stun(local_port).await;
        let mut is_connected = Arc::new(RwLock::new(false));
        Tunnel {
            local_port,
            public_ip,
            public_port,
            socket: None,
            client: None,
            is_connected,
        }
    }
    
    pub async fn with_port(port: u16) -> Self {
        let (public_ip, public_port) = Self::stun(port).await;
        Tunnel {
            local_port: port,
            public_ip,
            public_port,
            socket: None,
            client: None,
            is_connected: Arc::new(RwLock::new(false)),
        }
    }

    pub fn get_public_addr(&self) -> String {
        return format!("{}:{}", self.public_ip, self.public_port);
    }

    async fn load_stun_servers() -> Vec<String> {
        let default_servers = vec![
            "stun.l.google.com:19302",
            "stun1.l.google.com:19302",
            "stun2.l.google.com:19302",
            "stun3.l.google.com:19302",
            "stun4.l.google.com:19302",
            "stun.stunprotocol.org:3478",
            "stun.voipstunt.com:3478"
        ];

        match fs::read_to_string("stun_servers.txt").await {
            Ok(content) => {
                let mut servers: Vec<String> = content
                    .lines()
                    .map(|line| line.trim().to_string())
                    .filter(|line| !line.is_empty())
                    .collect();
                
                for server in default_servers {
                    if !servers.contains(&server.to_string()) {
                        servers.push(server.to_string());
                    }
                }
                servers
            }
            Err(e) => {
                println!("[WARNING] Failed to load STUN servers from file: {:?}. Using default servers.", e);
                default_servers.into_iter().map(|s| s.to_string()).collect()
            }
        }
    }

    async fn stun(port: u16) -> (String, u16) {
        let client = Client::new(format!("0.0.0.0:{}", port), None).await;
        if let Err(e) = client {
            panic!("Failed to create STUN client: {:?}", e);
        }
        let mut client = client.unwrap();

        let stun_servers = Self::load_stun_servers().await;
        println!("[DEBUG] Loaded {} STUN servers", stun_servers.len());

        let mut last_error = None;
        let mut last_res = None;
        for server in stun_servers {
            println!("[DEBUG] Trying STUN server: {}", server);
            let res = client.binding_request(&server, None).await;
            match res {
                Ok(response) => {
                    println!("[DEBUG] Successfully connected to STUN server: {}", server);
                    last_res = Some(response);
                    break;
                }
                Err(e) => {
                    println!("[DEBUG] Failed to connect to {}: {:?}", server, e);
                    last_error = Some(e);
                    continue;
                }
            }
        }

        if last_res.is_none() {
            if let Some(e) = last_error {
                panic!("Failed to connect to any STUN server. Last error: {:?}", e);
            } else {
                panic!("Failed to connect to any STUN server and no error was recorded");
            }
        }

        let res = last_res.unwrap();

        let xor_mapped_addr = Attribute::get_xor_mapped_address(&res);
        if let Some(addr) = xor_mapped_addr {
            (addr.ip().to_string(), addr.port())
        } else {
            let mapped_addr = Attribute::get_mapped_address(&res);
            if let Some(addr) = mapped_addr {
                (addr.ip().to_string(), addr.port())
            } else {
                panic!(
                    "Failed to get XOR mapped address or Mapped address from STUN response: {:?}",
                    res
                );
            }
        }
    }

    fn get_local_ip() -> Option<IpAddr> {
        if let Ok(socket) = std::net::UdpSocket::bind("0.0.0.0:0") {
            if let Ok(()) = socket.connect("8.8.8.8:80") {
                if let Ok(addr) = socket.local_addr() {
                    return Some(addr.ip());
                }
            }
        }
        None
    }

    pub async fn make_connection(
        &mut self,
        ip: &str,
        port: u16,
        timeout_default: u64,
    ) -> Result<(), String> {
        println!("[STUN] make_connection");
        println!("[STUN] IP: {}", ip);
        println!("[STUN] Public IP: {}", self.public_ip);
        let local_ip = match Self::get_local_ip() {
            Some(ip) => ip.to_string(),
            None => return Err("[STUN] Не удалось определить локальный IP".to_string()),
        };
        println!("[STUN] Локальный IP: {}", local_ip);

        // if ip == self.public_ip {
        //     println!("[STUN] Обнаружено локальное соединение. Используем локальную сеть.");
        //     let addr = format!("{}:{}", local_ip, port)
        //         .parse::<SocketAddr>()
        //         .expect("Invalid address");
        //     let local_port = self.local_port;
            
        //     let sock = match UdpSocket::bind(format!("0.0.0.0:{}", local_port)).await {
        //         Ok(s) => Arc::new(s),
        //         Err(e) => {
        //             return Err(format!("[STUN] Failed to bind UDP socket: {:?}", e));
        //         }
        //     };

        //     if let Err(e) = sock.send_to(b"Local Con. Request!", addr).await {
        //         return Err(format!("[STUN] Failed to send local connection request: {:?}", e));
        //     }

        //     let mut buf = vec![0u8; 1024];
        //     match timeout(Duration::from_secs(2), sock.recv_from(&mut buf)).await {
        //         Ok(res) => match res {
        //             Ok((_n, peer)) => {
        //                 println!("[STUN] Локальное соединение установлено с {}:{}", peer.ip(), peer.port());
        //                 self.client = Some(addr);
        //                 self.socket = Some(sock.clone());
        //                 self.is_connected = Arc::new(RwLock::new(true));
        //                 return Ok(());
        //             }
        //             Err(e) => {
        //                 return Err(format!("[STUN] Error while receiving data: {:?}", e));
        //             }
        //         },
        //         Err(_) => {
        //             return Err(format!("[STUN] Timeout while establishing local connection"));
        //         }
        //     }
        // }

        let addr = format!("{}:{}", ip, port)
            .parse::<SocketAddr>()
            .expect("Invalid address");
        let local_port = self.local_port;
        let mut timeout_count = timeout_default;
        println!("[STUN] Trying to connect to {}:{}", ip, port);

        while timeout_count > 0 {
            let sock = match UdpSocket::bind(format!("0.0.0.0:{}", local_port)).await {
                Ok(s) => Arc::new(s),
                Err(e) => {
                    return Err(format!("[STUN] Failed to bind UDP socket: {:?}", e));
                }
            };

            println!(
                "[STUN] Sending connection request to {}:{}... {}/{}",
                ip, port, timeout_count, timeout_default
            );

            if let Err(e) = sock.send_to(b"Con. Request!", addr).await {
                println!("[STUN] Failed to send connection request: {:?}", e);
                timeout_count -= 1;
                continue;
            }

            let mut buf = vec![0u8; 1024];
            match timeout(Duration::from_secs(2), sock.recv_from(&mut buf)).await {
                Ok(res) => match res {
                    Ok((_n, peer)) => {
                        println!(
                            "[STUN] Reply received from {}:{}...",
                            peer.ip(),
                            peer.port()
                        );
                        if let Err(e) = sock.send_to(b"Con. Request!", addr).await {
                            println!("[STUN] Failed to resend connection request: {:?}", e);
                            timeout_count -= 1;
                            continue;
                        }
                        self.client = Some(addr);
                        self.socket = Some(sock.clone());
                        self.is_connected = Arc::new(RwLock::new(true));
                        println!("[STUN] Hole with {} successfully broken!", addr);
                        return Ok(());
                    }
                    Err(e) => {
                        timeout_count -= 1;
                        println!("[STUN] Error while receiving data: {:?}", e);
                    }
                },
                Err(_) => {
                    timeout_count -= 1;
                    println!("[STUN] No handshake with {}:{} yet...", ip, port);
                }
            }
        }
        self.is_connected = Arc::new(RwLock::new(false));
        if self.client.is_none() {
            return Err(format!(
                "[STUN] Failed to establish connection with {}:{}",
                ip, port
            ));
        }
        Err(format!(
            "[STUN] Failed to establish connection with {}:{}",
            ip, port
        ))
    }

    pub fn backlife_cycle(&self, freq: u64) {
        if let Some(client) = self.client {
            if let Some(sock) = &self.socket {
                let sock = sock.clone();
                thread::spawn(move || {
                    Self::life_cycle(sock, client, freq);
                });
                println!("[STUN] Session with {} stabilized!", client);
            }
        } else {
            println!("[STUN] No client to stabilize session with.");
        }
    }

    fn life_cycle(sock: Arc<UdpSocket>, client: SocketAddr, freq: u64) {
        println!("[STUN] Starting life cycle...");
        let sock_clone = sock.clone();

        // Запуск отдельной задачи для отправки KPL
        thread::spawn(move || {
            loop {
                println!("[STUN] Sending keep-alive...");
                task::block_on(sock_clone.send_to(b"KPL", client)).unwrap();
                thread::sleep(Duration::from_secs_f64(1.0 / freq as f64));
            }
        });

        // Основной цикл для обработки входящих данных
        // loop {
        //     let mut buf = vec![0u8; 9999];
        //     while let Ok((n, reply_addr)) = task::block_on(sock.recv_from(&mut buf)) {
        //         Self::handle_received_data(&buf[..n], reply_addr, client, sock.clone(), message_tx.clone());
        //     }
        // }
    }

    fn handle_received_data(
        data: &[u8],
        reply_addr: SocketAddr,
        client: SocketAddr,
        sock: Arc<UdpSocket>,
    ) {
        let protocol = &data[..3];
        println!(
            "[STUN] {}: Received {} from {}: {:?}",
            client.ip(),
            str::from_utf8(protocol).unwrap(),
            reply_addr,
            data
        );

        if protocol == b"KPL" {
            return;
        } else if protocol == b"MSG" {
            let message: Message = serde_json::from_slice(&data[3..]).unwrap();
            println!("[STUN] Message from {}: {}", client.ip(), message.text);
        } else if protocol == b"FIL" {
            let file_message: FileMessage = serde_json::from_slice(&data[3..]).unwrap();
            println!(
                "[STUN] Received file {} from {}",
                file_message.filename,
                client.ip()
            );
            task::block_on(Self::save_file(&file_message.filename, &file_message.data));
        }
    }

    pub async fn send_message(&self, message: &str) {
        let msg = Message {
            text: message.to_string(),
        };
        let msg_bytes = serde_json::to_vec(&msg).unwrap();
        let client = self.client.unwrap();
        self.socket
            .as_ref()
            .unwrap()
            .send_to(&[b"MSG", &msg_bytes[..]].concat(), client)
            .await
            .unwrap();
    }

    async fn save_file(filename: &str, data: &[u8]) {
        let path = format!("./received_files/{}", filename);
        if let Err(e) = fs::create_dir_all("./received_files").await {
            println!("Failed to create directory: {:?}", e);
            return;
        }
        if let Err(e) = fs::write(&path, data).await {
            println!("Failed to save file: {:?}", e);
        } else {
            println!("File saved to {}", path);
        }
    }

    pub async fn send_file_path(&self, file_path: &str) {
        let filename = file_path.split('/').last().unwrap().to_string();
        let data = fs::read(file_path).await;
        if let Err(e) = data {
            println!("Failed to read file: {:?}", e);
            return;
        }
        self.send_file(&filename, data.unwrap()).await;
    }

    pub async fn send_file(&self, filename: &str, data: Vec<u8>) {
        let file_message = FileMessage {
            filename: filename.to_string(),
            data,
        };
        let file_message_bytes = serde_json::to_vec(&file_message).unwrap();
        let client = self.client.unwrap();
        self.socket
            .as_ref()
            .unwrap()
            .send_to(&[b"FIL", &file_message_bytes[..]].concat(), client)
            .await
            .unwrap();
    }

    pub fn get_public_ip(&self) -> String {
        self.public_ip.clone()
    }

    pub fn get_public_port(&self) -> u16 {
        self.public_port
    }

    pub async fn is_connected(&self) -> bool {
        *self.is_connected.read().await
    }
}


=== ../src\ui\console.rs ===
use crate::crypto::token::get_metadata_from_token;
use crate::db::P2PDatabase;
use crate::manager::ConnectionTurnStatus;
use crate::peer::peer_api::PeerAPI;
use colored::*;
use dashmap::DashMap;
use hex;
use std::io::{self, Write};
use std::sync::Arc;
use std::time::SystemTime;

pub fn print_welcome() {
    println!("\n{}", r#"
    ██╗     ██╗████████╗███████╗    ██████╗ ███████╗███████╗██████╗ 
    ██║     ██║╚══██╔══╝██╔════╝    ██╔══██╗██╔════╝██╔════╝██╔══██╗
    ██║     ██║   ██║   █████╗      ██████╔╝█████╗  █████╗  ██████╔╝
    ██║     ██║   ██║   ██╔══╝      ██╔═══╝ ██╔══╝  ██╔══╝  ██╔══██╗
    ███████╗██║   ██║   ███████╗    ██║     ███████╗███████╗██║  ██║
    ╚══════╝╚═╝   ╚═╝   ╚══════╝    ╚═╝     ╚══════╝╚══════╝╚═╝  ╚═╝
    "#.bright_blue());
    println!("{}", "                    P2P File Sharing Network".bright_cyan());
    println!("{}", "                    Version 2.1.1".bright_yellow());
    println!("\n{}", "Добро пожаловать в LITE PEER TO LITE NODE!".bright_green());
    println!("{}", "Введите 'help' для просмотра доступных команд\n".bright_white());
}

pub fn print_all_files(db: &P2PDatabase) {
    let myfiles = db.get_my_fragments();

    let uuid_peer = db.get_or_create_peer_id().unwrap();
    println!("{}", format!("[Peer] UUID: {}", uuid_peer).yellow());

    match myfiles {
        Ok(myfiles) => {
            println!("{}", "My Files:".bold().underline().blue());
            for fragment in myfiles {
                println!("  {}: {}", "Storage Peer UUID".yellow(), fragment.storage_peer_key);
                println!("  {}: {}", "Token".yellow(), fragment.token);
                println!("  {}: {}", "Filename".yellow(), fragment.filename);
                println!("  {}: {}", "UUID Fragment (key db)".yellow(), fragment.file_hash);
                println!("  {}: {}", "Size".yellow(), fragment.size);
                println!("  {}: {}", "Mime".yellow(), fragment.mime);
                println!("  {}: {}", "Public".yellow(), fragment.public);
                println!("  {}: {}", "Encrypted".yellow(), fragment.encrypted);
                println!("  {}: {}", "Compressed".yellow(), fragment.compressed);
                println!();
            }
        }
        Err(_) => (()),
    }
}

pub fn print_all_fragments(db: &P2PDatabase) {
    let fragments = db.get_storage_fragments();

    match fragments {
        Ok(fragments) => {
            println!("{}", "All fragments:".bold().underline().blue());
            for fragment in fragments {
                println!("  {}: {}", "Owner Peer UUID".yellow(), fragment.owner_key);
                println!(
                    "  {}: {}",
                    "Storage Peer UUID".yellow(),
                    fragment.storage_peer_key
                );
                println!("  {}: {}", "File Hash".yellow(), fragment.file_hash);
                println!("  {}: {}", "Mime".yellow(), fragment.mime);
                println!("  {}: {}", "Public".yellow(), fragment.public);
                println!("  {}: {}", "Encrypted".yellow(), fragment.encrypted);
                println!("  {}: {}", "Compressed".yellow(), fragment.compressed);
                println!("  {}: {}", "Token".yellow(), fragment.token);
                println!("  {}: {}", "Filename".yellow(), fragment.filename);
                println!();
            }
        }
        Err(_) => (()),
    }
}

pub async fn print_tokens_info(db: &P2PDatabase) {
    let tokens = match db.get_all_tokens() {
        Ok(tokens) => tokens,
        Err(e) => {
            println!(
                "{}",
                format!("[Peer] Ошибка при получении токенов: {}", e).red()
            );
            return;
        }
    };

    println!(
        "\n{}",
        "╔════════════════════════════════════════════════════════════╗".yellow()
    );
    println!(
        "{}",
        "║                    ИНФОРМАЦИЯ О ТОКЕНАХ                    ║".yellow()
    );
    println!(
        "{}",
        "╠════════════════════════════════════════════════════════════╣".yellow()
    );

    if tokens.is_empty() {
        println!(
            "{}",
            "║ Нет доступных токенов                                      ║".red()
        );
    } else {
        for (peer_id, token_info) in tokens {
            println!(
                "{}",
                "╠════════════════════════════════════════════════════════════╣".yellow()
            );
            println!(
                "{} {}",
                "║ Peer ID:".cyan(),
                format!("{:>40} ║", peer_id).white()
            );
            println!(
                "{} {}",
                "║ Токен:".cyan(),
                format!("{:>40} ║", token_info.token).white()
            );
            println!(
                "{} {}",
                "║ Свободное место:".cyan(),
                format!("{:>32} байт ║", token_info.free_space).white()
            );
            println!(
                "{} {}",
                "║ Занятое место:".cyan(),
                format!("{:>34} байт ║", token_info.used_space).white()
            );
            println!(
                "{} {}",
                "║ Доступно:".cyan(),
                format!("{:>38} байт ║", token_info.free_space - token_info.used_space).white()
            );

            let timestamp = token_info.timestamp;
            let datetime = SystemTime::UNIX_EPOCH + std::time::Duration::from_secs(timestamp);
            let datetime_str = format!("{:?}", datetime);
            println!(
                "{} {}",
                "║ Время создания:".cyan(),
                format!("{:>35} ║", datetime_str).white()
            );

            // Пытаемся получить метаданные токена
            if let Ok(metadata) = get_metadata_from_token(token_info.token.clone()).await {
                println!(
                    "{} {}",
                    "║ Размер файла:".cyan(),
                    format!("{:>37} байт ║", metadata.file_size).white()
                );
                println!(
                    "{} {}",
                    "║ Провайдер:".cyan(),
                    format!("{:>41} ║", metadata.storage_provider).white()
                );
                println!(
                    "{} {}",
                    "║ Подпись:".cyan(),
                    format!("{:>43} ║", hex::encode(&metadata.signature)).white()
                );
            } else {
                println!(
                    "{}",
                    "║ Не удалось получить метаданные токена                ║".red()
                );
            }
        }
    }

    println!(
        "{}",
        "╚════════════════════════════════════════════════════════════╝".yellow()
    );
    println!();
}

pub fn print_all_commands() {
    let width = 75; 
    let horizontal_line = "═".repeat(width - 2);
    let top_border = format!("╔{}╗", horizontal_line);
    let middle_border = format!("╠{}╣", horizontal_line);
    let bottom_border = format!("╚{}╝", horizontal_line);
    
    let commands = vec![
        ("files", "Список всех ваших файлов"),
        ("fragments", "Список всех ваших фрагментов"),
        ("tokens", "Показать все токены и их метаданные"),
        ("peers", "Список всех пиров"),
        ("virtual_storage", "Интерактивное управление виртуальным хранилищем"),
        ("sync_fragments", "Синхронизировать метаданные фрагментов с сервером"),
        ("search_peer <peer_id>", "Поиск конкретного пира"),
        ("connect <peer_id>", "Подключиться к пиру"),
        ("send_all <message>", "Отправить сообщение всем пирам"),
        ("<message>", "Отправить сообщение пиру"),
        ("get <session_key>", "Получить файл от пира"),
        ("upload <file_path>", "Загрузить файл на пир"),
        ("update <file_hash> <file_path>", "Обновить существующий файл"),
        ("reserve <size_in_bytes>", "Зарезервировать место на пирах"),
        ("valid_token <token>", "Проверить токен хранилища"),
        ("set_public <file_hash> <true/false>", "Изменить публичный доступ к файлу"),
        ("delete <file_hash>", "Удалить файл"),
        ("help", "Показать доступные команды"),
    ];

    println!("\n{}", top_border.bright_blue());
    println!("{}", format!("║{:^width$}║", "Доступные команды:", width = width - 2).bright_blue());
    println!("{}", middle_border.bright_blue());

    for (cmd, desc) in commands {
        println!("{}", format!("║  {:<30} - {:<25} ║", cmd.bright_green(), desc.bright_white()).bright_blue());
    }
    
    println!("{}", bottom_border.bright_blue());
    println!();
}

pub async fn console_manager(
    api: Arc<PeerAPI>,
    connections_turn: Arc<DashMap<String, ConnectionTurnStatus>>,
    db: &P2PDatabase,
) {
    let mut input = String::new();
    print!("\x1b[32m[LP2LP] >\x1b[0m ");
    io::stdout().flush().unwrap();
    std::io::stdin().read_line(&mut input).unwrap();
    let trimmed_input = input.trim();

    if trimmed_input == "help" {
        print_all_commands();
    } else if trimmed_input.starts_with("update ") {
        let args: Vec<&str> = trimmed_input.split_whitespace().collect();
        if args.len() != 3 {
            println!("{}", "[Peer] Использование: update <file_hash> <путь_к_новому_файлу>".red());
            return;
        }
        let file_hash = args[1].to_string();
        let new_file_path = args[2].to_string();

        println!("\n{}", "Настройка параметров обновления:".cyan());
        
        print!("{}", "Шифровать файл? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();
        let encrypted = input.trim().to_lowercase() == "y";

        print!("{}", "Сделать файл публичным? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        input.clear();
        std::io::stdin().read_line(&mut input).unwrap();
        let public = input.trim().to_lowercase() == "y";

        print!("{}", "Декомпрессировать файл после загрузки? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        input.clear();
        std::io::stdin().read_line(&mut input).unwrap();
        let decompress = input.trim().to_lowercase() == "y";

        println!("\n{}", "Параметры обновления:".cyan());
        println!("{}", format!("Шифрование: {}", if encrypted { "включено" } else { "выключено" }).yellow());
        println!("{}", format!("Публичный доступ: {}", if public { "да" } else { "нет" }).yellow());
        println!("{}", format!("Декомпрессия: {}", if decompress { "да" } else { "нет" }).yellow());
        println!();

        if let Err(e) = api.update_file(file_hash, new_file_path, encrypted, public, decompress).await {
            println!("{}", format!("[Peer] Ошибка при обновлении файла: {}", e).red());
        } else {
            println!("{}", "[Peer] Файл успешно обновлен".green());
        }
    } else if trimmed_input == "virtual_storage" {
        if let Err(e) = api.virtual_storage_interactive().await {
            println!("{}", format!("[Peer] Ошибка в виртуальном хранилище: {}", e).red());
        }
    } else if trimmed_input == "files" {
        print_all_files(db);
    } else if trimmed_input == "fragments" {
        print_all_fragments(db);
    } else if trimmed_input == "tokens" {
        print_tokens_info(db).await;
    } else if trimmed_input == "peers" {
        if let Err(e) = api.request_peer_list().await {
            println!("{}", format!("[Peer] Failed to request peer list: {}", e).red());
        }
    } else if trimmed_input == "sync_fragments" {
        if let Err(e) = api.sync_fragment_metadata().await {
            println!("{}", format!("[Peer] Ошибка при синхронизации фрагментов: {}", e).red());
        } else {
            println!("{}", "[Peer] Синхронизация фрагментов запущена".green());
        }
    } else if trimmed_input.starts_with("set_public ") {
        let args: Vec<&str> = trimmed_input.split_whitespace().collect();
        if args.len() != 3 {
            println!("{}", "[Peer] Использование: set_public <file_hash> <true/false>".red());
            return;
        }
        let file_hash = args[1].to_string();
        let public = match args[2].to_lowercase().as_str() {
            "true" => true,
            "false" => false,
            _ => {
                println!("{}", "[Peer] Значение public должно быть true или false".red());
                return;
            }
        };
        if let Err(e) = api.change_file_public_access(file_hash, public).await {
            println!("{}", format!("[Peer] Ошибка при изменении доступа: {}", e).red());
        }
    } else if trimmed_input.starts_with("delete ") {
        let file_hash = trimmed_input.strip_prefix("delete ").unwrap();
        if let Err(e) = api.delete_file(file_hash.to_string()).await {
            println!("{}", format!("[Peer] Ошибка при удалении файла: {}", e).red());
        }
    } else if trimmed_input.starts_with("search_peer ") {
        let peer_id = trimmed_input.strip_prefix("search_peer ").unwrap();
        if let Err(e) = api.search_peer(peer_id.to_string()).await {
            println!("{}", format!("[Peer] Failed to search peer: {}", e).red());
        }
    } else if trimmed_input.starts_with("reserve ") {
        let size_str = trimmed_input.strip_prefix("reserve ").unwrap();
        match size_str.parse::<u64>() {
            Ok(size) => {
                if let Err(e) = api.reserve_storage(size).await {
                    println!(
                        "{}",
                        format!("[Peer] Failed to reserve storage: {}", e).red()
                    );
                } else {
                    println!(
                        "{}",
                        format!("[Peer] Storage reservation request sent for {} bytes", size)
                            .green()
                    );
                }
            }
            Err(_) => println!(
                "{}",
                "[Peer] Invalid size format. Please provide a number in bytes.".red()
            ),
        }
    } else if trimmed_input.starts_with("valid_token ") {
        let token = trimmed_input.strip_prefix("valid_token ").unwrap();
        if let Err(e) = api.valid_token(token.to_string()).await {
            println!(
                "{}",
                format!("[Peer] Failed to validate token: {}", e).red()
            );
        } else {
            println!("{}", format!("[Peer] Token validated successfully").green());
        }
    } else if trimmed_input.starts_with("connect ") {
        let peer_id = trimmed_input.strip_prefix("connect ").unwrap();
        println!(
            "{}",
            format!("[Peer] Trying to connect to peer: {}", peer_id).cyan()
        );

        if let Err(e) = api.connect_to_peer(peer_id.to_string()).await {
            println!(
                "{}",
                format!("[Peer] Failed to connect to peer: {}", e).red()
            );
        } else {
            println!(
                "{}",
                "[Peer] Waiting for peer to accept connection...".yellow()
            );
        }
    } else if trimmed_input.starts_with("get ") {
        let filename = trimmed_input.strip_prefix("get ").unwrap();
        if let Err(e) = api.get_file(filename.to_string()).await {
            println!(
                "{}",
                format!("[Peer] Failed to get file {}: {}", filename, e).red()
            );
        } else {
            println!(
                "{}",
                format!("[Peer] File {} request sent successfully", filename).green()
            );
        }
    } else if trimmed_input.starts_with("upload ") {
        let file_path = trimmed_input.strip_prefix("upload ").unwrap().trim();
        if file_path.is_empty() {
            println!("{}", "[Peer] Использование: upload <путь_к_файлу>".red());
            return;
        }

        let path = std::path::Path::new(file_path);
        let is_directory = path.is_dir();

        if is_directory {
            print!("{}", "Вы указали путь к директории. Загрузить все файлы? (y/n): ".yellow());
            io::stdout().flush().unwrap();
            let mut input = String::new();
            std::io::stdin().read_line(&mut input).unwrap();
            if input.trim().to_lowercase() != "y" {
                println!("{}", "Загрузка отменена".red());
                return;
            }
        }

        println!("\n{}", "Настройка параметров загрузки:".cyan());
        
        // Запрос на шифрование
        print!("{}", "Шифровать файлы? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();
        let encrypted = input.trim().to_lowercase() == "y";

        // Запрос на публичный доступ
        print!("{}", "Сделать файлы публичными? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        input.clear();
        std::io::stdin().read_line(&mut input).unwrap();
        let public = input.trim().to_lowercase() == "y";

        // Запрос на декомпрессию
        print!("{}", "Декомпрессировать файлы после загрузки? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        input.clear();
        std::io::stdin().read_line(&mut input).unwrap();
        let decompress = input.trim().to_lowercase() == "y";

        println!("\n{}", "Параметры загрузки:".cyan());
        println!("{}", format!("Шифрование: {}", if encrypted { "включено" } else { "выключено" }).yellow());
        println!("{}", format!("Публичный доступ: {}", if public { "да" } else { "нет" }).yellow());
        println!("{}", format!("Декомпрессия: {}", if decompress { "да" } else { "нет" }).yellow());
        println!();

        if is_directory {
            if let Err(e) = api.upload_directory(file_path.to_string(), encrypted, public, decompress).await {
                println!("{}", format!("[Peer] Ошибка при загрузке директории: {}", e).red());
            }
        } else {
            if let Err(e) = api.upload_file(file_path.to_string(), encrypted, public, decompress, "").await {
                println!("{}", format!("[Peer] Ошибка при загрузке файла: {}", e).red());
            } else {
                println!("{}", "[Peer] Файл успешно загружен".green());
            }
        }
    } else if connections_turn.len() > 0 {
        let connections = connections_turn.iter();
        for entry in connections {
            if let Err(e) = api
                .send_message(entry.key().clone(), trimmed_input.to_string())
                .await
            {
                println!(
                    "{}",
                    format!("[Peer] Failed to send message to {}: {}", entry.key(), e).red()
                );
            }
        }
    } else {
        println!("{}", format!("[Peer] Команда '{}' не найдена", trimmed_input).red());
    }
}


=== ../src\ui\mod.rs ===
mod console;

pub use console::{print_all_files,console_manager, print_welcome, print_all_fragments};