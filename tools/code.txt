

=== ../src\config.rs ===
use std::fs;
use toml;
use serde::Deserialize;

#[derive(Debug, Deserialize, Clone)]
pub struct Config {
    pub signal_server_ip: String,
    pub signal_server_port: i64,
    pub storage_size: u64,
    pub proxy_ip: String,
    pub proxy_port: i64,
}

impl Config {
    pub fn from_file(file_path: &str) -> Self {
        let config_str = fs::read_to_string(file_path).expect("Failed to read config file");
        let config: toml::Value = toml::from_str(&config_str).expect("Failed to parse config file");
        Self {
            signal_server_ip: config["signal_server_ip"].as_str().unwrap().to_string(),
            signal_server_port: config["signal_server_port"].as_integer().unwrap(),
            storage_size: config["storage_size"].as_integer().unwrap() as u64,
            proxy_ip: config["proxy_ip"].as_str().unwrap().to_string(),
            proxy_port: config["proxy_port"].as_integer().unwrap(),
        }
    }
}

=== ../src\connection.rs ===
use std::sync::Arc;
use std::time::Duration;

use tokio::io::{split, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::{mpsc, oneshot, RwLock};
use tokio::task;
use tokio::time::sleep;

use crate::packets::{Protocol, TransportPacket, TransportData, PeerInfo};
use crate::db::P2PDatabase;

const SHOW_LOGS: bool = true;

fn log(message: &str) {
    if SHOW_LOGS {
        println!("{}", message);
    }
}

#[derive(Debug)]
pub enum Message {
    SendData(TransportPacket),
    GetResponse {
        tx: oneshot::Sender<TransportPacket>,
    },
}

#[derive(Clone)]
pub struct Connection {
    pub tx: mpsc::Sender<Message>,
    writer: Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
    reader: Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>,
    pub ip: String,
    pub port: i64,
    db: Arc<P2PDatabase>,
}

impl Connection {
    pub async fn new(
        signal_server_ip: String,
        signal_server_port: i64,
        db: &P2PDatabase,
    ) -> Connection {
        let (tx, rx) = mpsc::channel(16);

        let stream = TcpStream::connect(format!("{}:{}", signal_server_ip, signal_server_port))
            .await
            .unwrap();
        let (reader, writer) = split(stream);

        let reader = Arc::new(RwLock::new(reader));
        let writer = Arc::new(RwLock::new(writer));

        // Отправляем пакет при создании соединения
        let connect_packet = TransportPacket {
            act: "info".to_string(),
            to: None,
            data: Some(
                TransportData::PeerInfo(PeerInfo {
                    peer_id: db.get_or_create_peer_id().unwrap(),
                    is_signal_server: false,
                }),
            ),
            protocol: Protocol::SIGNAL,
            uuid: db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        if let Err(e) = Self::write_packet(&writer, &connect_packet).await {
            log(&format!("[Connection] Failed to send connect packet: {}", e));
        } else {
            log("[Connection] Connect packet sent successfully");
        }

        task::spawn(Self::process_messages(
            tx.clone(),
            rx,
            reader.clone(),
            writer.clone(),
            Arc::new(db.clone()),
        ));

        Connection { 
            tx, 
            writer, 
            reader,
            ip: signal_server_ip,
            port: signal_server_port,
            db: Arc::new(db.clone()),
        }
    }
    
    async fn write_packet(
        writer: &Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
        packet: &TransportPacket,
    ) -> Result<(), String> {
        let packet_str = serde_json::to_string(&packet).unwrap();
        let packet_len = packet_str.len() as u32;
        let mut writer = writer.write().await;

        // Отправляем длину сообщения (4 байта)
        let len_bytes = packet_len.to_be_bytes();
        if let Err(e) = writer.write_all(&len_bytes).await {
            return Err(format!("Failed to send packet length: {}", e));
        }

        // Отправляем само сообщение
        match writer.write_all(packet_str.as_bytes()).await {
            Ok(_) => {
                log("[Connection] Packet sent successfully");
                Ok(())
            }
            Err(e) => {
                log(&format!("[Connection] Failed to send packet: {}", e));
                Err(e.to_string())
            }
        }
    }

    async fn process_messages(
        tx: mpsc::Sender<Message>,
        mut rx: mpsc::Receiver<Message>,
        reader: Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>,
        writer: Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
        db: Arc<P2PDatabase>,
    ) {
        log("[Connection] Processing messages started");

        sleep(Duration::from_millis(100)).await;

        match Self::send_peer_info_request(&writer, &db).await {
            Ok(_) => log("[Connection] Peer info request sent successfully"),
            Err(e) => {
                log(&format!("[Connection] Failed to send peer info request: {}", e));
            }
        }

        log("[Connection] Starting message processing loop");
        while let Some(message) = rx.recv().await {
            log("[Connection] Received message from channel");
            match message {
                Message::SendData(packet) => {
                    log(&format!("[Connection] Processing SendData message: {:?}", packet));
                    if let Err(e) = Self::write_packet(&writer, &packet).await {
                        log(&format!("[Connection] Failed to send packet: {}", e));
                    } else {
                        log("[Connection] Packet sent successfully");
                    }
                }
                Message::GetResponse { tx } => {
                    log("[Connection] Processing GetResponse message");
                    let response = match Self::receive_message(&reader).await {
                        Ok(response) => response,
                        Err(e) => {
                            log(&format!("[Connection] Failed to receive message: {}", e));
                            continue;
                        }
                    };
                    if let Err(e) = tx.send(response) {
                        log(&format!("[Connection] Failed to send response to channel: {:?}", e));
                    } else {
                        log("[Connection] Response sent successfully");
                    }
                }
            }
        }
        log("[Connection] Message processing loop ended");
    }

    pub async fn send_peer_info_request(
        writer: &Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>,
        db: &P2PDatabase,
    ) -> Result<(), String> {
        let connect_packet = TransportPacket {
            act: "info".to_string(),
            to: None,
            data: Some(
                TransportData::PeerInfo(PeerInfo {
                    peer_id: db.get_or_create_peer_id().unwrap(),
                    is_signal_server: false,
                }),
            ),
            protocol: Protocol::STUN,
            uuid: db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        Self::write_packet(writer, &connect_packet).await
    }

    pub async fn receive_message(
        reader: &Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>,
    ) -> Result<TransportPacket, String> {
        let mut reader = reader.write().await;
        
        // Читаем длину сообщения (4 байта)
        let mut len_bytes = [0u8; 4];
        if let Err(e) = reader.read_exact(&mut len_bytes).await {
            if e.kind() == std::io::ErrorKind::ConnectionReset {
                log(&format!("[Connection] Connection reset by peer: {}", e));
                return Err("Connection reset by peer".to_string());
            }
            return Err(format!("Failed to read message length: {}", e));
        }
        let packet_len = u32::from_be_bytes(len_bytes) as usize;
        
        // Читаем само сообщение
        let mut packet_bytes = vec![0u8; packet_len];
        if let Err(e) = reader.read_exact(&mut packet_bytes).await {
            if e.kind() == std::io::ErrorKind::ConnectionReset {
                log(&format!("[Connection] Connection reset by peer: {}", e));
                return Err("Connection reset by peer".to_string());
            }
            return Err(format!("Failed to read message: {}", e));
        }
        
        let data = String::from_utf8_lossy(&packet_bytes);
        
        match serde_json::from_str(&data) {
            Ok(packet) => {
                Ok(packet)
            }
            Err(e) => {
                log(&format!("[Connection] Failed to parse JSON: {}", e));
                Err(format!("Failed to parse JSON: {}", e))
            }
        }
    }

    pub async fn send_packet(&self, packet: TransportPacket) -> Result<(), String> {
        Self::write_packet(&self.writer, &packet).await
    }

    pub async fn get_response(&self) -> Result<TransportPacket, String> {
        let (tx, rx) = oneshot::channel();
        self.tx.send(Message::GetResponse { tx }).await.unwrap();
        match rx.await {
            Ok(response) => Ok(response),
            Err(_) => Err("Failed to receive response from server".to_string()),
        }
    }
}


=== ../src\lib.rs ===
pub mod signal;
pub mod config;
pub mod packets;
pub mod tunnel;
pub mod db; 
pub mod ui;
pub mod connection;
pub mod manager;
pub mod peer;
pub mod crypto;
pub mod contract;
pub mod simulation;
pub mod http;
pub mod logger;
pub mod commands;

=== ../src\main.rs ===
use clap::{Arg, Command};
use commands::get_db_path;
use peer::Peer;
use std::path::PathBuf;
use crate::config::Config;

mod config;
mod connection;
mod signal;
mod tunnel;
mod db;
mod peer;
mod ui;
mod packets;
mod manager;
mod crypto;
mod contract;
mod http;
mod logger;
mod commands;

use crate::signal::SignalServer;
use crate::db::P2PDatabase;
use crate::ui::{print_all_files, print_welcome};
use crate::contract::runtime::hardcoded_test_contract;
use crate::commands::create_base_commands;

#[tokio::main]
async fn main() {
    hardcoded_test_contract();
    let matches = create_base_commands().get_matches();
    let db_path = get_db_path(&matches);

    let path = PathBuf::from(db_path);
    if !path.exists() {
        std::fs::create_dir_all(&path).unwrap();
    }

    let db = P2PDatabase::new(path.to_str().unwrap()).unwrap();
    let config: Config = Config::from_file("config.toml");

    print_welcome();
    print_all_files(&db);

    if matches.get_flag("signal") {
        let signal_server = SignalServer::new(&config, &db).await;
        signal_server.run().await;
    } else {
        let peer = Peer::new(&config, &db).await;
        peer.run().await;
    }
}

=== ../src\commands\mod.rs ===
use clap::{Arg, Command};

pub fn create_base_commands() -> Command {
    Command::new("P2P Server")
        .arg(Arg::new("signal")
            .long("signal")
            .action(clap::ArgAction::SetTrue)
            .help("Run as signal server"))
        .arg(Arg::new("db-path")
            .long("db-path")
            .action(clap::ArgAction::Set)
            .value_name("FILE")
            .help("Path to the database directory"))
}

pub fn get_db_path(matches: &clap::ArgMatches) -> String {
    matches.get_one::<String>("db-path")
        .map(|s| s.as_str())
        .unwrap_or("./storage").to_string()
}

pub fn get_path_blobs(matches: &clap::ArgMatches) -> String {
    matches.get_one::<String>("db-path")
        .map(|s| format!("{}/blobs", s))
        .unwrap_or("./storage/blobs".to_string())
}



=== ../src\contract\mod.rs ===
pub mod runtime;

=== ../src\contract\runtime.rs ===
use colored::*;
use wasmtime::*;
use std::fmt;

#[derive(Debug)]
enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}

impl fmt::Display for LogLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            LogLevel::Debug => write!(f, "{}", "DEBUG".blue().bold()),
            LogLevel::Info => write!(f, "{}", "INFO".green().bold()),
            LogLevel::Warn => write!(f, "{}", "WARN".yellow().bold()),
            LogLevel::Error => write!(f, "{}", "ERROR".red().bold()),
        }
    }
}

fn log(level: LogLevel, message: &str, context: Option<&str>) {
    let context_str = context.map_or("".to_string(), |c| format!(" [{}]", c.cyan()));
    println!("{} {}{} {}", 
        level,
        "CONTRACT".magenta().bold(),
        context_str,
        message
    );
}

fn log_debug(message: &str, context: Option<&str>) {
    log(LogLevel::Debug, message, context);
}

fn log_info(message: &str, context: Option<&str>) {
    log(LogLevel::Info, message, context);
}

fn log_warn(message: &str, context: Option<&str>) {
    log(LogLevel::Warn, message, context);
}

fn log_error(message: &str, context: Option<&str>) {
    log(LogLevel::Error, message, context);
}

pub fn execute_contract(path: &str, func_name: &str) {
    log_info(&format!("Loading contract from: {}", path.yellow()), Some("CONTRACT_LOADER"));

    let engine = Engine::default();
    let module = match Module::from_file(&engine, path) {
        Ok(m) => m,
        Err(e) => {
            log_error(&format!("Failed to load contract: {}", e), Some("CONTRACT_LOADER"));
            return;
        }
    };

    let mut store = Store::new(&engine, ());
    let instance = match Instance::new(&mut store, &module, &[]) {
        Ok(i) => i,
        Err(e) => {
            log_error(&format!("Failed to create instance: {}", e), Some("CONTRACT_LOADER"));
            return;
        }
    };

    log_info("Contract loaded successfully", Some("CONTRACT_LOADER"));

    log_info(&format!("Looking for function '{}'", func_name.cyan()), Some("FUNCTION_LOOKUP"));
    let func = match instance.get_func(&mut store, func_name) {
        Some(f) => f,
        None => {
            log_error(&format!("Function '{}' not found", func_name), Some("FUNCTION_LOOKUP"));
            return;
        }
    };

    log_info(&format!("Executing '{}'", func_name.cyan()), Some("FUNCTION_EXECUTION"));
    match func.call(&mut store, &[], &mut []) {
        Ok(_) => log_info("Contract executed successfully", Some("FUNCTION_EXECUTION")),
        Err(e) => log_error(&format!("Contract execution failed: {}", e), Some("FUNCTION_EXECUTION")),
    }
}

fn execute_increment_with_arg(contract_path: &str, peer_id: &str) {
    log_debug(&format!("Initializing contract execution for peer: {}", peer_id), Some("INCREMENT_OP"));
    
    let engine = Engine::default();
    let module = match Module::from_file(&engine, contract_path) {
        Ok(m) => m,
        Err(e) => {
            log_error(&format!("Failed to load contract: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };
    
    let mut store = Store::new(&engine, ());
    let instance = match Instance::new(&mut store, &module, &[]) {
        Ok(i) => i,
        Err(e) => {
            log_error(&format!("Failed to create instance: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };

    let memory = match instance.get_memory(&mut store, "memory") {
        Some(m) => m,
        None => {
            log_error("Memory not found", Some("INCREMENT_OP"));
            return;
        }
    };

    let init = match instance.get_func(&mut store, "init") {
        Some(f) => f,
        None => {
            log_error("Init function not found", Some("INCREMENT_OP"));
            return;
        }
    };
    
    log_debug("Initializing contract state", Some("INCREMENT_OP"));
    if let Err(e) = init.call(&mut store, &[], &mut []) {
        log_error(&format!("Failed to initialize contract: {}", e), Some("INCREMENT_OP"));
        return;
    }

    let offset = 1024;
    let peer_id_bytes = peer_id.as_bytes();
    if let Err(e) = memory.write(&mut store, offset, peer_id_bytes) {
        log_error(&format!("Failed to write peer_id to memory: {}", e), Some("INCREMENT_OP"));
        return;
    }

    let increment = match instance.get_typed_func::<(i32, i32), i64>(&mut store, "increment") {
        Ok(f) => f,
        Err(e) => {
            log_error(&format!("Failed to get increment function: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };

    log_debug(&format!("Executing increment for peer_id: {}", peer_id), Some("INCREMENT_OP"));
    let result = match increment.call(&mut store, (offset as i32, peer_id_bytes.len() as i32)) {
        Ok(r) => r,
        Err(e) => {
            log_error(&format!("Failed to execute increment: {}", e), Some("INCREMENT_OP"));
            return;
        }
    };

    log_info(&format!("Counter for peer_id `{}` now equals {}", peer_id, result), Some("INCREMENT_OP"));
}

pub fn hardcoded_test_contract() {
    log_info("Starting WASM smart-contract test suite", Some("TEST_SUITE"));
    log_info("=================================", Some("TEST_SUITE"));

    let path = "contracts/counter/target/wasm32-unknown-unknown/release/counter.wasm";
    execute_increment_with_arg(path, "peer_id");
}


=== ../src\crypto\crypto.rs ===
use chacha20poly1305::aead::Aead;
use chacha20poly1305::{ChaCha20Poly1305, Key, KeyInit, Nonce};
use k256::elliptic_curve::ecdh::diffie_hellman;
use k256::elliptic_curve::ecdh::EphemeralSecret;
use k256::elliptic_curve::sec1::FromEncodedPoint;
use k256::EncodedPoint;
use k256::{ecdh::SharedSecret, PublicKey, SecretKey};
use rand_core::{OsRng, RngCore};
use sha2::{Digest, Sha256};


pub fn get_shared_secret(private: &SecretKey, peer_pub_bytes: &[u8]) -> [u8; 32] {
    let secret_scalar = private.to_nonzero_scalar();
    let pub_point = EncodedPoint::from_bytes(peer_pub_bytes).expect("invalid public key bytes");
    let peer_pub = PublicKey::from_encoded_point(&pub_point).expect("invalid public key");

    let shared = diffie_hellman(secret_scalar, peer_pub.as_affine());

    let hash = Sha256::digest(shared.raw_secret_bytes());
    hash.into()
}

pub fn encrypt(plaintext: &[u8], key_bytes: [u8; 32]) -> (Vec<u8>, [u8; 12]) {
    let key = Key::from_slice(&key_bytes);
    let cipher = ChaCha20Poly1305::new(key);

    let mut nonce_bytes = [0u8; 12];
    OsRng.fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::from_slice(&nonce_bytes);

    let ciphertext = cipher
        .encrypt(nonce, plaintext)
        .expect("encryption failure!");
    (ciphertext, nonce_bytes)
}

pub fn decrypt(ciphertext: &[u8], key_bytes: [u8; 32], nonce_bytes: [u8; 12]) -> Vec<u8> {
    let key = Key::from_slice(&key_bytes);
    let cipher = ChaCha20Poly1305::new(key);
    let nonce = Nonce::from_slice(&nonce_bytes);

    cipher
        .decrypt(nonce, ciphertext)
        .expect("decryption failure!")
}


=== ../src\crypto\mod.rs ===
pub mod token;
pub mod crypto;

use self::token::get_metadata_from_token;
// use crate::crypto::crypto;



=== ../src\crypto\token.rs ===
use crate::packets::StorageToken;
use base64;
use hex;
use k256;
use serde_json;
use k256::elliptic_curve::sec1::ToEncodedPoint;
use k256::ecdsa::signature::Verifier;

pub async fn get_metadata_from_token(token: String) -> Result<StorageToken, String> {
    let token_bytes = base64::decode(&token).map_err(|e| e.to_string())?;
    let token_str = String::from_utf8(token_bytes).map_err(|e| e.to_string())?;
    let token: StorageToken = serde_json::from_str(&token_str).map_err(|e| e.to_string())?;
    Ok(token)
}

pub async fn validate_signature_token(token: String, db: &crate::db::P2PDatabase) -> Result<StorageToken, String> {
    let token_bytes = base64::decode(&token).map_err(|e| e.to_string())?;
    let token_str = String::from_utf8(token_bytes).map_err(|e| e.to_string())?;
    let mut token: StorageToken = serde_json::from_str(&token_str).map_err(|e| e.to_string())?;
    
    let signature = token.signature.clone();
    token.signature = Vec::new();
    
    let token_bytes = serde_json::to_vec(&token).map_err(|e| e.to_string())?;
    
    let pub_key_bytes = hex::decode(&token.storage_provider)
        .map_err(|e| format!("Invalid public key hex: {}", e))?;
    let verifying_key = k256::ecdsa::VerifyingKey::from_sec1_bytes(&pub_key_bytes)
        .map_err(|e| format!("Invalid public key: {}", e))?;
    
    let signature = k256::ecdsa::Signature::from_slice(&signature)
        .map_err(|e| format!("Invalid signature format: {}", e))?;
    
    verifying_key
        .verify(&token_bytes, &signature)
        .map_err(|e| format!("Signature verification failed: {}", e))?;

    token.signature = signature.to_bytes().to_vec();
    Ok(token)
}




=== ../src\db\db.rs ===
use async_std::path::PathBuf;
use redb::{Database, Error};
use std::sync::{Arc, Mutex};

use super::tables;

#[derive(Clone, Debug)]
pub struct P2PDatabase {
    pub db: Arc<Mutex<Database>>,
    pub path: String,
}

impl P2PDatabase {
    pub fn new(path: &str) -> Result<Self, Error> {
        let db_file = PathBuf::from(path).join("db");

        let db = Database::create(db_file)?;
        {
            let write_txn = db.begin_write()?;
            {
                write_txn.open_table(tables::STORAGE_TABLE)?;
                write_txn.open_table(tables::PEER_INFO_TABLE)?;
                write_txn.open_table(tables::SECRET_KEYS_TABLE)?;
                write_txn.open_table(tables::DHT_TABLE)?;
                write_txn.open_table(tables::TOKENS_TABLE)?;
                write_txn.open_table(tables::VALIDATOR_STORAGE_TABLE)?;
            }
            write_txn.commit()?;
        }

        Ok(Self {
            db: Arc::new(Mutex::new(db)),
            path: path.to_string(),
        })
    }
}


=== ../src\db\dht.rs ===
use crate::db::{models::DHTEntry, tables::DHT_TABLE};
use redb::{Error, ReadableTable};
use std::time::{SystemTime, UNIX_EPOCH};

use super::P2PDatabase;

impl P2PDatabase {
    pub fn add_dht_entry(&self, peer_id: &str, session_key: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        let entry = DHTEntry {
            peer_id: peer_id.to_string(),
            session_key: session_key.to_string(),
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        {
            let mut table = tx.open_table(DHT_TABLE)?;
            let key = format!("{}:{}", peer_id, session_key);
            let data = serde_json::to_string(&entry).unwrap();
            table.insert(key.as_str(), data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_peers_by_session_key(&self, session_key: &str) -> Result<Vec<String>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(DHT_TABLE)?;

        let mut peers = Vec::new();
        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let entry: DHTEntry = serde_json::from_str(&data).unwrap();
            if entry.session_key == session_key {
                peers.push(entry.peer_id);
            }
        }

        Ok(peers)
    }

    pub fn get_files_by_peer(&self, peer_id: &str) -> Result<Vec<String>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(DHT_TABLE)?;

        let mut files = Vec::new();
        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let entry: DHTEntry = serde_json::from_str(&data).unwrap();
            if entry.peer_id == peer_id {
                files.push(entry.session_key);
            }
        }

        Ok(files)
    }

    pub fn remove_dht_entry(&self, peer_id: &str, session_key: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;
        
        {
            let mut table = tx.open_table(DHT_TABLE)?;
            let key = format!("{}:{}", peer_id, session_key);
            table.remove(key.as_str())?;
        }

        tx.commit()?;
        Ok(())
    }
} 

=== ../src\db\mod.rs ===
mod db;
mod models;
pub mod tables;
mod peer;
mod storage;
mod dht;
mod tokens;
pub use db::P2PDatabase;
pub use models::{Fragment, Storage};

=== ../src\db\models.rs ===
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Fragment {
    pub uuid_peer: String,
    pub token: String,
    pub filename: String,
    pub hash_file: String,
    pub encrypted: bool,
    pub compressed: bool,
    pub public: bool,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Storage {
    pub file_hash: String, // sha256
    pub filename: String,
    pub mime: String, // mime type for http proxy
    pub public: bool, // true if file is public (not encrypted)
    pub encrypted: bool, // true if file is encrypted
    pub compressed: bool, // true if file is compressed
    pub auto_decompress: bool, // true if file should be automatically decompressed
    pub owner_key: String, // owner public key
    pub storage_peer_key: String, // provider peer key
    pub uploaded_via_token: Option<String>, // base64 token
    pub token: String, // base64 token
    pub token_hash: Option<String>, // hash of the token
    pub size: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DHTEntry {
    pub peer_id: String,
    pub session_key: String,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct TokenInfo {
    pub token: String,
    pub free_space: u64,
    pub used_space: u64,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ValidatorStorageInfo {
    pub peer_id: String,
    pub free_space: u64,
    pub total_space: u64,
    pub last_update: u64,
    pub is_online: bool,
} 

=== ../src\db\peer.rs ===
use crate::db::tables::PEER_INFO_TABLE;
use flate2::bufread::GzEncoder;
use k256::elliptic_curve::group::UncompressedEncoding;
use redb::Error;
use anyhow::Result;
use std::io::Read;

use hex::{decode as hex_decode, encode as hex_encode};
use k256::{
    elliptic_curve::rand_core::OsRng,
    SecretKey,
    PublicKey,
};
use k256::ecdsa::{SigningKey, VerifyingKey};
use k256::elliptic_curve::sec1::{ToEncodedPoint, FromEncodedPoint};

use super::P2PDatabase;
use crate::crypto::crypto::{get_shared_secret, encrypt, decrypt};

impl P2PDatabase {
    pub fn get_or_create_peer_id(&self) -> Result<String, Error> {
        let db = self.db.lock().unwrap();
        let read_txn = db.begin_read()?;
        let table = read_txn.open_table(PEER_INFO_TABLE)?;

        if let Some(data) = table.get("private_key")? {
            let priv_key_hex = String::from_utf8(data.value().to_vec()).unwrap();
            let priv_key_bytes = hex_decode(&priv_key_hex).unwrap();

            let secret = SecretKey::from_bytes(priv_key_bytes.as_slice().try_into().unwrap()).unwrap();
            let signing_key = SigningKey::from(secret);
            let verifying_key = signing_key.verifying_key();
            let pub_key = verifying_key.to_encoded_point(true);
            let pub_key_hex = hex_encode(pub_key.as_bytes());
            return Ok(pub_key_hex);
        } else {
            drop(read_txn);

            let signing_key = SigningKey::random(&mut OsRng);
            let priv_key_bytes = signing_key.to_bytes();
            let priv_key_hex = hex_encode(priv_key_bytes);

            let verifying_key = signing_key.verifying_key();
            let pub_key = verifying_key.to_encoded_point(true);
            let pub_key_hex = hex_encode(pub_key.as_bytes());

            let write_txn = db.begin_write()?;
            {
                let mut table = write_txn.open_table(PEER_INFO_TABLE)?;
                table.insert("private_key", priv_key_hex.as_bytes())?;
            }
            write_txn.commit()?;

            Ok(pub_key_hex)
        }
    }

    pub fn get_private_key(&self) -> Result<SecretKey, Error> {
        let db = self.db.lock().unwrap();
        let read_txn = db.begin_read()?;
        let table = read_txn.open_table(PEER_INFO_TABLE)?;

        let data = table.get("private_key")?.ok_or_else(|| Error::Corrupted("Private key not found".to_string()))?;
        let priv_key_hex = String::from_utf8(data.value().to_vec()).unwrap();
        let priv_key_bytes = hex_decode(&priv_key_hex).unwrap();
        Ok(SecretKey::from_bytes(priv_key_bytes.as_slice().try_into().unwrap()).unwrap())
    }

    pub fn get_private_signing_key(&self) -> Result<SigningKey, Error> {
        let db = self.db.lock().unwrap();
        let read_txn = db.begin_read()?;
        let table = read_txn.open_table(PEER_INFO_TABLE)?;

        let data = table.get("private_key")?.ok_or_else(|| Error::Corrupted("Private key not found".to_string()))?;
        let priv_key_hex = String::from_utf8(data.value().to_vec()).unwrap();
        let priv_key_bytes = hex_decode(&priv_key_hex).unwrap();
        Ok(SigningKey::from_bytes(priv_key_bytes.as_slice().try_into().unwrap()).unwrap())
    }

    pub fn encrypt_data(&self, data: &[u8]) -> Result<(Vec<u8>, [u8; 12])> {
        let private_key = self.get_private_key()?;
        let signing_key = SigningKey::from(&private_key);
        let verifying_key = signing_key.verifying_key();
        let pub_key = verifying_key.to_encoded_point(true);
        let pub_key_bytes: [u8; 32] = pub_key.as_bytes()[1..33].try_into().unwrap();
        Ok(encrypt(data, pub_key_bytes))
    }

    pub fn decrypt_data(&self, data: &[u8], nonce: &[u8; 12]) -> Result<Vec<u8>> {
        let private_key = self.get_private_key()?;
        let signing_key = SigningKey::from(&private_key);
        let verifying_key = signing_key.verifying_key();
        let pub_key = verifying_key.to_encoded_point(true);
        let pub_key_bytes: [u8; 32] = pub_key.as_bytes()[1..33].try_into().unwrap();
        Ok(decrypt(data, pub_key_bytes, *nonce))
    }

    pub fn encrypt_message(&self, message: &[u8], peer_public_key: &str) -> Result<(Vec<u8>, [u8; 12])> {
        let private_key = self.get_private_key()?;
        let peer_pub_key_bytes = hex_decode(peer_public_key)?;
        
        let pub_point = k256::EncodedPoint::from_bytes(&peer_pub_key_bytes)
            .map_err(|_| anyhow::anyhow!("Invalid public key bytes"))?;
        let peer_pub_key = PublicKey::from_encoded_point(&pub_point)
            .unwrap();
        
        let signing_key = SigningKey::from(&private_key);
        let shared_secret = get_shared_secret(&private_key, &peer_pub_key_bytes);
        Ok(encrypt(message, shared_secret))
    }

    pub fn decrypt_message(&self, ciphertext: &[u8], nonce: [u8; 12], peer_public_key: &str) -> Result<Vec<u8>> {
        let private_key = self.get_private_key()?;
        let peer_pub_key_bytes = hex_decode(peer_public_key)?;
        let peer_pub_key = PublicKey::from_sec1_bytes(&peer_pub_key_bytes)?;
        let encoded_point = peer_pub_key.to_encoded_point(false);
        let peer_pub_key_bytes = encoded_point.as_bytes();
        
        let signing_key = SigningKey::from(&private_key);
        let shared_secret = get_shared_secret(&private_key, peer_pub_key_bytes);
        Ok(decrypt(ciphertext, shared_secret, nonce))
    }

    pub fn uncompress_data(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut decoder = flate2::read::GzDecoder::new(data);
        let mut decompressed_data = Vec::new();
        decoder.read_to_end(&mut decompressed_data)
            .map_err(|e| anyhow::anyhow!("Failed to decompress data: {}", e))?;
        Ok(decompressed_data)
    }
}


=== ../src\db\storage.rs ===
use std::time::{SystemTime, UNIX_EPOCH};

use crate::{
    config::Config,
    db::{models::Storage, tables::STORAGE_TABLE},
};
use async_std::stream::StreamExt;
use redb::{Error, ReadableTable};

use super::{models::TokenInfo, tables::TOKENS_TABLE, P2PDatabase};

#[derive(Debug)]
pub enum StorageError {
    Redb(redb::Error),
    Io(std::io::Error),
}

impl From<redb::Error> for StorageError {
    fn from(err: redb::Error) -> Self {
        StorageError::Redb(err)
    }
}

impl From<std::io::Error> for StorageError {
    fn from(err: std::io::Error) -> Self {
        StorageError::Io(err)
    }
}

impl P2PDatabase {
    pub fn add_storage_fragment(&self, fragment: Storage) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;
        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let data = serde_json::to_string(&fragment).unwrap();
            table.insert(fragment.file_hash.as_str(), data.as_bytes())?;
        }
        tx.commit()?;
        Ok(())
    }

    pub fn get_storage_fragments(&self) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;

        let mut result = Vec::new();
        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            result.push(fragment);
        }

        Ok(result)
    }

    pub fn get_storage_fragments_by_hash(&self, hash: &str) -> Result<Option<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;

        if let Some(value) = table.get(hash)? {
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            Ok(Some(fragment))
        } else {
            Ok(None)
        }
    }

    pub fn get_storage_fragments_by_token(&self, token: &str) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        if let Some(value) = table.get(token)? {
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if fragment.token == token {
                fragments.push(fragment);
            }
        }

        Ok(fragments)
    }

    pub fn get_by_owner_key_fragments(&self, owner_key: &str) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if fragment.owner_key == owner_key {
                fragments.push(fragment);
            }
        }

        Ok(fragments)
    }

    pub fn search_fragment_in_virtual_storage(
        &self,
        identifier: &str,
        public: Option<bool>,
    ) -> Result<Vec<Storage>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(STORAGE_TABLE)?;
        let mut fragments = Vec::new();

        for item in table.iter()? {
            let (_, value) = item?;
            let data = String::from_utf8(value.value().to_vec()).unwrap();
            let fragment: Storage = serde_json::from_str(&data).unwrap();
            if (fragment.owner_key == identifier
                || fragment.file_hash == identifier
                || fragment.filename == identifier)
            {
                if public.is_none() {
                    fragments.push(fragment);
                } else if public.is_some() == fragment.public {
                    fragments.push(fragment);
                }
            }
        }

        Ok(fragments)
    }

    pub fn get_my_fragments(&self) -> Result<Vec<Storage>, Error> {
        let my_peer_id = self.get_or_create_peer_id().unwrap();
        let fragments = self.get_by_owner_key_fragments(&my_peer_id)?;
        Ok(fragments)
    }

    pub async fn get_storage_size(&self) -> Result<u64, StorageError> {
        let path = format!("{}/blobs", self.path);

        if !std::path::Path::new(&path).exists() {
            std::fs::create_dir_all(&path).unwrap();
            return Ok(0);
        }

        let mut total_size = 0u64;

        let mut entries = async_std::fs::read_dir(&path).await?;
        while let Some(entry) = entries.next().await {
            let entry = entry?;
            let metadata = entry.metadata().await?;
            if metadata.is_file() {
                total_size += metadata.len();
            }
        }

        Ok(total_size)
    }

    pub async fn get_storage_free_space(&self) -> Result<u64, StorageError> {
        let config = Config::from_file("config.toml");
        let free_space = config.storage_size - self.get_storage_size().await?;
        Ok(free_space)
    }

    pub fn update_fragment_public_access(
        &self,
        file_hash: &str,
        public: bool,
    ) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let fragment_data = if let Some(data) = table.get(file_hash)? {
                let data = String::from_utf8(data.value().to_vec()).unwrap();
                let mut fragment: Storage = serde_json::from_str(&data).unwrap();
                fragment.public = public;
                serde_json::to_string(&fragment).unwrap()
            } else {
                return Err(Error::Corrupted("Фрагмент не найден".into()));
            };
            table.insert(file_hash, fragment_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn remove_fragment(&self, file_hash: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            table.remove(file_hash)?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn update_fragment_path(&self, file_hash: &str, new_path: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(STORAGE_TABLE)?;
            let data = table.get(file_hash)?;
            let json_str = String::from_utf8(
                data.ok_or_else(|| Error::Corrupted("Файл не найден".to_string()))?
                    .value()
                    .to_vec(),
            )
            .unwrap();
            let mut fragment: Storage = serde_json::from_str(&json_str).unwrap();
            fragment.filename = new_path.to_string();
            let updated_data = serde_json::to_string(&fragment).unwrap();
            table.insert(file_hash, updated_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn update_token_used_space(&self, peer_id: &str, used_space: u64) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        {
            let mut table = tx.open_table(TOKENS_TABLE)?;
            let data = table.get(peer_id)?;
            let json_str = String::from_utf8(
                data.ok_or_else(|| Error::Corrupted("Токен не найден".to_string()))?
                    .value()
                    .to_vec(),
            )
            .unwrap();
            let mut token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            token_info.used_space = used_space;
            let updated_data = serde_json::to_string(&token_info).unwrap();
            table.insert(peer_id, updated_data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_token_used_space(&self, peer_id: &str) -> Result<u64, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        if let Some(data) = table.get(peer_id)? {
            let json_str = String::from_utf8(data.value().to_vec()).unwrap();
            let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            Ok(token_info.used_space)
        } else {
            Ok(0)
        }
    }
}


=== ../src\db\tables.rs ===
use redb::TableDefinition;

pub const DHT_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("dht");
pub const STORAGE_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("storage");
pub const PEER_INFO_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("peer_info");
pub const SECRET_KEYS_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("secret_keys");
pub const TOKENS_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("tokens");
pub const VALIDATOR_STORAGE_TABLE: TableDefinition<&str, &[u8]> = TableDefinition::new("validator_storage"); 

=== ../src\db\tokens.rs ===
use crate::db::{models::{TokenInfo, ValidatorStorageInfo}, tables::{TOKENS_TABLE, VALIDATOR_STORAGE_TABLE}};
use redb::{Error, ReadableTable, ReadableTableMetadata};
use std::time::{SystemTime, UNIX_EPOCH};

use super::P2PDatabase;

impl P2PDatabase {
    pub fn add_token(&self, peer_id: &str, token: &str, free_space: u64) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        let token_info = TokenInfo {
            token: token.to_string(),
            free_space,
            used_space: 0,
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        {
            let mut table = tx.open_table(TOKENS_TABLE)?;
            let data = serde_json::to_string(&token_info).unwrap();
            table.insert(peer_id, data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_token(&self, peer_id: &str) -> Result<Option<TokenInfo>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        match table.get(peer_id)? {
            Some(data) => {
                let json_str = String::from_utf8(data.value().to_vec()).unwrap();
                let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
                Ok(Some(token_info))
            }
            None => Ok(None),
        }
    }

    pub fn get_all_tokens(&self) -> Result<Vec<(String, TokenInfo)>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        let mut tokens = Vec::new();
        for item in table.iter()? {
            let (key, value) = item?;
            let json_str = String::from_utf8(value.value().to_vec()).unwrap();
            let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            tokens.push((key.value().to_string(), token_info));
        }

        Ok(tokens)
    }

    pub fn get_best_token(&self, file_size: u64) -> Result<Option<(String, TokenInfo)>, Error> {
        let my_peer_id = self.get_or_create_peer_id().unwrap();
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(TOKENS_TABLE)?;

        if table.is_empty()? {
            return Ok(None);
        }

        let mut best_token = None;
        let mut best_free_space = 0;
        
        println!("[DEBUG] Starting iteration over tokens");
        for item in table.iter()? {
            let (key, value) = item?;
            println!("[DEBUG] Processing token for peer: {}", key.value());
            let json_str = String::from_utf8(value.value().to_vec()).unwrap();
            let token_info: TokenInfo = serde_json::from_str(&json_str).unwrap();
            if token_info.free_space >= file_size {
                if token_info.free_space > best_free_space && my_peer_id == key.value().to_string() {
                    best_free_space = token_info.free_space;
                    best_token = Some((key.value().to_string(), token_info));
                    println!("[DEBUG] Found better token with free space: {}", best_free_space);
                }
            }
        }
        println!("[DEBUG] Finished processing tokens");

        Ok(best_token)
    }

    pub fn remove_token(&self, peer_id: &str) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;
        
        {
            let mut table = tx.open_table(TOKENS_TABLE)?;
            table.remove(peer_id)?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn update_token_free_space(&self, peer_id: &str, free_space: u64) -> Result<(), Error> {
        if let Some(mut token_info) = self.get_token(peer_id)? {
            token_info.free_space = free_space;
            token_info.timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();

            let db = self.db.lock().unwrap();
            let tx = db.begin_write()?;
            
            {
                let mut table = tx.open_table(TOKENS_TABLE)?;
                let data = serde_json::to_string(&token_info).unwrap();
                table.insert(peer_id, data.as_bytes())?;
            }

            tx.commit()?;
        }
        Ok(())
    }

    pub fn update_validator_storage(&self, peer_id: &str, free_space: u64, total_space: u64) -> Result<(), Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_write()?;

        let storage_info = ValidatorStorageInfo {
            peer_id: peer_id.to_string(),
            free_space,
            total_space,
            last_update: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            is_online: true,
        };

        {
            let mut table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;
            let data = serde_json::to_string(&storage_info).unwrap();
            table.insert(peer_id, data.as_bytes())?;
        }

        tx.commit()?;
        Ok(())
    }

    pub fn get_validator_storage(&self, peer_id: &str) -> Result<Option<ValidatorStorageInfo>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;

        match table.get(peer_id)? {
            Some(data) => {
                let json_str = String::from_utf8(data.value().to_vec()).unwrap();
                let storage_info: ValidatorStorageInfo = serde_json::from_str(&json_str).unwrap();
                Ok(Some(storage_info))
            }
            None => Ok(None),
        }
    }

    pub fn get_all_validator_storage(&self) -> Result<Vec<ValidatorStorageInfo>, Error> {
        let db = self.db.lock().unwrap();
        let tx = db.begin_read()?;
        let table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;

        let mut storage_info = Vec::new();
        for item in table.iter()? {
            let (_, value) = item?;
            let json_str = String::from_utf8(value.value().to_vec()).unwrap();
            let info: ValidatorStorageInfo = serde_json::from_str(&json_str).unwrap();
            storage_info.push(info);
        }

        Ok(storage_info)
    }

    pub fn mark_peer_offline(&self, peer_id: &str) -> Result<(), Error> {
        if let Some(mut storage_info) = self.get_validator_storage(peer_id)? {
            storage_info.is_online = false;
            storage_info.last_update = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();

            let db = self.db.lock().unwrap();
            let tx = db.begin_write()?;
            
            {
                let mut table = tx.open_table(VALIDATOR_STORAGE_TABLE)?;
                let data = serde_json::to_string(&storage_info).unwrap();
                table.insert(peer_id, data.as_bytes())?;
            }

            tx.commit()?;
        }
        Ok(())
    }
} 

=== ../src\http\http_proxy.rs ===
use bytes::Bytes;
use colored::Colorize;
use http_body_util::{combinators::BoxBody, BodyExt, Full};
use hyper::server::conn::http1;
use hyper::service::service_fn;
use hyper::{body::Incoming, Request, Response};
use hyper_util::rt::tokio::TokioIo;
use uuid::Uuid;
use std::{collections::HashMap, convert::Infallible, net::SocketAddr, sync::Arc};
use tokio::net::TcpListener;
use tokio::sync::{oneshot, Mutex, RwLock};
use tokio::sync::mpsc;
use crate::db::P2PDatabase;
use crate::packets::{Protocol, ProxyMessage, TransportData, TransportPacket};

#[derive(Clone, Debug)]
pub struct HttpProxy {
    db: Arc<P2PDatabase>,
    proxy_tx: mpsc::Sender<TransportPacket>,
    client_to_peer_mapping: Arc<RwLock<HashMap<String, String>>>,
    pending_responses: Arc<Mutex<HashMap<String, oneshot::Sender<Vec<u8>>>>>,
}

impl HttpProxy {
    pub fn new(db: Arc<P2PDatabase>, proxy_tx: mpsc::Sender<TransportPacket>) -> Self {
        Self {
            db,
            proxy_tx,
            client_to_peer_mapping: Arc::new(RwLock::new(HashMap::new())),
            pending_responses: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn set_peer_for_client(&self, client_ip: String, peer_id: String) {
        self.client_to_peer_mapping
            .write()
            .await
            .insert(client_ip, peer_id);
    }

    pub async fn get_peer_for_client(&self, client_ip: &str) -> Option<String> {
        self.client_to_peer_mapping
            .read()
            .await
            .get(client_ip)
            .cloned()
    }

    pub async fn set_response(&self, request_id: String, response: Vec<u8>) {
        println!("[HTTP Proxy] Set response for request: {}", request_id);
        if let Some(sender) = self.pending_responses.lock().await.remove(&request_id) {
            let _ = sender.send(response);
        }
    }

    pub async fn start(self: Arc<Self>) {
        let mut port = 8080;
        let mut listener = None;
        
        while listener.is_none() {
            let addr = SocketAddr::from(([0, 0, 0, 0], port));
            match TcpListener::bind(addr).await {
                Ok(l) => {
                    listener = Some(l);
                    println!(
                        "{}",
                        format!("[HTTP Proxy] Listening on http://{}", addr).green()
                    );
                }
                Err(_) => {
                    println!("[HTTP Proxy] Port {} is busy, trying {}", port, port + 1);
                    port += 1;
                }
            }
        }

        let listener = listener.unwrap();

        loop {
            let (stream, socket) = listener.accept().await.unwrap();
            let peer_ip = format!(
                "{}:{}",
                stream.peer_addr().unwrap().ip().to_string(),
                stream.peer_addr().unwrap().port()
            );
            println!("[HTTP Proxy] Peer IP: {}", peer_ip);
            let proxy = self.clone();

            tokio::spawn(async move {
                let service = service_fn(move |req: Request<Incoming>| {
                    let proxy = proxy.clone();
                    let peer_ip = peer_ip.clone();
                    println!("[HTTP Proxy] [thread] Peer IP: {}", peer_ip);
                    async move { proxy.handle(req, peer_ip).await }
                });

                if let Err(err) = http1::Builder::new()
                    .serve_connection(TokioIo::new(stream), service)
                    .await
                {
                    eprintln!("[HTTP Proxy] Connection error: {:?}", err);
                }
            });
        }
    }

    fn extract_peer_id(req: &Request<Incoming>) -> Option<String> {
        println!("[HTTP Proxy] [DEBUG] Starting peer ID extraction");
        
        if let Some(host) = req.headers().get("host") {
            if let Ok(host_str) = host.to_str() {
                println!("[HTTP Proxy] [DEBUG] Checking host header: {}", host_str);
                if host_str.chars().all(|c| c.is_ascii_hexdigit()) {
                    println!("[HTTP Proxy] [DEBUG] Found valid peer ID in host: {}", host_str);
                    return Some(host_str.to_string());
                }
            }
        }

        if let Some(referer) = req.headers().get("referer") {
            if let Ok(referer_str) = referer.to_str() {
                println!("[HTTP Proxy] [DEBUG] Checking referer header: {}", referer_str);
                for segment in referer_str.split('/') {
                    if !segment.is_empty() && segment.chars().all(|c| c.is_ascii_hexdigit()) {
                        println!("[HTTP Proxy] [DEBUG] Found valid peer ID in referer: {}", segment);
                        return Some(segment.to_string());
                    }
                }
            }
        }

        let path = req.uri().path();
        println!("[HTTP Proxy] [DEBUG] Checking URI path: {}", path);

        for segment in path.split('/') {
            if !segment.is_empty() && segment.chars().all(|c| c.is_ascii_hexdigit()) {
                println!("[HTTP Proxy] [DEBUG] Found valid peer ID in URI path: {}", segment);
                return Some(segment.to_string());
            }
        }

        if let Some(query) = req.uri().query() {
            println!("[HTTP Proxy] [DEBUG] Checking query parameters: {}", query);
            for param in query.split('&') {
                let parts: Vec<&str> = param.split('=').collect();
                if parts.len() == 2 {
                    let value = parts[1];
                    if value.chars().all(|c| c.is_ascii_hexdigit()) {
                        println!("[HTTP Proxy] [DEBUG] Found valid peer ID in query: {}", value);
                        return Some(value.to_string());
                    }
                }
            }
        }

        println!("[HTTP Proxy] [DEBUG] No valid peer ID found in request");
        None
    }

    async fn get_peer_id_from_request(
        &self,
        req: &Request<Incoming>,
        client_ip: &str,
    ) -> String {
        println!("[HTTP Proxy] [DEBUG] Starting peer ID extraction for client IP: {}", client_ip);
        let mut peer_id = None;

        if peer_id.is_none() {
            if let Some(extracted) = Self::extract_peer_id(req) {
                println!("[HTTP Proxy] [DEBUG] Successfully extracted peer ID from request: {}", extracted);
                peer_id = Some(extracted);
            } else {
                println!("[HTTP Proxy] [DEBUG] No peer ID found in request, checking client mapping");
                peer_id = self.get_peer_for_client(client_ip).await;
                if let Some(id) = &peer_id {
                    println!("[HTTP Proxy] [DEBUG] Found peer ID in client mapping: {}", id);
                }
            }
        }

        if peer_id.is_none() {
            println!("[HTTP Proxy] [DEBUG] Checking cookies for peer ID");
            if let Some(cookie_header) = req.headers().get("cookie") {
                if let Ok(cookie_str) = cookie_header.to_str() {
                    println!("[HTTP Proxy] [DEBUG] Cookie header: {}", cookie_str);
                    for cookie in cookie_str.split(';') {
                        let parts: Vec<&str> = cookie.trim().split('=').collect();
                        if parts.len() == 2 && parts[0] == "peer_id" {
                            let value = parts[1];
                            if value.chars().all(|c| c.is_ascii_hexdigit()) {
                                println!("[HTTP Proxy] [DEBUG] Found valid peer ID in cookie: {}", value);
                                peer_id = Some(value.to_string());
                                break;
                            }
                        }
                    }
                }
            }    
        }

        let peer_id = peer_id.unwrap_or_else(|| {
            println!("[HTTP Proxy] [DEBUG] No peer ID found, using empty string");
            "".to_string()
        });
        
        if !peer_id.is_empty() {
            println!("[HTTP Proxy] [DEBUG] Setting peer ID {} for client {}", peer_id, client_ip);
            self.set_peer_for_client(client_ip.to_string(), peer_id.clone()).await;
        }

        peer_id
    }

    async fn handle(
        &self,
        req: Request<Incoming>,
        client_ip: String,
    ) -> Result<Response<BoxBody<Bytes, Infallible>>, hyper::Error> {
        println!("[HTTP Proxy] Request Method: {}", req.method());
        println!("[HTTP Proxy] Request URI: {}", req.uri());
        println!("[HTTP Proxy] Request Headers:");
        for (name, value) in req.headers() {
            println!("  {}: {}", name, value.to_str().unwrap_or("(invalid)"));
        }

        let peer_id = self.get_peer_id_from_request(&req, &client_ip).await;
        println!("[HTTP Proxy] Peer ID: {}", peer_id);

        let mut request_str = String::new();
        request_str.push_str(&format!("{} {} HTTP/1.1\r\n", req.method(), req.uri()));

        for (name, value) in req.headers() {
            request_str.push_str(&format!(
                "{}: {}\r\n",
                name,
                value.to_str().unwrap_or("(invalid)")
            ));
        }

        request_str.push_str("\r\n");

        let whole_body = req.collect().await?.to_bytes();
        if !whole_body.is_empty() {
            request_str.push_str(&String::from_utf8_lossy(&whole_body));
        }

        let request_id = Uuid::new_v4().to_string();
        
        let (tx, rx) = oneshot::channel();
        self.pending_responses
            .lock()
            .await
            .insert(request_id.clone(), tx);
        
        let encrypted = match self
            .db
            .encrypt_message(request_str.as_bytes(), &peer_id)
        {
            Ok(e) => e,
            Err(_) => {
                return Ok(Response::builder()
                    .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                    .body(full("Encryption failed"))
                    .unwrap());
            }
        };

        let packet = TransportPacket {
            act: "http_proxy_request".to_string(),
            to: Some(peer_id.clone()),
            data: Some(TransportData::ProxyMessage(ProxyMessage {
                text: base64::encode(encrypted.0),
                nonce: base64::encode(encrypted.1),
                from_peer_id: self.db.get_or_create_peer_id().unwrap(),
                end_peer_id: peer_id.clone(),
                request_id: request_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.proxy_tx.send(packet).await;

        match tokio::time::timeout(tokio::time::Duration::from_secs(30), rx).await {
            Ok(Ok(response)) => {
                let mut header_end = 0;
                let response_str = String::from_utf8_lossy(&response);
                
                if let Some(pos) = response_str.find("\r\n\r\n") {
                    header_end = pos + 4;
                } else if let Some(pos) = response_str.find("\n\n") {
                    header_end = pos + 2;
                }

                if header_end == 0 {
                    println!("[HTTP Proxy] Failed to find header separator in response");
                    return Ok(Response::builder()
                        .status(hyper::StatusCode::INTERNAL_SERVER_ERROR)
                        .body(full("Failed to parse response: Invalid HTTP format"))
                        .unwrap());
                }

                let (header_bytes, body_bytes) = response.split_at(header_end);
                let header_str = String::from_utf8_lossy(header_bytes);

                let mut lines = header_str.lines();
                let status_line = lines.next().unwrap_or("HTTP/1.1 500 Internal Server Error");
                let status_code = status_line
                    .split_whitespace()
                    .nth(1)
                    .and_then(|s| s.parse::<u16>().ok())
                    .unwrap_or(500);

                let mut response_builder = Response::builder().status(status_code);
                let mut content_type_set = false;

                for line in lines {
                    if let Some((name, value)) = line.split_once(':') {
                        let name_trimmed = name.trim();
                        let value_trimmed = value.trim();

                        if name_trimmed.eq_ignore_ascii_case("transfer-encoding") {
                            continue;
                        }

                        if name_trimmed.eq_ignore_ascii_case("content-type") {
                            content_type_set = true;
                        }

                        response_builder = response_builder.header(name_trimmed, value_trimmed);
                    }
                }

                if !content_type_set {
                    response_builder =
                        response_builder.header("Content-Type", "text/html; charset=utf-8");
                }

                let cookie = format!(
                    "peer_id={}; Path=/; HttpOnly; SameSite=Strict; Max-Age=31536000",
                    peer_id
                );
                response_builder = response_builder.header("Set-Cookie", cookie);

                Ok(response_builder
                    .body(Full::new(Bytes::from(body_bytes.to_vec())).boxed())
                    .unwrap())
            }
            _ => Ok(Response::builder()
                .status(hyper::StatusCode::GATEWAY_TIMEOUT)
                .body(full("Proxy timeout"))
                .unwrap()),
        }
    }
}

fn full<T: Into<Bytes>>(chunk: T) -> BoxBody<Bytes, Infallible> {
    Full::new(chunk.into()).map_err(|_| unreachable!()).boxed()
}


=== ../src\http\mod.rs ===
pub mod proxy;
pub mod http_proxy;

=== ../src\http\proxy.rs ===
use reqwest;
use std::sync::Arc;

use crate::commands::create_base_commands;
use crate::connection::Connection;
use crate::manager::ConnectionManager::ConnectionManager;
use crate::packets::{Protocol, ProxyMessage, TransportData, TransportPacket};

fn create_error_response(status: u16, message: &str) -> Vec<u8> {
    let status_text = match status {
        400 => "Bad Request",
        404 => "Not Found",
        500 => "Internal Server Error",
        _ => "Unknown Error",
    };

    let html = format!(
        r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Error {}</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }}
        .error-container {{
            background-color: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }}
        .error-code {{
            color: #e74c3c;
            font-size: 2.5rem;
            margin: 0;
            margin-bottom: 1rem;
        }}
        .error-title {{
            color: #2c3e50;
            font-size: 1.5rem;
            margin: 0;
            margin-bottom: 1rem;
        }}
        .error-message {{
            color: #7f8c8d;
            font-size: 1rem;
            line-height: 1.5;
        }}
    </style>
</head>
<body>
    <div class="error-container">
        <h1 class="error-code">{}</h1>
        <h2 class="error-title">{}</h2>
        <p class="error-message">{}</p>
    </div>
</body>
</html>"#,
        status, status, status_text, message
    );

    let response = format!(
        "HTTP/1.1 {} {}\r\n\
         Content-Type: text/html; charset=UTF-8\r\n\
         Content-Length: {}\r\n\
         Cache-Control: no-cache, no-store, must-revalidate\r\n\
         Pragma: no-cache\r\n\
         Expires: 0\r\n\
         X-Content-Type-Options: nosniff\r\n\
         X-Frame-Options: DENY\r\n\
         X-XSS-Protection: 1; mode=block\r\n\
         \r\n\
         {}",
        status,
        status_text,
        html.len(),
        html
    );
    response.into_bytes()
}

pub async fn handle_http_proxy_response(
    packet: TransportPacket,
    connection: &Connection,
    manager: Arc<ConnectionManager>,
    path_blobs: String,
) -> Result<(), String> {
    if let Some(TransportData::ProxyMessage(msg)) = packet.data {
        println!("[HTTP Proxy] Received encrypted request: {:?}", msg);

        let encrypted_request = match base64::decode(&msg.text) {
            Ok(data) => data,
            Err(e) => {
                let error_response = create_error_response(
                    400,
                    &format!("Failed to decode encrypted request: {}", e),
                );
                return send_error_response(error_response, &msg, connection, manager).await;
            }
        };

        let nonce = match base64::decode(&msg.nonce) {
            Ok(data) => data,
            Err(e) => {
                let error_response =
                    create_error_response(400, &format!("Failed to decode nonce: {}", e));
                return send_error_response(error_response, &msg, connection, manager).await;
            }
        };

        let nonce_array: [u8; 12] = match nonce.try_into() {
            Ok(arr) => arr,
            Err(_) => {
                let error_response = create_error_response(400, "Invalid nonce length");
                return send_error_response(error_response, &msg, connection, manager).await;
            }
        };

        println!("[HTTP Proxy] Public key: {}", &msg.from_peer_id);

        let request_bytes =
            match manager
                .db
                .decrypt_message(&encrypted_request, nonce_array, &msg.from_peer_id)
            {
                Ok(data) => data,
                Err(e) => {
                    let error_response =
                        create_error_response(500, &format!("Failed to decrypt message: {}", e));
                    return send_error_response(error_response, &msg, connection, manager).await;
                }
            };

        let request_str = String::from_utf8_lossy(&request_bytes);

        let mut lines = request_str.lines();
        let first_line = lines.next().unwrap_or("");
        let parts: Vec<&str> = first_line.split_whitespace().collect();
        // let method = if parts.len() > 0 { parts[0] } else { "GET" };
        let url = if parts.len() > 1 { parts[1] } else { "/" };

        // let client = match reqwest::Client::builder()
        //     .danger_accept_invalid_certs(true)
        //     .build()
        // {
        //     Ok(client) => client,
        //     Err(e) => {
        //         let error_response =
        //             create_error_response(500, &format!("Failed to create HTTP client: {}", e));
        //         return send_error_response(error_response, &msg, connection, manager).await;
        //     }
        // };

        println!("PATH FILE: {}", url);
        let url_without_my_id = url.replace(&format!("/{}", manager.db.get_or_create_peer_id().unwrap()), "");
        let url_without_my_id = if url_without_my_id.starts_with('/') {
            url_without_my_id.trim_start_matches('/').to_string()
        } else {
            url_without_my_id
        };
        println!("URL WITHOUT MY ID: {}", url_without_my_id);
        let search_result = manager.db.search_fragment_in_virtual_storage(&url_without_my_id, Some(true));
        let fragments = search_result.unwrap();
        let first_fragment = match fragments.first() {
            Some(fragment) => fragment,
            None => {
                println!("File not found");
                let error_response = create_error_response(404, "File not found");
                return send_error_response(error_response, &msg, connection, manager).await;
            }
        };
        let file_hash = first_fragment.file_hash.clone();
        let file_path = format!("{}/{}", path_blobs, file_hash);
        println!("FILE PATH: {}", file_path);
        
        if !std::path::Path::new(&file_path).exists() {
            let error_response = create_error_response(404, "File not found");
            return send_error_response(error_response, &msg, connection, manager).await;
        }

        let file_content = match std::fs::read(&file_path) {
            Ok(content) => content,
            Err(e) => {
                let error_response = create_error_response(500, &format!("Failed to read file: {}", e));
                return send_error_response(error_response, &msg, connection, manager).await;
            }
        };

        let mime_type = if let Some(fragment) = fragments.first() {
            fragment.mime.clone()
        } else {
            "application/octet-stream".to_string()
        };

        // Формируем HTTP-ответ
        let mut response = format!(
            "HTTP/1.1 200 OK\r\n\
             Content-Type: {}\r\n\
             Content-Length: {}\r\n\
             Cache-Control: no-cache\r\n\
             X-Content-Type-Options: nosniff\r\n\
             \r\n",
            mime_type,
            file_content.len()
        );

        let mut full_response = response.into_bytes();
        full_response.extend_from_slice(&file_content);

        // Шифруем ответ
        let (encrypted_response, nonce) = match manager
            .db
            .encrypt_message(&full_response, &msg.from_peer_id)
        {
            Ok(result) => result,
            Err(e) => {
                let error_response =
                    create_error_response(500, &format!("Failed to encrypt response: {}", e));
                return send_error_response(error_response, &msg, connection, manager).await;
            }
        };

        let response_packet = TransportPacket {
            act: "http_proxy_response".to_string(),
            to: Some(msg.from_peer_id.clone()),
            data: Some(TransportData::ProxyMessage(ProxyMessage {
                text: base64::encode(encrypted_response),
                nonce: base64::encode(nonce),
                from_peer_id: manager
                    .db
                    .get_or_create_peer_id()
                    .map_err(|e| format!("Failed to get peer ID: {}", e))?,
                end_peer_id: msg.from_peer_id.clone(),
                request_id: msg.request_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: manager
                .db
                .get_or_create_peer_id()
                .map_err(|e| format!("Failed to get peer ID: {}", e))?,
            nodes: vec![],
        };

        connection
            .send_packet(response_packet)
            .await
            .map_err(|e| e.to_string())
    } else {
        Ok(())
    }
}

async fn send_error_response(
    error_response: Vec<u8>,
    original_msg: &ProxyMessage,
    connection: &Connection,
    manager: Arc<ConnectionManager>,
) -> Result<(), String> {
    let base64_response = base64::encode(error_response);
    let (encrypted_response, nonce) = manager
        .db
        .encrypt_message(base64_response.as_bytes(), &original_msg.from_peer_id)
        .map_err(|e| format!("Failed to encrypt error response: {}", e))?;

    let response_packet = TransportPacket {
        act: "http_proxy_response".to_string(),
        to: Some(original_msg.from_peer_id.clone()),
        data: Some(TransportData::ProxyMessage(ProxyMessage {
            text: base64::encode(encrypted_response),
            nonce: base64::encode(nonce),
            from_peer_id: manager
                .db
                .get_or_create_peer_id()
                .map_err(|e| format!("Failed to get peer ID: {}", e))?,
            end_peer_id: original_msg.from_peer_id.clone(),
            request_id: original_msg.request_id.clone(),
        })),
        protocol: Protocol::TURN,
        uuid: manager
            .db
            .get_or_create_peer_id()
            .map_err(|e| format!("Failed to get peer ID: {}", e))?,
        nodes: vec![],
    };

    connection
        .send_packet(response_packet)
        .await
        .map_err(|e| e.to_string())
}


=== ../src\logger\mod.rs ===
use colored::*;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LogLevel {
    Debug,
    Info,
    Warning,
    Error,
}

pub struct Logger {
    show_debug: bool,
    show_info: bool,
    show_warning: bool,
    show_error: bool,
}

impl Logger {
    pub fn new() -> Self {
        Self {
            show_debug: false,
            show_info: true,
            show_warning: true,
            show_error: true,
        }
    }

    pub fn set_level(&mut self, level: LogLevel, enabled: bool) {
        match level {
            LogLevel::Debug => self.show_debug = enabled,
            LogLevel::Info => self.show_info = enabled,
            LogLevel::Warning => self.show_warning = enabled,
            LogLevel::Error => self.show_error = enabled,
        }
    }

    pub fn debug(&self, message: &str) {
        if self.show_debug {
            println!("{}", format!("[DEBUG] {}", message).blue().bold());
        }
    }

    pub fn info(&self, message: &str) {
        if self.show_info {
            println!("{}", message);
        }
    }

    pub fn warning(&self, message: &str) {
        if self.show_warning {
            println!("{}", format!("[WARNING] {}", message).yellow().bold());
        }
    }

    pub fn error(&self, message: &str) {
        if self.show_error {
            println!("{}", format!("[ERROR] {}", message).red().bold());
        }
    }

    pub fn peer(&self, message: &str) {
        if self.show_info {
            println!("{}", format!("[PEER] {}", message).cyan());
        }
    }

    pub fn turn(&self, message: &str) {
        if self.show_info {
            println!("{}", format!("[TURN] {}", message).green());
        }
    }

    pub fn storage(&self, message: &str) {
        if self.show_info {
            println!("{}", format!("[STORAGE] {}", message).magenta());
        }
    }
}

lazy_static::lazy_static! {
    pub static ref LOGGER: Logger = Logger::new();
} 

=== ../src\manager\ConnectionManager.rs ===
use crate::commands::{create_base_commands, get_db_path, get_path_blobs};
use crate::connection::{Connection, Message};
use crate::db::P2PDatabase;
use crate::http::http_proxy::HttpProxy;
use crate::manager::types::{ConnectionTurnStatus, ConnectionType};
use crate::packets::{TransportData, TransportPacket};
use crate::peer::peer_api::PeerAPI;
use crate::tunnel::Tunnel;
use crate::ui::console_manager;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex, RwLock};

use super::types::PeerOpenNetInfo;

#[derive(Clone)]
pub struct ConnectionManager {
    pub connections: Arc<Mutex<HashMap<String, Connection>>>,
    pub tunnels: Arc<Mutex<HashMap<String, Arc<Mutex<Tunnel>>>>>,
    pub connections_stun: Arc<Mutex<HashMap<String, PeerOpenNetInfo>>>,

    pub incoming_packet_rx:
        Arc<Mutex<mpsc::Receiver<(ConnectionType, TransportPacket, Option<Arc<Connection>>)>>>,
    pub incoming_packet_tx:
        mpsc::Sender<(ConnectionType, TransportPacket, Option<Arc<Connection>>)>,

    pub connections_turn: Arc<RwLock<HashMap<String, ConnectionTurnStatus>>>,
    pub db: Arc<P2PDatabase>,
    pub http_proxy: Arc<HttpProxy>,
    pub proxy_http_tx: mpsc::Sender<TransportPacket>,

    pub proxy_http_tx_reciever: Arc<Mutex<mpsc::Sender<TransportPacket>>>,
    pub path_blobs: String,
}

impl ConnectionManager {
    pub async fn new(db: &P2PDatabase) -> Self {
        let (incoming_packet_tx, incoming_packet_rx) = mpsc::channel(100);
        let (proxy_http_tx, mut proxy_http_rx) = mpsc::channel(1000);
        let (proxy_http_tx_reciever, mut proxy_http_rx_reciever) = mpsc::channel(1000);

        let connections_turn: Arc<RwLock<HashMap<String, ConnectionTurnStatus>>> =
            Arc::new(RwLock::new(HashMap::new()));

        let connections_stun = Arc::new(Mutex::new(HashMap::<String, PeerOpenNetInfo>::new()));

        let db_arc = Arc::new(db.clone());
        let proxy = Arc::new(HttpProxy::new(db_arc.clone(), proxy_http_tx.clone()));

        let proxy_clone = Arc::clone(&proxy);
        let proxy_clone_for_spawn = proxy_clone.clone();
        
        let mut proxy_http_rx_reciever = proxy_http_rx_reciever;

        tokio::spawn(async move {
            proxy_clone_for_spawn.start().await;
        });

        let commands = create_base_commands();
        let path_blobs = get_path_blobs(&commands.get_matches());

        let manager = ConnectionManager {
            connections: Arc::new(Mutex::new(HashMap::new())),
            tunnels: Arc::new(Mutex::new(HashMap::new())),
            connections_stun,

            incoming_packet_rx: Arc::new(Mutex::new(incoming_packet_rx)),
            incoming_packet_tx,

            connections_turn,

            db: db_arc,
            http_proxy: proxy,
            proxy_http_tx,

            proxy_http_tx_reciever: Arc::new(Mutex::new(proxy_http_tx_reciever)),
            path_blobs,
        };

        let manager_clone = manager.clone();
        let manager_clone_for_http = manager_clone.clone();
        tokio::spawn(async move {
            while let Some(packet) = proxy_http_rx.recv().await {
                println!(
                    "[HTTP Proxy] Getted request from http proxy: {:?}",
                    packet.to
                );
                manager_clone_for_http.auto_send_packet(packet).await;
            }
        });

        let db_clone = manager_clone.db.clone();
        let proxy_clone_rx = proxy_clone.clone();
        tokio::spawn(async move {
            while let Some(packet) = proxy_http_rx_reciever.recv().await {
                println!("[HTTP Proxy] Getted request from http proxy: {:?}", packet.to);
                let db = db_clone.clone();
                let proxy = proxy_clone_rx.clone();
                tokio::spawn(async move {
                    if let Some(TransportData::ProxyMessage(msg)) = packet.data {
                        println!("[HTTP Proxy] Getted request from http proxy: {:?}", msg.from_peer_id);
                        let encrypted_response = base64::decode(&msg.text).unwrap();
                        let nonce = base64::decode(&msg.nonce).unwrap();
                        let nonce_array: [u8; 12] = nonce.try_into().unwrap();
                        let response_bytes = db
                            .decrypt_message(&encrypted_response, nonce_array, &msg.from_peer_id)
                            .unwrap();
                        proxy.set_response(msg.request_id.clone(), response_bytes).await;
                    }
                });
            }
        });

        manager
    }

    pub async fn send_signaling_message(
        &self,
        server_address: &str,
        data: TransportPacket,
    ) -> Result<(), String> {
        let connections = self.connections.lock().await;
        if let Some(conn) = connections.get(server_address) {
            if let Err(e) = conn.tx.send(Message::SendData(data)).await {
                return Err(format!(
                    "Failed to send message to {}: {}",
                    server_address, e
                ));
            }
            Ok(())
        } else {
            Err(format!(
                "Signaling connection to {} not found",
                server_address
            ))
        }
    }

    pub async fn auto_send_packet(&self, packet: TransportPacket) {
        let connections = self.connections.lock().await;
        let mut sended_by_uuid = false;
        println!("Auto send packet: {:?}", packet);
        for (id, connection) in connections.iter() {
            if let Some(to) = &packet.to {
                if id == to {
                    if let Err(e) = connection.send_packet(packet.clone()).await {
                        println!("[ERROR] Failed to send packet to connection {}: {}", id, e);
                    } else {
                        println!(
                            "[HTTP Proxy] [AUTO SEND] Sended packet to connection {}: {:?}",
                            id, packet.to
                        );
                        sended_by_uuid = true;
                    }
                }
            }
        }
        if !sended_by_uuid {
            for (id, connection) in connections.iter() {
                if let Err(e) = connection.send_packet(packet.clone()).await {
                    println!("[ERROR] Failed to send packet to connection {}: {}", id, e);
                } else {
                    println!(
                        "[HTTP Proxy] [BROADCAST] Sended packet to connection {}: {:?}",
                        id, packet.to
                    );
                    sended_by_uuid = true;
                }
            }
        }
    }

    pub async fn add_connection(&self, id: String, connection: Arc<Connection>) {
        let tx = self.incoming_packet_tx.clone();
        let mut connections = self.connections.lock().await;

        self.connections_turn.write().await.insert(
            id.clone(),
            ConnectionTurnStatus {
                connected: true,
                turn_connection: true,
            },
        );

        let id_clone = id.clone();
        let connections_turn_clone = self.connections_turn.clone();

        let api = PeerAPI::new(connection.clone(), &self.db, &self);
        let api_clone = api.clone();
        let db_clone = self.db.clone();

        tokio::spawn({
            async move {
                loop {
                    console_manager(
                        Arc::new(api_clone.clone()),
                        connections_turn_clone.clone(),
                        &db_clone,
                    )
                    .await;
                }
            }
        });

        tokio::spawn({
            let tx_clone = tx.clone();
            let connection_clone = connection.clone();
            async move {
                while let Ok(response) = connection_clone.get_response().await {
                    let _ = tx_clone
                        .send((
                            ConnectionType::Signal(id_clone.clone()),
                            response,
                            Some(connection_clone.clone()),
                        ))
                        .await;
                }
            }
        });

        connections.insert(
            id,
            Arc::try_unwrap(connection).unwrap_or_else(|arc| (*arc).clone()),
        );
    }

    pub async fn get_tunnel(&self, id: String) -> Option<Arc<Mutex<Tunnel>>> {
        let tunnels = self.tunnels.lock().await;
        tunnels.get(&id).cloned()
    }

    pub async fn have_connection_with_peer(&self, id: String) -> bool {
        let connections_turn = self.connections_turn.read().await;
        connections_turn.get(&id).is_some() && connections_turn.get(&id).unwrap().connected
    }

    pub async fn add_tunnel(&self, id: String, tunnel: Tunnel) {
        let tx = self.incoming_packet_tx.clone();
        let mut tunnels = self.tunnels.lock().await;

        let tunnel_clone = Arc::new(tokio::sync::Mutex::new(tunnel));
        let tunnel_clone_for_spawn = tunnel_clone.clone();
        tokio::spawn(async move {
            let (local_tx, mut local_rx) = mpsc::channel::<Vec<u8>>(16);

            // Запуск обработки входящих сообщений из туннеля
            tokio::spawn(async move {
                while let Some(data) = local_rx.recv().await {
                    // Преобразование Vec<u8> в TransportPacket
                    if let Ok(packet) = serde_json::from_slice(&data)
                        .map_err(|e| format!("Failed to parse TransportPacket: {}", e))
                    {
                        let _ = tx.send((ConnectionType::Stun, packet, None)).await;
                    } else {
                        println!("[ERROR] Failed to parse incoming data into TransportPacket");
                    }
                }
            });

            loop {
                let mut buf = vec![0u8; 1024];
                let mut tunnel = tunnel_clone_for_spawn.lock().await;
                if let Some(socket) = &tunnel.socket {
                    while let Ok((n, reply_addr)) = socket.recv_from(&mut buf).await {
                        let data = buf[..n].to_vec();
                        let _ = local_tx.send(data).await;
                    }
                }
            }
        });

        tunnels.insert(id, tunnel_clone);
    }
}


=== ../src\manager\file_handler.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::connection::Connection;
use crate::crypto::token::validate_signature_token;
use crate::db::{P2PDatabase, Storage};
use crate::packets::{
    EncryptedData, FileData, Message, PeerFileGet, PeerFileSaved, PeerUploadFile, Protocol,
    TransportData, TransportPacket, PeerFileAccessChange, PeerFileDelete, PeerFileMove,
    FragmentMetadataSync,
};
use base64;
use colored::*;
use serde_json;
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use sha2::{Digest, Sha256};
use hex;

impl ConnectionManager {
    pub async fn handle_file_upload(
        &self,
        db: &P2PDatabase,
        data: PeerUploadFile,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        println!("Get token for peer: {}", data.peer_id);
        let token_info = self.db.get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных. Возможно, он был отозван или истек срок его действия".to_string())?;

        if token_info.token != data.token {
            println!(
                "Token info: {}. Token in request: {}",
                token_info.token, data.token
            );
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let token_hash = hex::encode(Sha256::digest(data.token.as_bytes()));

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        let contents = base64::decode(&data.contents)
            .map_err(|e| format!("Ошибка при декодировании содержимого файла: {}", e))?;

        if contents.len() as u64 > validated_token.file_size {
            return Err(format!(
                "Размер файла ({}) превышает разрешенный размер в токене ({})",
                contents.len(),
                validated_token.file_size
            ));
        }

        let free_space = self
            .db
            .get_storage_free_space()
            .await
            .map_err(|e| format!("Ошибка при получении свободного места: {:?}", e))?;

        if free_space < contents.len() as u64 {
            return Err(format!(
                "Недостаточно свободного места. Требуется: {}, Доступно: {}",
                contents.len(),
                free_space
            ));
        }

        let dir_path: String = format!("{}/blobs", self.db.path.as_str());
        if !std::path::Path::new(&dir_path).exists() {
            tokio::fs::create_dir_all(&dir_path)
                .await
                .map_err(|e| format!("Ошибка при создании директории: {}", e))?;
        }

        let final_contents = if data.compressed && data.auto_decompress {
            println!("Распаковка сжатых данных...");
            self.db
                .uncompress_data(&contents)
                .map_err(|e| format!("Ошибка распаковки: {}", e))?
        } else {
            contents
        };

        let path = format!("{}/{}", dir_path, data.file_hash);
        let mut file = File::create(&path)
            .await
            .map_err(|e| format!("Ошибка при создании файла: {}", e))?;
        file.write_all(&final_contents)
            .await
            .map_err(|e| format!("Ошибка при записи файла: {}", e))?;

        let peer_id = data.peer_id.clone();

        let file_is_compressed = if data.auto_decompress {
            false
        } else {
            data.compressed
        };

        self.db
            .add_storage_fragment(Storage {
                file_hash: data.file_hash.clone(),
                filename: data.filename.clone(),
                token: data.token.clone(),
                token_hash: Some(token_hash.clone()),
                uploaded_via_token: Some(data.token.clone()),
                owner_key: peer_id.clone(),
                storage_peer_key: self.db.get_or_create_peer_id().unwrap(),
                mime: data.mime.clone(),
                public: data.public,
                encrypted: data.encrypted,
                compressed: file_is_compressed,
                auto_decompress: data.auto_decompress,
                size: final_contents.len() as u64,
            })
            .map_err(|e| format!("Ошибка при добавлении информации о фрагменте: {}", e))?;

        println!("{}", "[Peer] Файл успешно сохранен".green());

        let packet_feedback = TransportPacket {
            act: "file_saved".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::PeerFileSaved(PeerFileSaved {
                filename: data.filename,
                token: data.token,
                token_hash: Some(token_hash),
                storage_peer_key: self.db.get_or_create_peer_id().unwrap(),
                owner_key: peer_id.clone(),
                hash_file: data.file_hash,
                encrypted: data.encrypted,
                compressed: file_is_compressed,
                auto_decompress: data.auto_decompress,
                public: data.public,
                size: final_contents.len() as u64,
                mime: data.mime,
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        connection
            .send_packet(packet_feedback)
            .await
            .map_err(|e| format!("Ошибка при отправке подтверждения: {}", e))
    }

    pub async fn handle_file_saved(&self, data: PeerFileSaved) -> Result<(), String> {
        let token_clone = data.token.clone().to_string();
        let _ = self.db.add_storage_fragment(Storage {
            file_hash: data.hash_file.clone(),
            filename: data.filename.clone(),
            token: token_clone.clone(),
            token_hash: data.token_hash.clone(),
            uploaded_via_token: Some(data.token.clone()),
            owner_key: data.owner_key.clone(),
            storage_peer_key: data.storage_peer_key.clone(),
            mime: data.mime.clone(),
            public: data.public,
            encrypted: data.encrypted,
            compressed: data.compressed,
            auto_decompress: data.auto_decompress,
            size: data.size,
        });

        println!(
            "{}",
            format!("\x1b[32m[Peer] File saved. Hash: {}\x1b[0m", data.hash_file).green()
        );
        Ok(())
    }

    pub async fn handle_file_get(
        &self,
        data: PeerFileGet,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let contents = self
            .db
            .search_fragment_in_virtual_storage(&data.file_hash, None);

        if let Some(fragment) = contents.unwrap().first() {
            if !fragment.public
                && fragment.uploaded_via_token.is_some()
                && data.token.as_ref().map_or(false, |t| t != &fragment.token)
            {
                let packet_feedback = TransportPacket {
                    act: "file_get".to_string(),
                    to: Some(from_uuid.clone()),
                    data: Some(TransportData::Message(Message {
                        text: "Token is not valid".to_string(),
                        nonce: None,
                    })),
                    protocol: Protocol::TURN,
                    uuid: self.db.get_or_create_peer_id().unwrap(),
                    nodes: vec![],
                };

                connection
                    .send_packet(packet_feedback)
                    .await
                    .map_err(|e| e.to_string())?;
                return Err("Token is not valid".to_string());
            }

            let dir_path = format!("{}/blobs", self.db.path.as_str());
            let path = format!("{}/{}", dir_path, fragment.file_hash);
            let mut file = File::open(path).await.unwrap();
            let mut contents = vec![];
            file.read_to_end(&mut contents).await.unwrap();

            let packet_file = TransportPacket {
                act: "file".to_string(),
                to: Some(from_uuid.clone()),
                data: Some(TransportData::FileData(FileData {
                    filename: fragment.filename.clone().to_string(),
                    contents: base64::encode(contents),
                    peer_id: self.db.get_or_create_peer_id().unwrap(),
                    hash_file: fragment.file_hash.clone(),
                    encrypted: fragment.encrypted,
                    compressed: fragment.compressed,
                    public: fragment.public,
                    auto_decompress: fragment.auto_decompress,
                })),
                protocol: Protocol::TURN,
                uuid: self.db.get_or_create_peer_id().unwrap(),
                nodes: vec![],
            };

            println!(
                "{}",
                format!("[Peer] Sending file: {}", fragment.filename.clone()).cyan()
            );
            connection
                .send_packet(packet_file)
                .await
                .map_err(|e| e.to_string())?;
        }
        Ok(())
    }

    pub async fn handle_file_data(&self, data: FileData) -> Result<(), String> {
        let dir_path: String = format!("{}/recive_files", self.db.path.as_str());
        if !std::path::Path::new(&dir_path).exists() {
            tokio::fs::create_dir_all(&dir_path).await.unwrap();
        }

        println!("Filename: {:?}", data.filename);
        println!("File hash: {:?}", data.hash_file);
        println!("File encrypted: {:?}", data.encrypted);
        println!("File compressed: {:?}", data.compressed);
        println!("File public: {:?}", data.public);

        let path = format!("{}/{}", dir_path, data.filename);
        let mut file = File::create(path).await.unwrap();

        let contents = base64::decode(data.contents).unwrap();
        println!("Contents: {:?}", contents);

        let final_contents = if data.encrypted {
            let json_data: EncryptedData = serde_json::from_slice(&contents)
                .map_err(|e| format!("Ошибка десериализации зашифрованных данных: {}", e))?;

            let decrypted_contents = self
                .db
                .decrypt_data(&json_data.content, &json_data.nonce)
                .map_err(|e| format!("Ошибка расшифровки: {}", e))?;

            if data.compressed {
                self.db
                    .uncompress_data(&decrypted_contents)
                    .map_err(|e| format!("Ошибка распаковки: {}", e))?
            } else {
                decrypted_contents
            }
        } else {
            if data.compressed && data.auto_decompress {
                self.db
                    .uncompress_data(&contents)
                    .map_err(|e| format!("Ошибка распаковки: {}", e))?
            } else {
                contents
            }
        };

        file.write_all(&final_contents)
            .await
            .map_err(|e| format!("Ошибка записи файла: {}", e))?;

        println!(
            "{}",
            format!("[Peer] File saved: {}", data.filename).green()
        );
        Ok(())
    }

    pub async fn handle_file_access_change(
        &self,
        data: PeerFileAccessChange,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let fragments = self.db
            .search_fragment_in_virtual_storage(&data.file_hash, None)
            .map_err(|e| format!("Ошибка при поиске файла: {}", e))?;
        let fragment = fragments.first()
            .ok_or_else(|| "Файл не найден".to_string())?;

        if fragment.owner_key != from_uuid {
            return Err("У вас нет прав на изменение доступа к этому файлу".to_string());
        }

        let token_info = self.db.get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных".to_string())?;

        if token_info.token != data.token {
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        self.db
            .update_fragment_public_access(&data.file_hash, data.public)
            .map_err(|e| format!("Ошибка при обновлении доступа: {}", e))?;

        println!("{}", format!("[Peer] Доступ к файлу {} изменен на {}", data.file_hash, if data.public { "публичный" } else { "приватный" }).green());

        let packet_feedback = TransportPacket {
            act: "file_access_changed".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: format!("Доступ к файлу {} изменен на {}", data.file_hash, if data.public { "публичный" } else { "приватный" }),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        connection.send_packet(packet_feedback).await
    }

    pub async fn handle_file_delete(
        &self,
        data: PeerFileDelete,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let fragments = self.db
            .search_fragment_in_virtual_storage(&data.file_hash, None)
            .map_err(|e| format!("Ошибка при поиске файла: {}", e))?;
        let fragment = fragments.first()
            .ok_or_else(|| "Файл не найден".to_string())?;

        if fragment.owner_key != from_uuid {
            return Err("У вас нет прав на удаление этого файла".to_string());
        }

        let token_info = self.db.get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных".to_string())?;

        if token_info.token != data.token {
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        // Удаляем физический файл
        let dir_path = format!("{}/blobs", self.db.path.as_str());
        let path = format!("{}/{}", dir_path, data.file_hash);
        if std::path::Path::new(&path).exists() {
            tokio::fs::remove_file(&path)
                .await
                .map_err(|e| format!("Ошибка при удалении файла: {}", e))?;
        }

        // Удаляем запись из базы данных
        self.db
            .remove_fragment(&data.file_hash)
            .map_err(|e| format!("Ошибка при удалении записи из базы данных: {}", e))?;

        println!("{}", format!("[Peer] Файл {} успешно удален", data.file_hash).green());

        let packet_feedback = TransportPacket {
            act: "file_deleted".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: format!("Файл {} успешно удален", data.file_hash),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        connection.send_packet(packet_feedback).await
    }

    pub async fn handle_file_move(
        &self,
        data: PeerFileMove,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let fragments = self.db
            .search_fragment_in_virtual_storage(&data.file_hash, None)
            .map_err(|e| format!("Ошибка при поиске файла: {}", e))?;
        let fragment = fragments.first()
            .ok_or_else(|| "Файл не найден".to_string())?;

        if fragment.owner_key != from_uuid {
            return Err("У вас нет прав на перемещение этого файла".to_string());
        }

        let token_info = self.db.get_token(&data.peer_id)
            .map_err(|e| format!("Ошибка при проверке токена в базе данных: {}", e))?
            .ok_or_else(|| "Токен не найден в базе данных".to_string())?;

        if token_info.token != data.token {
            return Err("Токен в запросе не совпадает с токеном в базе данных".to_string());
        }

        let validated_token = validate_signature_token(data.token.clone(), &self.db)
            .await
            .map_err(|e| format!("Ошибка при проверке подписи токена: {}", e))?;

        // Обновляем путь к файлу
        self.db
            .update_fragment_path(&data.file_hash, &data.new_path)
            .map_err(|e| format!("Ошибка при обновлении пути: {}", e))?;

        println!("{}", format!("[Peer] Файл {} перемещен в {}", data.file_hash, data.new_path).green());

        let packet_feedback = TransportPacket {
            act: "file_moved".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: format!("Файл {} успешно перемещен в {}", data.file_hash, data.new_path),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        connection.send_packet(packet_feedback).await
    }
}


=== ../src\manager\ManagerPorts.rs ===
use super::ConnectionManager::ConnectionManager;

impl ConnectionManager {

    
}


=== ../src\manager\message_handler.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::{
    connection::Connection,
    packets::{Message, Protocol, TransportData, TransportPacket},
};
use colored::*;

impl ConnectionManager {
    pub async fn handle_message(
        &self,
        data: Message,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        println!("{}", format!("[Peer] Message: {}", data.text).green());

        let response_packet = TransportPacket {
            act: "message_response".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::Message(Message {
                text: "Message received".to_string(),
                nonce: None,
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        connection
            .send_packet(response_packet)
            .await
            .map_err(|e| e.to_string())
    }

    pub async fn handle_message_response(&self) -> Result<(), String> {
        println!("{}", "[Peer] Message sent successfully".green());
        Ok(())
    }
}


=== ../src\manager\mod.rs ===
pub mod ConnectionManager;
pub mod ProcessPackets;
pub mod StunManager;
pub mod types;
pub mod ManagerPorts;
pub mod storage_handler;
pub mod file_handler;
pub mod message_handler;

pub use types::ConnectionTurnStatus;

=== ../src\manager\ProcessPackets.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::http::proxy::handle_http_proxy_response;
use crate::logger::LOGGER;
use crate::manager::types::{ConnectionTurnStatus, ConnectionType};
use crate::packets::{Message, Protocol, StorageToken, TransportData, TransportPacket};
use crate::peer::turn_tunnel;
use colored::Colorize;
use hex;
use serde_json;
use std::sync::Arc;
use std::time::Duration;

impl ConnectionManager {
    pub async fn handle_incoming_packets(&self) {
        let incoming_packet_rx = self.incoming_packet_rx.clone();
        let mut rx = incoming_packet_rx.lock().await;
        LOGGER.debug("Starting to handle incoming packets...");
        loop {
            if let Some((connection_type, packet, connection)) = rx.recv().await {
                match connection_type {
                    ConnectionType::Signal(id) => {
                        if let Some(connection) = connection {
                            LOGGER.debug(&format!("Received signal packet: {:?}", packet));
                            let from_uuid = packet.uuid.clone();
                            let packet_clone = packet.clone();
                            let protocol_connection = packet.protocol.clone();

                            if let Some(data) = &packet.data {
                                match data {
                                    TransportData::ProxyMessage(data) => {
                                        self.proxy_http_tx_reciever
                                            .lock()
                                            .await
                                            .send(packet.clone())
                                            .await;
                                    }
                                    TransportData::StorageReservationRequest(request) => {
                                        if let Err(e) = self
                                            .handle_storage_reservation_request(
                                                request.clone(),
                                                &connection,
                                            )
                                            .await
                                        {
                                            LOGGER.error(&format!(
                                                "Failed to handle storage reservation request: {}",
                                                e
                                            ));
                                        }
                                    }
                                    TransportData::StorageValidTokenRequest(token) => {
                                        if let Err(e) = self
                                            .handle_storage_valid_token_request(
                                                token.token.clone(),
                                                &connection,
                                                from_uuid.clone(),
                                            )
                                            .await
                                        {
                                            LOGGER.error(&format!(
                                                "Failed to handle storage valid token request: {}",
                                                e
                                            ));
                                        }
                                    }
                                    TransportData::PeerFileGet(data) => {
                                        if let Err(e) = self
                                            .handle_file_get(
                                                data.clone(),
                                                &connection,
                                                from_uuid.clone(),
                                            )
                                            .await
                                        {
                                            LOGGER.error(&format!(
                                                "Failed to handle file get: {}",
                                                e
                                            ));
                                        }
                                    }
                                    TransportData::FileData(data) => {
                                        let peer_id = data.peer_id.clone();
                                        if let Err(e) = self.handle_file_data(data.clone()).await {
                                            LOGGER.error(&format!(
                                                "Failed to handle file data: {}",
                                                e
                                            ));
                                        } else {
                                            if let Ok(free_space) =
                                                self.db.get_storage_free_space().await
                                            {
                                                if let Err(e) = self
                                                    .db
                                                    .update_token_free_space(&peer_id, free_space)
                                                {
                                                    LOGGER.error(&format!(
                                                        "Failed to update token free space: {}",
                                                        e
                                                    ));
                                                }
                                            }
                                        }
                                    }
                                    TransportData::PeerFileDelete(data) => {
                                        if let Err(e) = self
                                            .handle_file_delete(
                                                data.clone(),
                                                &connection,
                                                from_uuid.clone(),
                                            )
                                            .await
                                        {
                                            LOGGER.error(&format!(
                                                "Failed to handle file delete: {}",
                                                e
                                            ));
                                        }
                                    }
                                    TransportData::PeerFileMove(data) => {
                                        if let Err(e) = self
                                            .handle_file_move(
                                                data.clone(),
                                                &connection,
                                                from_uuid.clone(),
                                            )
                                            .await
                                        {
                                            LOGGER.error(&format!(
                                                "Failed to handle file move: {}",
                                                e
                                            ));
                                        }
                                    }
                                    TransportData::PeerFileAccessChange(data) => {
                                        if let Err(e) = self
                                            .handle_file_access_change(
                                                data.clone(),
                                                &connection,
                                                from_uuid.clone(),
                                            )
                                            .await
                                        {
                                            LOGGER.error(&format!(
                                                "Failed to handle file access change: {}",
                                                e
                                            ));
                                        }
                                    }
                                    TransportData::StorageValidTokenResponse(response) => {
                                        LOGGER.storage("\n╔════════════════════════════════════════════════════════════╗");
                                        LOGGER.storage("║                    ВАЛИДАЦИЯ ТОКЕНА ХРАНИЛИЩА                  ║");
                                        LOGGER.storage("╠════════════════════════════════════════════════════════════╣");
                                        LOGGER.storage(&format!(
                                            "║ Статус: {} ║",
                                            if response.status {
                                                "✅ ТОКЕН ВАЛИДЕН"
                                            } else {
                                                "❌ ТОКЕН НЕВАЛИДЕН"
                                            }
                                        ));
                                        LOGGER.storage("╚════════════════════════════════════════════════════════════╝\n");
                                    }
                                    TransportData::PeerSearchResponse(response) => {
                                        LOGGER.peer("\n╔════════════════════════════════════════════════════════════╗");
                                        LOGGER.peer("║                      РЕЗУЛЬТАТЫ ПОИСКА ПИРА                    ║");
                                        LOGGER.peer("╠════════════════════════════════════════════════════════════╣");
                                        LOGGER.peer(&format!(
                                            "║ {} ║",
                                            format!("Статус: {}", "✅ ПИР НАЙДЕН").yellow()
                                        ));
                                        LOGGER.peer(&format!(
                                            "║ {} ║",
                                            format!("UUID пира: {}", response.peer_id).cyan()
                                        ));
                                        LOGGER.peer(&format!(
                                            "║ {} ║",
                                            format!(
                                                "Адрес ноды: {}:{}",
                                                response.public_ip, response.public_port
                                            )
                                            .cyan()
                                        ));
                                        LOGGER.peer(&format!(
                                            "║ {} ║",
                                            format!("Прыжков: {}", response.hops).cyan()
                                        ));
                                        LOGGER.peer("╚════════════════════════════════════════════════════════════╝\n");
                                    }
                                    TransportData::StorageReservationResponse(response) => {
                                        LOGGER.storage(&format!("\n{}", "=".repeat(80).yellow()));
                                        LOGGER.storage(&format!("{}", "ВНИМАНИЕ! ВЫ ПОЛУЧИЛИ УНИКАЛЬНЫЙ ТОКЕН ДЛЯ ХРАНЕНИЯ И ПОЛУЧЕНИЯ ДАННЫХ С P2P ПИРА".red().bold()));
                                        LOGGER.storage(&format!("{}", "ЕСЛИ ВЫ ПОТЕРЯЕТЕ КЛЮЧ ВЫ НЕ СМОЖЕТЕ ПОЛУЧИТЬ ДОСТУП К ДАННЫМ".red().bold()));
                                        LOGGER.storage(&format!("{}", "=".repeat(80).yellow()));

                                        if let Ok(token_bytes) = base64::decode(&response.token) {
                                            if let Ok(token_str) = String::from_utf8(token_bytes) {
                                                if let Ok(token) =
                                                    serde_json::from_str::<StorageToken>(&token_str)
                                                {
                                                    LOGGER.storage(&format!(
                                                        "\n{}",
                                                        "ДЕТАЛИ ТОКЕНА:".cyan().bold()
                                                    ));
                                                    LOGGER.storage(&format!(
                                                        "{} {}",
                                                        "Размер файла:".yellow(),
                                                        format!("{} байт", token.file_size).white()
                                                    ));
                                                    LOGGER.storage(&format!(
                                                        "{} {}",
                                                        "Провайдер хранилища:".yellow(),
                                                        token.storage_provider.white()
                                                    ));
                                                    LOGGER.storage(&format!(
                                                        "{} {}",
                                                        "Временная метка:".yellow(),
                                                        format!("{}", token.timestamp).white()
                                                    ));
                                                    LOGGER.storage(&format!(
                                                        "{} {}",
                                                        "Подпись:".yellow(),
                                                        hex::encode(&token.signature).white()
                                                    ));

                                                    if let Err(e) = self.db.add_token(
                                                        &response.peer_id,
                                                        &response.token,
                                                        token.file_size,
                                                    ) {
                                                        LOGGER.error(&format!(
                                                            "Failed to save token to database: {}",
                                                            e
                                                        ));
                                                    }
                                                }
                                            }
                                        }

                                        LOGGER.storage(&format!("\n{}", "=".repeat(80).yellow()));
                                        LOGGER.storage(&format!(
                                            "{}",
                                            "ТОКЕН В BASE64:".cyan().bold()
                                        ));
                                        LOGGER.storage(&format!("{}", response.token.white()));
                                        LOGGER.storage(&format!("{}", "=".repeat(80).yellow()));
                                    }
                                    _ => {}
                                }
                            }

                            if packet.act == "http_proxy_request" {
                                LOGGER.debug("Received http proxy request");
                                let connection = connection.clone();
                                let manager = Arc::new(self.clone());
                                let packet_clone = packet.clone();
                                let path_blobs = self.path_blobs.clone().to_string();
                                tokio::spawn(async move {
                                    let _ = handle_http_proxy_response(
                                        packet_clone,
                                        &connection,
                                        manager,
                                        path_blobs,
                                    )
                                    .await;
                                });
                            } else if packet.act == "peer_list" {
                                if let Some(TransportData::SyncPeerInfoData(peer_info_data)) =
                                    packet.data
                                {
                                    LOGGER.peer("Received peer list:");
                                    for peer in peer_info_data.peers {
                                        LOGGER.peer(&format!("Peer - UUID: {}", peer.uuid));
                                    }
                                } else {
                                    LOGGER.error("Peer list data is missing.");
                                }
                            } else if protocol_connection == Protocol::STUN {
                                LOGGER.debug("Processing STUN packet");
                                match packet.act.as_str() {
                                    "wait_connection" => {
                                        LOGGER.debug(&format!(
                                            "Received wait_connection from {}",
                                            from_uuid
                                        ));
                                        let result = async {
                                            self.send_wait_connection(
                                                packet.uuid.clone(),
                                                &connection,
                                                self.db.get_or_create_peer_id().unwrap(),
                                            )
                                            .await
                                        }
                                        .await;

                                        if let Err(e) = result {
                                            LOGGER.error(&format!(
                                                "Failed to send wait_connection: {}",
                                                e
                                            ));
                                        } else {
                                            LOGGER.debug("Successfully sent wait_connection");
                                        }
                                    }
                                    "accept_connection" => {
                                        LOGGER.debug(&format!(
                                            "Received accept_connection from {}",
                                            from_uuid
                                        ));
                                        let result = self
                                            .receive_accept_connection(
                                                packet,
                                                self.db.get_or_create_peer_id().unwrap(),
                                            )
                                            .await;

                                        match result {
                                            Ok(_) => {
                                                LOGGER.debug("Connection established successfully");
                                                self.connections_turn.write().await.insert(
                                                    from_uuid.clone(),
                                                    ConnectionTurnStatus {
                                                        connected: true,
                                                        turn_connection: false,
                                                    },
                                                );
                                            }
                                            Err(e) => {
                                                LOGGER.error(&format!(
                                                    "Failed to establish connection: {}",
                                                    e
                                                ));
                                                self.connections_turn.write().await.insert(
                                                    from_uuid.clone(),
                                                    ConnectionTurnStatus {
                                                        connected: false,
                                                        turn_connection: true,
                                                    },
                                                );
                                            }
                                        }
                                    }
                                    _ => {
                                        LOGGER.debug(&format!("Unknown STUN act: {}", packet.act));
                                    }
                                }
                            } else if protocol_connection == Protocol::TURN
                                && packet.act == "wait_connection"
                            {
                                self.connections_turn.write().await.insert(
                                    from_uuid.clone(),
                                    ConnectionTurnStatus {
                                        connected: false,
                                        turn_connection: true,
                                    },
                                );
                            }

                            LOGGER.debug(&format!("From UUID: {}", from_uuid.clone()));
                            if let Some(status) =
                                self.connections_turn.write().await.get_mut(&from_uuid)
                            {
                                if status.turn_connection && !status.connected {
                                    let result_turn_tunnel =
                                        turn_tunnel(packet_clone, &connection, &self.db).await;
                                    tokio::time::sleep(Duration::from_millis(100)).await;
                                    LOGGER.debug(&format!(
                                        "Result turn tunnel {:?}",
                                        result_turn_tunnel
                                    ));
                                    match result_turn_tunnel {
                                        Ok(r) => {
                                            if r == "successful_connection" {
                                                LOGGER.turn("Connection established!");
                                                status.connected = true;
                                                status.turn_connection = false;

                                                let packet_hello = TransportPacket {
                                                    act: "test_turn".to_string(),
                                                    to: Some(from_uuid.clone()),
                                                    data: None,
                                                    protocol: Protocol::TURN,
                                                    uuid: self.db.get_or_create_peer_id().unwrap(),
                                                    nodes: vec![],
                                                };
                                                LOGGER.debug("Sending accept connection");
                                                let _ = connection.send_packet(packet_hello).await;
                                            } else if r == "send_wait_connection" {
                                                LOGGER
                                                    .peer("Wait answer acceptation connection...");
                                            }
                                        }
                                        Err(e) => {
                                            status.connected = false;
                                            status.turn_connection = true;
                                            LOGGER.error(&format!("Fail: {}", e));
                                        }
                                    }
                                    LOGGER.debug("Wait new packets...");
                                } else {
                                    let packet_file_clone = packet_clone.clone();
                                    match packet_clone.act.as_str() {
                                        "save_file" => {
                                            if let Some(TransportData::PeerUploadFile(data)) =
                                                packet_file_clone.data
                                            {
                                                if let Err(e) = self
                                                    .handle_file_upload(
                                                        &self.db,
                                                        data,
                                                        &connection,
                                                        from_uuid.clone(),
                                                    )
                                                    .await
                                                {
                                                    let formatted_error = format!(
                                                        "Failed to handle file upload: {}",
                                                        e
                                                    );
                                                    LOGGER.error(&formatted_error);

                                                    let packet_error = TransportPacket {
                                                        act: "message".to_string(),
                                                        to: Some(from_uuid.clone()),
                                                        data: Some(TransportData::Message(
                                                            Message {
                                                                text: formatted_error,
                                                                nonce: None,
                                                            },
                                                        )),
                                                        protocol: Protocol::TURN,
                                                        uuid: self
                                                            .db
                                                            .get_or_create_peer_id()
                                                            .unwrap(),
                                                        nodes: vec![],
                                                    };

                                                    let _ =
                                                        connection.send_packet(packet_error).await;
                                                }
                                            }
                                        }
                                        "file_saved" => {
                                            if let Some(TransportData::PeerFileSaved(data)) =
                                                packet_file_clone.data
                                            {
                                                if let Err(e) = self.handle_file_saved(data).await {
                                                    println!(
                                                        "[Peer] Failed to handle file saved: {}",
                                                        e
                                                    );
                                                }
                                            }
                                        }
                                        "message_response" => {
                                            if let Err(e) = self.handle_message_response().await {
                                                LOGGER.error(&format!(
                                                    "Failed to handle message response: {}",
                                                    e
                                                ));
                                            }
                                        }
                                        "message" => {
                                            if let Some(TransportData::Message(data)) =
                                                packet_clone.data
                                            {
                                                if let Err(e) = self
                                                    .handle_message(
                                                        data,
                                                        &connection,
                                                        from_uuid.clone(),
                                                    )
                                                    .await
                                                {
                                                    LOGGER.error(&format!(
                                                        "Failed to handle message: {}",
                                                        e
                                                    ));
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            } else {
                                LOGGER.error("[Turn] Connection not found");
                            }
                        }
                    }
                    ConnectionType::Stun => {
                        LOGGER.debug(&format!("Received message from Tunnel: {:?}", packet));
                    }
                }
            } else {
                LOGGER.debug("No messages received, sleeping...");
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            }
        }
    }
}


=== ../src\manager\storage_handler.rs ===
use super::ConnectionManager::ConnectionManager;
use crate::connection::Connection;
use crate::packets::{
    StorageReservationRequest, StorageReservationResponse, StorageToken, StorageValidTokenResponse,
    TransportData, TransportPacket, Protocol,
};
use base64;
use hex;
use k256;
use k256::ecdsa::signature::SignerMut;
use serde_json;

impl ConnectionManager {
    pub async fn handle_storage_reservation_request(
        &self,
        request: StorageReservationRequest,
        connection: &Connection,
    ) -> Result<(), String> {
        let free_space = self.db.get_storage_free_space().await.unwrap();
        println!("[Peer] Free space: {}", free_space);

        if free_space < request.size_in_bytes {
            println!("[Peer] Not enough storage space available");
            return Err("Not enough storage space".to_string());
        }

        let mut signing_key = self.db.get_private_signing_key().unwrap();
        let pub_key = signing_key.verifying_key().to_sec1_bytes();
        let pub_key_hex = hex::encode(pub_key);

        let storage_token = StorageToken {
            file_size: request.size_in_bytes as u64,
            storage_provider: pub_key_hex,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            signature: Vec::new(),
        };

        let mut token_bytes = serde_json::to_vec(&storage_token).unwrap();
        let signature: k256::ecdsa::Signature = signing_key.sign(&token_bytes);

        let mut final_token = storage_token;
        final_token.signature = signature.to_bytes().to_vec();

        let token_base64 = base64::encode(serde_json::to_vec(&final_token).unwrap());

        if let Err(e) = self.db.add_token(&request.peer_id, &token_base64, free_space) {
            println!("[Peer] Failed to save token to database: {}", e);
            return Err(format!("Failed to save token: {}", e));
        }

        let response = TransportPacket {
            act: "reserve_storage_response".to_string(),
            to: Some(request.peer_id.clone()),
            data: Some(TransportData::StorageReservationResponse(
                StorageReservationResponse {
                    peer_id: request.peer_id,
                    token: token_base64,
                    size_in_bytes: request.size_in_bytes,
                },
            )),
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        connection.send_packet(response).await.map_err(|e| e.to_string())
    }

    pub async fn handle_storage_valid_token_request(
        &self,
        token: String,
        connection: &Connection,
        from_uuid: String,
    ) -> Result<(), String> {
        let token_bytes = base64::decode(&token).unwrap();
        let token_str = String::from_utf8(token_bytes).unwrap();
        let token: StorageToken = serde_json::from_str(&token_str).unwrap();
        
        let mut signing_key = self.db.get_private_signing_key().unwrap();
        let pub_key = signing_key.verifying_key().to_sec1_bytes();
        let pub_key_hex = hex::encode(pub_key);

        let status = pub_key_hex == token.storage_provider;

        let response = TransportPacket {
            act: "storage_valid_token_response".to_string(),
            to: Some(from_uuid),
            data: Some(TransportData::StorageValidTokenResponse(
                StorageValidTokenResponse {
                    peer_id: self.db.get_or_create_peer_id().unwrap(),
                    status,
                },
            )),
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        connection.send_packet(response).await.map_err(|e| e.to_string())
    }
} 

=== ../src\manager\StunManager.rs ===
use crate::connection::Connection;
use crate::packets::{PeerWaitConnection, Protocol, TransportData, TransportPacket};
use crate::tunnel::Tunnel;
use anyhow::Result;

use super::types::PeerOpenNetInfo;
use super::ConnectionManager::ConnectionManager;

impl ConnectionManager {
    pub async fn send_wait_connection(
        &self,
        target_uuid: String,
        server_conn: &Connection,
        my_key: String,
    ) -> Result<(), String> {
        println!("[DEBUG] Starting send_wait_connection");
        println!("[DEBUG] Target UUID: {}", target_uuid);
        println!("[DEBUG] My Key: {}", my_key);

        let tunnel = Tunnel::new().await;
        println!("[DEBUG] Created new tunnel with IP: {} and Port: {}", tunnel.public_ip, tunnel.public_port);

        let net_info = PeerWaitConnection {
            connect_peer_id: target_uuid.clone(),
            public_ip: tunnel.public_ip.clone(),
            public_port: tunnel.public_port,
        };

        println!("[DEBUG] Created net_info: {:?}", net_info);

        self.connections_stun.lock().await.insert(
            target_uuid.clone(),
            PeerOpenNetInfo {
                ip: net_info.public_ip.clone(),
                port: net_info.public_port,
            },
        );

        println!("[DEBUG] Added connection to STUN connections map");

        self.add_tunnel(target_uuid.clone(), tunnel).await;
        println!("[DEBUG] Added tunnel to tunnels map");

        let packet = TransportPacket {
            act: "accept_connection".to_string(),
            to: Some(target_uuid.clone()),
            data: Some(TransportData::PeerWaitConnection(net_info)),
            protocol: Protocol::STUN,
            uuid: my_key.clone(),
            nodes: vec![],
        };

        println!("[DEBUG] Sending accept_connection packet: {:?}", packet);

        server_conn
            .send_packet(packet)
            .await
            .map_err(|e| e.to_string())
    }

    pub async fn receive_accept_connection(
        &self,
        packet: TransportPacket,
        my_key: String,
    ) -> Result<(), String> {
        println!("[DEBUG] Starting receive_accept_connection");
        println!("[DEBUG] Received packet: {:?}", packet);
        println!("[DEBUG] My Key: {}", my_key);

        if let Some(TransportData::PeerWaitConnection(data)) = packet.data {
            let ip = data.public_ip.clone();
            let port = data.public_port;
            println!("[DEBUG] Target IP: {}, Port: {}", ip, port);

            let tunnel_opt = self.get_tunnel(packet.uuid.clone()).await;
            println!("[DEBUG] Got tunnel for UUID {}: {:?}", packet.uuid, tunnel_opt.is_some());

            if let Some(tunnel_arc) = tunnel_opt {
                println!("[DEBUG] Attempting connection to {}:{}", ip, port);
                
                let mut tunnel_guard = tunnel_arc.lock().await;
                
                match tunnel_guard.make_connection(&ip, port, 3).await {
                    Ok(()) => {
                        tunnel_guard.backlife_cycle(3);
                        drop(tunnel_guard);
                        println!("[DEBUG] Successfully established connection");
                        Ok(())
                    }
                    Err(e) => {
                        println!("[DEBUG] Connection failed: {}", e);
                        Err("[STUN] Fail connection".to_string())
                    }
                }
            } else {
                println!("[DEBUG] No tunnel found for UUID: {}", packet.uuid);
                Err("[STUN] error get tunnel".to_string())
            }
        } else {
            println!("[DEBUG] Invalid packet data format");
            Err("[STUN] Invalid accept_connection packet".to_string())
        }
    }
}


=== ../src\manager\types.rs ===
#[derive(Debug, Clone)]
pub struct ConnectionTurnStatus {
    pub connected: bool,
    pub turn_connection: bool,
}

pub enum ConnectionType {
    Signal(String),
    Stun,
}

#[derive(Debug, Clone)]
pub struct PeerOpenNetInfo {
    pub ip: String,
    pub port: u16,
}


=== ../src\packets\mod.rs ===
pub mod packets;
pub use packets::*;

=== ../src\packets\packets.rs ===
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerInfo {
    pub peer_id: String,
    pub is_signal_server: bool,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerWaitConnection {
    pub connect_peer_id: String,
    pub public_ip: String,
    pub public_port: u16
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileSaved {
    pub filename: String,
    pub token: String,
    pub token_hash: Option<String>,
    pub storage_peer_key: String,
    pub owner_key: String,
    pub hash_file: String,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
    pub public: bool,
    pub size: u64,
    pub mime: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileGet {
    pub peer_id: String,
    pub file_hash: String,
    pub token: Option<String>,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerUploadFile {
    pub peer_id: String,
    pub file_hash: String,
    pub filename: String,
    pub contents: String,
    pub token: String,
    pub mime: String,
    pub public: bool,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct SyncPeerInfo {
    pub uuid: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct SyncPeerInfoData {
    pub peers: Vec<SyncPeerInfo>,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone, PartialEq)]
pub enum Protocol {
    TURN,
    STUN,
    SIGNAL,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub enum Status {
    ERROR,
    SUCCESS,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct Message {
    pub text: String,
    pub nonce: Option<String>,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct ProxyMessage {
    pub text: String,
    pub nonce: String,
    pub from_peer_id: String,
    pub end_peer_id: String,
    pub request_id: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct FileData {
    pub filename: String,
    pub contents: String,
    pub peer_id: String,
    pub hash_file: String,
    pub encrypted: bool,
    pub compressed: bool,
    pub public: bool,
    pub auto_decompress: bool,
}


#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StunSyncPubAddr {
    pub public_addr: String
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageValidTokenRequest {
    pub token: String,
    pub peer_id: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageValidTokenResponse {
    pub peer_id: String,
    pub status: bool,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageReservationRequest {
    pub peer_id: String,
    pub size_in_bytes: u64,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageToken {
    pub file_size: u64,                  // Размер файла
    pub storage_provider: String,      // Паблик-ключ (или крипто-адрес) хранителя
    pub timestamp: u64,                  // Unix-время создания токена
    pub signature: Vec<u8>,              // Подпись хранителя, подтверждающая согласие
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct StorageReservationResponse {
    pub peer_id: String,
    pub token: String,  // base64 encoded StorageToken
    pub size_in_bytes: u64,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct PeerSearchRequest {
    pub search_id: String, // id поиска
    pub peer_id: String, // id пира инициатора поиска
    pub max_hops: u32, // максимальное количество прыжков
    pub path: Vec<SearchPathNode>, // путь поиска от инициатора до текущего узла
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct SearchPathNode {
    pub uuid: String,        // UUID узла
    pub public_ip: String, // Публичный адрес узла
    pub public_port: i64,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct PeerSearchResponse {
    pub search_id: String,     // id поиска
    pub peer_id: String,       // id пира инициатора поиска
    pub found_peer_id: String, // id пира найденного
    pub public_ip: String,   // публичный адрес ноды пира
    pub public_port: i64,
    pub hops: u32,            // количество прыжков
    pub path: Vec<SearchPathNode>, // путь поиска от инициатора до нашедшего пира
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct SignalServerInfo {
    pub public_key: String,
    pub public_ip: String,
    pub port: i64,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileMove {
    pub file_hash: String,
    pub peer_id: String,
    pub token: String,
    pub new_path: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct GetFragmentsMetadata {
    pub token_hash: String,
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub enum TransportData {
    Message(Message),
    ProxyMessage(ProxyMessage),
    PeerInfo(PeerInfo),
    PeerWaitConnection(PeerWaitConnection),
    PeerFileGet(PeerFileGet),
    PeerUploadFile(PeerUploadFile),
    SyncPeerInfoData(SyncPeerInfoData),
    StorageReservationRequest(StorageReservationRequest),
    StorageReservationResponse(StorageReservationResponse),
    StorageValidTokenRequest(StorageValidTokenRequest),
    StorageValidTokenResponse(StorageValidTokenResponse),
    PeerFileSaved(PeerFileSaved),
    StunSyncPubAddr(StunSyncPubAddr),
    FileData(FileData),
    PeerSearchRequest(PeerSearchRequest),
    PeerSearchResponse(PeerSearchResponse),
    SignalServerInfo(SignalServerInfo),
    PeerFileAccessChange(PeerFileAccessChange),
    PeerFileDelete(PeerFileDelete),
    PeerFileMove(PeerFileMove),
    FragmentMetadataSync(FragmentMetadataSync),
    GetFragmentsMetadata(GetFragmentsMetadata),
}

#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
pub struct TransportPacket {
    pub act: String,         //info, answer, wait_connection,
    pub to: Option<String>,  //кому отправляем данный пакет
    pub data: Option<TransportData>,
    pub protocol: Protocol,     // TURN, STUN, SIGNAL
    pub uuid: String,
    pub nodes: Vec<SearchPathNode>, // ноды через которых прошел пакет
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct EncryptedData {
    pub content: Vec<u8>,
    pub nonce: [u8; 12],
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileAccessChange {
    pub file_hash: String,
    pub public: bool,
    pub peer_id: String,
    pub token: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PeerFileDelete {
    pub file_hash: String,
    pub peer_id: String,
    pub token: String,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct FragmentMetadata {
    pub file_hash: String,
    pub mime: String,
    pub public: bool,
    pub encrypted: bool,
    pub compressed: bool,
    pub auto_decompress: bool,
    pub owner_key: String,
    pub storage_peer_key: String,
    pub size: u64,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct FragmentMetadataSync {
    pub fragments: Vec<FragmentMetadata>,
    pub peer_id: String,
}

impl std::fmt::Display for TransportPacket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TransportPacket {{ act: {}, to: {:?}, protocol: {:?}, uuid: {} }}",
            self.act, self.to, self.protocol, format!("{:?}...{:?}", &self.uuid[0..5], &self.uuid[30..])
        )
    }
}

=== ../src\peer\mod.rs ===
mod turn;
pub mod peer;
pub mod peer_api;
mod types;

pub use turn::turn_tunnel;
pub use peer::Peer;
pub use types::ConnectionTurnStatus;

=== ../src\peer\peer.rs ===
use colored::*;
use std::sync::Arc;

use crate::config::Config;
use crate::connection::Connection;
use crate::manager::ConnectionManager::ConnectionManager;
use crate::db::P2PDatabase;

pub struct Peer {
    connection_manager: Arc<ConnectionManager>,
    connection: Arc<Connection>,
    db: Arc<P2PDatabase>,
}

impl Peer {
    pub async fn new(config: &Config, db: &P2PDatabase) -> Self {
        let connection_manager = Arc::new(ConnectionManager::new(db).await);

        let connection = Arc::new(
            Connection::new(
                config.signal_server_ip.clone(),
                config.signal_server_port,
                db,
            )
            .await,
        );

        connection_manager
            .add_connection(
                format!("{}:{}", config.signal_server_ip, config.signal_server_port),
                connection.clone(),
            )
            .await;

        Peer {
            connection_manager,
            connection,
            db: Arc::new(db.clone()),
        }
    }

    pub async fn run(&self) {
        let peer_id = self.db.get_or_create_peer_id().unwrap();
        println!("{}", format!("[Peer] Your UUID: {}", peer_id).yellow());

        println!("[Peer] Starting peer...");

        self.connection_manager.handle_incoming_packets().await;
    }
}


=== ../src\peer\peer_api.rs ===
use crate::connection::Connection;
use crate::crypto::token::get_metadata_from_token;
use crate::db::P2PDatabase;
use crate::manager::ConnectionManager::ConnectionManager;
use crate::packets::{
    EncryptedData, FragmentMetadata, FragmentMetadataSync, GetFragmentsMetadata, Message, PeerFileAccessChange, PeerFileDelete, PeerFileGet, PeerFileMove, PeerSearchRequest, PeerUploadFile, PeerWaitConnection, Protocol, SearchPathNode, StorageReservationRequest, StorageValidTokenRequest, TransportData, TransportPacket
};
use crate::tunnel::Tunnel;
use colored::Colorize;
use hex;
use mime_guess;
use sha2::{Digest, Sha256};
use std::sync::Arc;

use flate2::write::GzEncoder;
use flate2::Compression;
use std::io;
use std::io::Write;
use std::path::Path;

#[derive(Debug)]
pub enum UploadError {
    FileNotFound(String),
    NoTokensAvailable,
    InsufficientSpace { required: u64, available: u64 },
    DatabaseError(String),
    IoError(String),
}

impl std::fmt::Display for UploadError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UploadError::FileNotFound(path) => write!(f, "Файл не найден: {}", path),
            UploadError::NoTokensAvailable => write!(f, "Нет доступных токенов для загрузки. Используйте команду reserve для получения нового токена."),
            UploadError::InsufficientSpace { required, available } => write!(
                f,
                "Недостаточно места для загрузки файла. Требуется: {} байт, Доступно: {} байт. Используйте команду reserve для получения дополнительного места.",
                required, available
            ),
            UploadError::DatabaseError(e) => write!(f, "Ошибка базы данных: {}", e),
            UploadError::IoError(e) => write!(f, "Ошибка ввода/вывода: {}", e),
        }
    }
}

impl std::error::Error for UploadError {}

#[derive(Clone)]
pub struct PeerAPI {
    connection: Arc<Connection>,
    db: Arc<P2PDatabase>,
    manager: Arc<ConnectionManager>,
}

impl PeerAPI {
    pub fn new(connection: Arc<Connection>, db: &P2PDatabase, manager: &ConnectionManager) -> Self {
        PeerAPI {
            connection,
            db: Arc::new(db.clone()),
            manager: Arc::new(manager.clone()),
        }
    }

    pub async fn get_file(&self, identifier: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files
            .iter()
            .find(|f| f.filename == identifier || f.file_hash == identifier);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", identifier));
        }
        let file = file.unwrap();
        let token = file.token.clone();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "get_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileGet(PeerFileGet {
                token: Some(token),
                peer_id: my_peer_id.clone(),
                file_hash: file.file_hash.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    fn clean_file_path(path: &str, root_dir: &str) -> String {
        let path = Path::new(path);
        let root = Path::new(root_dir);

        if let Ok(relative) = path.strip_prefix(root) {
            relative.to_string_lossy().replace('\\', "/")
        } else {
            path.file_name()
                .unwrap_or_else(|| path.as_os_str())
                .to_string_lossy()
                .to_string()
        }
    }

    pub async fn upload_file(
        &self,
        file_path: String,
        encrypt: bool,
        public: bool,
        auto_decompress: bool,
        root_dir: &str,
    ) -> Result<(), UploadError> {
        println!("Uploading file: {}", file_path);
        let file_size = tokio::fs::metadata(&file_path)
            .await
            .map_err(|e| UploadError::FileNotFound(e.to_string()))?
            .len();

        println!("File size: {}", file_size);

        let (owner_peer_id, token_info) = self
            .db
            .get_best_token(file_size)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?
            .ok_or(UploadError::NoTokensAvailable)?;

        // Проверяем занятое место в токене
        let used_space = self
            .db
            .get_token_used_space(&owner_peer_id)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        if used_space + file_size > token_info.free_space {
            return Err(UploadError::InsufficientSpace {
                required: file_size,
                available: token_info.free_space - used_space,
            });
        }

        println!("Owner peer id: {}", owner_peer_id);
        println!("Token info: {}", token_info.token);
        println!("Used space: {} / {}", used_space, token_info.free_space);

        let metadata = get_metadata_from_token(token_info.token.clone()).await;

        let token_provider = metadata.unwrap().storage_provider;

        if !self
            .manager
            .have_connection_with_peer(token_provider.clone())
            .await
        {
            self.connect_to_peer(token_provider.clone())
                .await
                .map_err(|e| UploadError::IoError(format!("Failed to connect to peer: {}", e)))?;

            let mut attempts = 0;
            let max_attempts = 30;

            while attempts < max_attempts {
                if self
                    .manager
                    .have_connection_with_peer(token_provider.clone())
                    .await
                {
                    break;
                }
                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                attempts += 1;
            }

            if attempts >= max_attempts {
                return Err(UploadError::IoError(
                    "Failed to establish connection with peer".to_string(),
                ));
            }
        }

        // ⏬ Сжатие файла
        let contents = tokio::fs::read(&file_path)
            .await
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
        encoder
            .write_all(&contents)
            .map_err(|e| UploadError::IoError(e.to_string()))?;
        let compressed_contents = encoder
            .finish()
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        println!("Compressed size: {}", compressed_contents.len());

        let (final_content, encrypted) = if encrypt {
            // ⏬ Шифрование файла
            let encrypted_contents = self
                .db
                .encrypt_data(&compressed_contents)
                .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

            let content = serde_json::to_string(&EncryptedData {
                nonce: encrypted_contents.1,
                content: encrypted_contents.0,
            })
            .unwrap();
            (base64::encode(content.to_string().as_bytes()), true)
        } else {
            (base64::encode(compressed_contents), false)
        };

        let my_peer_id = self
            .db
            .get_or_create_peer_id()
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        let file_hash = hex::encode(Sha256::digest(final_content.to_string().as_bytes()));
        let mime = mime_guess::from_path(file_path.clone()).first_or_text_plain();

        let packet = TransportPacket {
            act: "save_file".to_string(),
            to: Some(token_provider),
            data: Some(TransportData::PeerUploadFile(PeerUploadFile {
                filename: Self::clean_file_path(&file_path, root_dir),
                contents: final_content,
                peer_id: my_peer_id.clone(),
                token: token_info.token,
                file_hash: file_hash,
                mime: mime.to_string(),
                public,
                encrypted,
                compressed: true,
                auto_decompress,
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection
            .send_packet(packet)
            .await
            .map_err(|e| UploadError::IoError(e.to_string()))?;

        // Обновляем использованное место в токене
        self.db
            .update_token_used_space(&owner_peer_id, used_space + file_size)
            .map_err(|e| UploadError::DatabaseError(e.to_string()))?;

        Ok(())
    }

    pub async fn upload_file_default(&self, file_path: String) -> Result<(), UploadError> {
        self.upload_file(file_path, true, false, false, "").await
    }

    pub async fn send_message(&self, peer_id: String, message: String) -> Result<(), String> {
        let packet = TransportPacket {
            act: "message".to_string(),
            to: Some(peer_id),
            data: Some(TransportData::Message(Message {
                text: message,
                nonce: None,
            })),
            protocol: Protocol::TURN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn connect_to_peer(&self, peer_id: String) -> Result<(), String> {
        let tunnel = Tunnel::new().await;
        let tunnel_ip = tunnel.public_ip.clone();
        let tunnel_port = tunnel.public_port.clone();
        self.manager.add_tunnel(peer_id.to_string(), tunnel).await;
        let packet = TransportPacket {
            act: "wait_connection".to_string(),
            to: None,
            data: Some(TransportData::PeerWaitConnection(PeerWaitConnection {
                connect_peer_id: peer_id,
                public_port: tunnel_port,
                public_ip: tunnel_ip,
            })),
            protocol: Protocol::STUN,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn request_peer_list(&self) -> Result<(), String> {
        let packet = TransportPacket {
            act: "peer_list".to_string(),
            to: None,
            data: None,
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };
        println!("{}", format!("[Peer] Sending peer list to signal server"));
        self.connection.send_packet(packet).await
    }

    pub async fn reserve_storage(&self, size_in_bytes: u64) -> Result<(), String> {
        let packet = TransportPacket {
            act: "reserve_storage".to_string(),
            to: None,
            data: Some(TransportData::StorageReservationRequest(
                StorageReservationRequest {
                    peer_id: self.db.get_or_create_peer_id().unwrap(),
                    size_in_bytes,
                },
            )),
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn valid_token(&self, token: String) -> Result<(), String> {
        let metadata = get_metadata_from_token(token.clone().to_string()).await;

        if let Ok(metadata) = metadata {
            let packet = TransportPacket {
                act: "valid_token".to_string(),
                to: Some(metadata.storage_provider),
                data: Some(TransportData::StorageValidTokenRequest(
                    StorageValidTokenRequest {
                        token: token.clone(),
                        peer_id: self.db.get_or_create_peer_id().unwrap(),
                    },
                )),
                protocol: Protocol::SIGNAL,
                uuid: self.db.get_or_create_peer_id().unwrap(),
                nodes: vec![],
            };

            self.connection.send_packet(packet).await
        } else {
            Err("Invalid token".to_string())
        }
    }

    pub async fn search_peer(&self, peer_id: String) -> Result<(), String> {
        let packet = TransportPacket {
            act: "search_peer".to_string(),
            to: None,
            data: Some(TransportData::PeerSearchRequest(PeerSearchRequest {
                peer_id: self.db.get_or_create_peer_id().unwrap(),
                search_id: peer_id,
                max_hops: 3,
                path: vec![SearchPathNode {
                    uuid: self.db.get_or_create_peer_id().unwrap(),
                    public_ip: self.connection.ip.clone(),
                    public_port: self.connection.port.clone(),
                }],
            })),
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn change_file_public_access(
        &self,
        file_hash: String,
        public: bool,
    ) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "change_file_access".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileAccessChange(PeerFileAccessChange {
                file_hash,
                public,
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn delete_file(&self, file_hash: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        let packet = TransportPacket {
            act: "delete_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileDelete(PeerFileDelete {
                file_hash,
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn move_file(&self, file_hash: String, new_path: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let files = self.db.get_my_fragments().unwrap();

        let file = files.iter().find(|f| f.file_hash == file_hash);

        if file.is_none() {
            return Err(format!("Файл не найден: {}", file_hash));
        }
        let file = file.unwrap();
        let uuid_peer = file.storage_peer_key.clone();

        // Получаем имя файла из текущего пути
        let current_filename = std::path::Path::new(&file.filename)
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or(&file.filename);

        // Формируем новый путь с сохранением имени файла
        let new_path = if new_path.ends_with('/') || new_path.ends_with('\\') {
            format!("{}{}", new_path, current_filename)
        } else {
            format!("{}/{}", new_path, current_filename)
        };

        let packet = TransportPacket {
            act: "move_file".to_string(),
            to: Some(uuid_peer),
            data: Some(TransportData::PeerFileMove(PeerFileMove {
                file_hash: file_hash.clone(),
                new_path: new_path.clone(),
                token: file.token.clone(),
                peer_id: my_peer_id.clone(),
            })),
            protocol: Protocol::TURN,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await?;

        self.db
            .update_fragment_path(&file_hash, &new_path)
            .map_err(|e| format!("Ошибка при обновлении метаданных: {}", e))?;

        Ok(())
    }

    pub async fn virtual_storage(&self) -> Result<(), String> {
        let files = self
            .db
            .get_my_fragments()
            .map_err(|e| format!("Ошибка при получении списка файлов: {}", e))?;

        // Создаем структуру для хранения файлов по путям
        let mut file_tree: std::collections::HashMap<String, Vec<(String, String)>> =
            std::collections::HashMap::new();

        for file in files {
            let path = std::path::Path::new(&file.filename);
            let parent = path.parent().and_then(|p| p.to_str()).unwrap_or("/");

            file_tree
                .entry(parent.to_string())
                .or_insert_with(Vec::new)
                .push((
                    path.file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or(&file.filename)
                        .to_string(),
                    file.file_hash,
                ));
        }

        // Выводим дерево файлов
        println!(
            "\n{}",
            "╔════════════════════════════════════════════════════════════╗".cyan()
        );
        println!(
            "{}",
            "║                    ВИРТУАЛЬНОЕ ХРАНИЛИЩЕ                   ║".cyan()
        );
        println!(
            "{}",
            "╠════════════════════════════════════════════════════════════╣".cyan()
        );

        for (path, files) in file_tree.iter() {
            println!("{}", format!("║ 📁 {}", path).cyan());
            for (filename, hash) in files {
                println!("{}", format!("║   └─ {} ({})", filename, hash).white());
            }
        }

        println!(
            "{}",
            "╚════════════════════════════════════════════════════════════╝".cyan()
        );
        println!("\n{}", "Доступные команды:".yellow());
        println!(
            "{}",
            "  • move <hash> <new_path> - переместить файл".white()
        );
        println!("{}", "  • delete <hash> - удалить файл".white());
        println!("{}", "  • public <hash> - сделать файл публичным".white());
        println!("{}", "  • private <hash> - сделать файл приватным".white());
        println!("{}", "  • exit - выйти из виртуального хранилища".white());

        Ok(())
    }

    pub async fn virtual_storage_interactive(&self) -> Result<(), String> {
        use std::io::{self, Write};

        loop {
            // Показываем текущее состояние хранилища
            self.virtual_storage().await?;

            print!("\n{}", "virtual_storage> ".green());
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut input = String::new();
            io::stdin()
                .read_line(&mut input)
                .map_err(|e| e.to_string())?;
            let input = input.trim();

            if input == "exit" {
                break;
            }

            let parts: Vec<&str> = input.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }

            match parts[0] {
                "move" => {
                    if parts.len() != 3 {
                        println!("{}", "Использование: move <hash> <new_path>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .move_file(parts[1].to_string(), parts[2].to_string())
                        .await
                    {
                        println!("{}", format!("Ошибка при перемещении файла: {}", e).red());
                    } else {
                        println!("{}", "Файл успешно перемещен".green());
                    }
                }
                "delete" => {
                    if parts.len() != 2 {
                        println!("{}", "Использование: delete <hash>".red());
                        continue;
                    }
                    if let Err(e) = self.delete_file(parts[1].to_string()).await {
                        println!("{}", format!("Ошибка при удалении файла: {}", e).red());
                    } else {
                        println!("{}", "Файл успешно удален".green());
                    }
                }
                "public" => {
                    if parts.len() != 2 {
                        println!("{}", "Использование: public <hash>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .change_file_public_access(parts[1].to_string(), true)
                        .await
                    {
                        println!("{}", format!("Ошибка при изменении доступа: {}", e).red());
                    } else {
                        println!("{}", "Файл сделан публичным".green());
                    }
                }
                "private" => {
                    if parts.len() != 2 {
                        println!("{}", "Использование: private <hash>".red());
                        continue;
                    }
                    if let Err(e) = self
                        .change_file_public_access(parts[1].to_string(), false)
                        .await
                    {
                        println!("{}", format!("Ошибка при изменении доступа: {}", e).red());
                    } else {
                        println!("{}", "Файл сделан приватным".green());
                    }
                }
                _ => {
                    println!(
                        "{}",
                        "Неизвестная команда. Используйте help для списка команд.".red()
                    );
                }
            }
        }

        Ok(())
    }

    fn collect_files_recursively(
        &self,
        dir_path: &std::path::Path,
        files: &mut Vec<String>,
    ) -> Result<(), UploadError> {
        for entry in std::fs::read_dir(dir_path).map_err(|e| UploadError::IoError(e.to_string()))? {
            let entry = entry.map_err(|e| UploadError::IoError(e.to_string()))?;
            let path = entry.path();

            if path.is_file() {
                files.push(path.to_string_lossy().to_string());
            } else if path.is_dir() {
                self.collect_files_recursively(&path, files)?;
            }
        }
        Ok(())
    }

    pub async fn upload_directory(
        &self,
        dir_path: String,
        encrypt: bool,
        public: bool,
        auto_decompress: bool,
    ) -> Result<(), UploadError> {
        let path = std::path::Path::new(&dir_path);
        if !path.is_dir() {
            return Err(UploadError::FileNotFound(
                "Указанный путь не является директорией".to_string(),
            ));
        }

        let mut files = Vec::new();
        self.collect_files_recursively(path, &mut files)?;

        if files.is_empty() {
            return Err(UploadError::FileNotFound("Директория пуста".to_string()));
        }

        println!(
            "{}",
            format!("Найдено файлов для загрузки: {}", files.len()).cyan()
        );

        for (i, file) in files.iter().enumerate() {
            println!(
                "{}",
                format!("Загрузка файла {}/{}: {}", i + 1, files.len(), file).yellow()
            );
            if let Err(e) = self
                .upload_file(file.clone(), encrypt, public, auto_decompress, &dir_path)
                .await
            {
                println!(
                    "{}",
                    format!("Ошибка при загрузке файла {}: {}", file, e).red()
                );
            } else {
                println!("{}", format!("Файл {} успешно загружен", file).green());
            }
        }

        Ok(())
    }

    pub async fn get_fragments_metadata(&self, token_hash: String) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let packet = TransportPacket {
            act: "get_fragments_metadata".to_string(),
            to: None,
            data: Some(TransportData::GetFragmentsMetadata(GetFragmentsMetadata {
                token_hash,
            })),
            protocol: Protocol::SIGNAL,
            uuid: my_peer_id,
            nodes: vec![],
        };

        self.connection.send_packet(packet).await
    }

    pub async fn sync_fragment_metadata(&self) -> Result<(), String> {
        let my_peer_id = self.db.get_or_create_peer_id().unwrap();
        let fragments = self
            .db
            .get_my_fragments()
            .map_err(|e| format!("Ошибка при получении фрагментов: {}", e))?;

        let metadata_fragments: Vec<FragmentMetadata> = fragments
            .into_iter()
            .map(|f| FragmentMetadata {
                file_hash: f.file_hash,
                mime: f.mime,
                public: f.public,
                encrypted: f.encrypted,
                compressed: f.compressed,
                auto_decompress: f.auto_decompress,
                owner_key: f.owner_key,
                storage_peer_key: f.storage_peer_key,
                size: f.size,
            })
            .collect();

        let sync_data = FragmentMetadataSync {
            fragments: metadata_fragments,
            peer_id: my_peer_id.clone(),
        };

        let packet = TransportPacket {
            act: "sync_fragments".to_string(),
            to: None,
            data: Some(TransportData::FragmentMetadataSync(sync_data)),
            protocol: Protocol::SIGNAL,
            uuid: my_peer_id,
            nodes: vec![],
        };

        println!(
            "{}",
            "[Peer] Отправка метаданных фрагментов на сигнальную ноду".cyan()
        );
        self.connection.send_packet(packet).await
    }
}


=== ../src\peer\turn.rs ===
use anyhow::Result;
use colored::*;

use crate::connection::Connection;
use crate::packets::{Protocol, TransportPacket};
use crate::db::P2PDatabase;

pub async fn turn_tunnel(
    packet: TransportPacket,
    signal: &Connection,
    db: &P2PDatabase,
) -> Result<String, String> {

    println!(
        "{}",
        format!("[TURN] Turn tunnel creating, sending packets.. {}", packet.act).yellow()
    );
    if packet.act == "wait_connection" {
        let packet_hello = TransportPacket {
            act: "try_turn_connection".to_string(),
            to: Some(packet.uuid.clone().to_string()),
            data: None,
            protocol: Protocol::TURN,
            uuid: db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };
        let result = signal.send_packet(packet_hello).await;
        println!(
            "{}",
            format!("[TURN] [try_turn_connection] Result sending socket {:?}", result).yellow()
        );
        match result {
            Ok(_) => {
                return Ok("send_wait_connection".to_string());
            }
            Err(e) => {
                return Err(e);
            }
        }
    } else if packet.act == "accept_connection" || packet.act == "try_turn_connection" {
        let packet_hello = TransportPacket {
            act: "accept_connection".to_string(),
            to: Some(packet.uuid.to_string()),
            data: None,
            protocol: Protocol::TURN,
            uuid: db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };
        println!("{}", "[TURN] [accept_connection] Sending accept connection".yellow());
        let result = signal.send_packet(packet_hello).await;
        match result {
            Ok(_) => {
                return Ok("successful_connection".to_string());
            }
            Err(e) => {
                return Err(e);
            }
        }
    }
    return Err("[TURN] Peer didn't give the connection agreement".to_string());
}


=== ../src\peer\types.rs ===
#[derive(Debug, Clone)]
pub struct ConnectionTurnStatus {
    pub connected: bool,
    pub turn_connection: bool,
} 

=== ../src\signal\client.rs ===
use crate::db::P2PDatabase;
use crate::packets::{PeerInfo, Protocol, TransportData, TransportPacket};
use anyhow::Result;
use std::sync::Arc;
use tokio::io::{split, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::{mpsc, RwLock};

#[derive(Debug)]
struct Peer {
    socket: Arc<RwLock<TcpStream>>,
    info: String,
}

type PeersSender = mpsc::Sender<Peer>;
type PeersReceiver = mpsc::Receiver<Peer>;

#[derive(Debug)]
pub struct SignalClient {
    writer: Option<Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>>,
    reader: Option<Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>>,
    db: Arc<P2PDatabase>,
    message_tx: mpsc::Sender<TransportPacket>,
    message_rx: Option<mpsc::Receiver<TransportPacket>>,
    pub signal_server_ip: String,
    pub signal_server_port: u16,
    pub public_key: String,
}

impl SignalClient {
    pub fn new(db: &P2PDatabase) -> Self {
        let (message_tx, message_rx) = mpsc::channel(100);
        SignalClient {
            writer: None,
            reader: None,
            db: Arc::new(db.clone()),
            message_tx,
            message_rx: Some(message_rx),
            signal_server_ip: "".to_string(),
            signal_server_port: 0,
            public_key: "".to_string(),
        }
    }

    pub fn get_message_receiver(&mut self) -> Option<mpsc::Receiver<TransportPacket>> {
        self.message_rx.take()
    }

    pub async fn connect(
        &mut self,
        signal_server_ip: &str,
        signal_server_port: i64,
        public_ip: &str,
        public_port: u16,
        public_key: &str,
    ) -> Result<(), String> {
        println!(
            "[SignalClient] Connecting to signal server {}:{}",
            signal_server_ip, signal_server_port
        );

        self.signal_server_ip = signal_server_ip.to_string();
        self.signal_server_port = signal_server_port as u16;
        self.public_key = public_key.to_string();
        match TcpStream::connect(format!("{}:{}", signal_server_ip, signal_server_port)).await {
            Ok(socket) => {
                let (reader, writer) = split(socket);
                self.writer = Some(Arc::new(RwLock::new(writer)));
                self.reader = Some(Arc::new(RwLock::new(reader)));

                // Запускаем обработчик входящих сообщений
                let reader = self.reader.as_ref().unwrap().clone();
                let db = self.db.clone();
                let message_tx = self.message_tx.clone();
                tokio::spawn(async move {
                    let mut buffer = [0; 1024];
                    loop {
                        let mut reader_guard = reader.write().await;
                        
                        // Читаем длину сообщения (4 байта)
                        let mut len_bytes = [0u8; 4];
                        match reader_guard.read_exact(&mut len_bytes).await {
                            Ok(_) => {
                                let message_len = u32::from_be_bytes(len_bytes) as usize;
                                
                                // Читаем само сообщение
                                let mut message_bytes = vec![0u8; message_len];
                                match reader_guard.read_exact(&mut message_bytes).await {
                                    Ok(_) => {
                                        let message = String::from_utf8_lossy(&message_bytes);
                                        println!("[SignalClient] Received message: {}", message);
                                        if let Ok(packet) = serde_json::from_str::<TransportPacket>(&message) {
                                            println!("[SignalClient] Parsed packet: {:?}", packet);
                                            
                                            // Отправляем пакет в канал для обработки
                                            if let Err(e) = message_tx.send(packet).await {
                                                println!("[SignalClient] Failed to send packet to handler: {}", e);
                                                break;
                                            }
                                        } else {
                                            println!("[SignalClient] Failed to parse packet: {}", message);
                                        }
                                    }
                                    Err(e) => {
                                        println!("[SignalClient] Error reading message: {}", e);
                                        break;
                                    }
                                }
                            }
                            Err(e) => {
                                if e.kind() == std::io::ErrorKind::ConnectionReset {
                                    println!("[SignalClient] Connection closed by server");
                                    break;
                                }
                                println!("[SignalClient] Error reading message length: {}", e);
                                break;
                            }
                        }
                    }
                });

                // Отправляем начальный пакет
                let connect_packet = TransportPacket {
                    act: "info".to_string(),
                    to: None,
                    data: Some(TransportData::PeerInfo(PeerInfo {
                        peer_id: self.db.get_or_create_peer_id().unwrap(),
                        is_signal_server: true,
                    })),
                    protocol: Protocol::SIGNAL,
                    uuid: self.db.get_or_create_peer_id().unwrap(),
                    nodes: vec![],
                };

                self.send_packet(connect_packet).await?;

                Ok(())
            }
            Err(e) => {
                println!("[SignalClient] Failed to connect to signal server: {}", e);
                Err(e.to_string())
            }
        }
    }

    pub async fn send_packet(&self, packet: TransportPacket) -> Result<(), String> {
        let string_packet = serde_json::to_string(&packet).unwrap();
        let message_len = string_packet.len() as u32;
        let len_bytes = message_len.to_be_bytes();

        if let Some(writer) = &self.writer {
            println!(
                "[SignalClient] Sending packet to signal server: {}",
                string_packet
            );

            let mut writer_guard = writer.write().await;
            
            // Отправляем длину сообщения
            match writer_guard.write_all(&len_bytes).await {
                Ok(_) => {
                    // Отправляем само сообщение
                    match writer_guard.write_all(string_packet.as_bytes()).await {
                        Ok(_) => {
                            println!("[SignalClient] Successfully sent packet");
                            Ok(())
                        }
                        Err(e) => {
                            println!("[SignalClient] Failed to send packet: {}", e);
                            Err(e.to_string())
                        }
                    }
                }
                Err(e) => {
                    println!("[SignalClient] Failed to send packet length: {}", e);
                    Err(e.to_string())
                }
            }
        } else {
            println!("[SignalClient] Writer is not connected");
            Err("[SignalClient] Writer is not connected".to_string())
        }
    }
}


=== ../src\signal\mod.rs ===
pub mod server;
mod peer;
pub mod peer_search;
mod signal_servers;
pub mod client;

pub use self::server::SignalServer;
pub use self::peer::Peer;

=== ../src\signal\peer.rs ===
use async_std::sync::Mutex;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::io::{split, AsyncReadExt, AsyncWriteExt}; // Добавляем split
use tokio::net::TcpStream;
use tokio::sync::{mpsc, RwLock};

use crate::logger::{self, LOGGER}; // Добавляем mpsc

#[derive(Clone, Debug)]
pub struct InfoPeer {
    pub wait_connection: Arc<RwLock<bool>>,
    pub public_addr: Arc<RwLock<String>>,
    pub local_addr: String,
    pub is_signal_server: Arc<RwLock<bool>>,
    pub uuid: Arc<RwLock<Option<String>>>,
}

#[derive(Debug, Clone)]
pub struct PeerOpenNetInfo {
    pub ip: String,
    pub port: u16,
}

#[derive(Debug, Clone)]
pub struct Peer {
    reader: Arc<RwLock<tokio::io::ReadHalf<TcpStream>>>, // Добавляем reader
    writer: Arc<RwLock<tokio::io::WriteHalf<TcpStream>>>, // Добавляем writer
    pub info: InfoPeer,                                  // Peer information (ip:port)
    tx: mpsc::Sender<String>,                            // Добавляем Sender для отправки сообщений

    open_tunnels: Arc<RwLock<HashMap<String, PeerOpenNetInfo>>>,
}

impl Peer {
    pub fn new(socket: TcpStream, info: Option<InfoPeer>) -> Arc<Self> {
        let mut info = info;

        if info.is_none() {
            info = Some(InfoPeer {
                wait_connection: Arc::new(RwLock::new(false)),
                public_addr: Arc::new(RwLock::new("".to_string())),
                local_addr: socket.peer_addr().unwrap().to_string(),
                uuid: Arc::new(RwLock::new(None)),
                is_signal_server: Arc::new(RwLock::new(false)),
            });
        }

        let open_tunnels = Arc::new(RwLock::new(HashMap::<String, PeerOpenNetInfo>::new()));

        let (reader, writer) = split(socket);
        let reader = Arc::new(RwLock::new(reader));
        let writer = Arc::new(RwLock::new(writer));
        let (tx, _) = mpsc::channel(100); // Оставляем канал для совместимости с существующим кодом

        Arc::new(Self {
            reader,
            writer,
            info: info.unwrap(),
            tx,
            open_tunnels,
        })
    }

    pub async fn send_data(&self, message: &str) {
        let message_len = message.len() as u32;
        let len_bytes = message_len.to_be_bytes();

        let mut writer = self.writer.write().await;

        // Отправляем длину сообщения (4 байта)
        if let Err(e) = writer.write_all(&len_bytes).await {
            LOGGER.debug(&format!(
                "Failed to send message length to peer {}: {}",
                self.info.local_addr, e
            ));
            return;
        }

        // Отправляем само сообщение
        if let Err(e) = writer.write_all(message.as_bytes()).await {
            LOGGER.debug(&format!(
                "Failed to send message to peer {}: {}",
                self.info.local_addr, e
            ));
        } else {
            LOGGER.debug(&format!(
                "[SendData] Message sent to peer {}: {}",
                self.info.local_addr, message
            ));
        }
    }

    pub async fn receive_message(&self) -> Result<String, String> {
        let mut reader = self.reader.write().await;

        // Читаем длину сообщения (4 байта)
        let mut len_bytes = [0u8; 4];
        match reader.read_exact(&mut len_bytes).await {
            Ok(_) => {}
            Err(e) => {
                if e.kind() == std::io::ErrorKind::ConnectionReset {
                    LOGGER.debug(&format!("Peer {} disconnected", self.info.local_addr));
                    return Err("Peer disconnected".to_string());
                }
                LOGGER.debug(&format!(
                    "Error reading message length from peer {}: {}",
                    self.info.local_addr, e
                ));
                return Err(e.to_string());
            }
        }

        let message_len = u32::from_be_bytes(len_bytes) as usize;

        // Читаем само сообщение
        let mut message_bytes = vec![0u8; message_len];
        match reader.read_exact(&mut message_bytes).await {
            Ok(_) => {}
            Err(e) => {
                LOGGER.debug(&format!(
                    "Error reading message from peer {}: {}",
                    self.info.local_addr, e
                ));
                return Err(e.to_string());
            }
        }

        match String::from_utf8(message_bytes) {
            Ok(message) => Ok(message),
            Err(e) => {
                LOGGER.debug(&format!(
                    "Error converting message to string from peer {}: {}",
                    self.info.local_addr, e
                ));
                Err(e.to_string())
            }
        }
    }

    pub async fn is_signal_server(&self) -> bool {
        self.info.is_signal_server.read().await.clone()
    }

    pub async fn set_is_signal_server(&self, is_signal_server: bool) {
        let mut guard = self.info.is_signal_server.write().await;
        *guard = is_signal_server;
    }

    pub async fn add_open_tunnel(&self, peer_id: &str, ip: String, port: u16) {
        let mut open_tunnels = self.open_tunnels.write().await;
        open_tunnels.insert(peer_id.to_string(), PeerOpenNetInfo { ip, port });
    }

    pub async fn get_open_tunnel(&self, peer_id: &str) -> Option<PeerOpenNetInfo> {
        let open_tunnels = self.open_tunnels.read().await;
        open_tunnels.get(peer_id).cloned()
    }

    pub async fn get_key(&self) -> Option<String> {
        return self.info.uuid.read().await.clone();
    }

    pub async fn set_wait_connection(&self, wait_connection_new: bool) {
        let mut wait_connection = self.info.wait_connection.write().await;
        *wait_connection = wait_connection_new;
    }

    pub async fn set_public_addr(&self, public_addr: String) {
        let mut public_addr_now = self.info.public_addr.write().await;
        *public_addr_now = public_addr;
    }

    pub async fn set_uuid(&self, uuid: String) {
        let mut current_uuid = self.info.uuid.write().await;
        *current_uuid = Some(uuid);
    }

    pub async fn send(&self, packet: String) -> Result<(), String> {
        self.send_data(&packet).await;
        Ok(())
    }

    pub async fn receive(&self) -> Result<String, String> {
        self.receive_message().await
    }
}


=== ../src\signal\peer_search.rs ===
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{mpsc, RwLock};
use uuid::Uuid;

use crate::packets::{
    PeerInfo, PeerSearchRequest, PeerSearchResponse, Protocol, SearchPathNode, TransportData, TransportPacket,
};
use crate::signal::client::SignalClient;

use super::{peer, Peer};

#[derive(Debug)]
struct SearchCache {
    found_peer_id: String,
    public_ip: String,
    public_port: i64,
    expires_at: Instant,
}

#[derive(Debug)]
pub struct PeerSearchManager {
    peers: Arc<RwLock<Vec<Arc<Peer>>>>,
    public_key: String,
    public_ip: String,
    public_port: i64,
    connected_servers: Arc<RwLock<Vec<Arc<SignalClient>>>>,
    active_searches: Arc<RwLock<HashMap<String, mpsc::Sender<PeerSearchResponse>>>>,
    search_cache: Arc<RwLock<HashMap<String, SearchCache>>>,
}

impl PeerSearchManager {
    pub fn new(
        public_key: String,
        public_ip: String,
        public_port: i64,
        peers: Arc<RwLock<Vec<Arc<Peer>>>>,
        connected_servers: Arc<RwLock<Vec<Arc<SignalClient>>>>,
    ) -> Arc<Self> {
        Arc::new(Self {
            peers,
            public_key,
            public_ip,
            public_port,
            connected_servers,
            active_searches: Arc::new(RwLock::new(HashMap::new())),
            search_cache: Arc::new(RwLock::new(HashMap::new())),
        })
    }

    pub async fn handle_search_request(&self, request: PeerSearchRequest) -> Result<(), String> {
        let peer_id = request.peer_id.clone(); // id пира инициатора поиска
        let search_id = request.search_id.clone(); // id поиска

        println!(
            "[PeerSearch] Starting search for peer {} (request from {})",
            search_id, peer_id
        );

        // Проверяем кэш
        if let Some(cache) = self.search_cache.read().await.get(&search_id) {
            if cache.expires_at > Instant::now() {
                println!("[PeerSearch] Found peer {} in cache", search_id);
                let mut path = request.path.clone();
                path.push(SearchPathNode {
                    uuid: self.public_key.clone(),
                    public_ip: self.public_ip.clone(),
                    public_port: self.public_port,
                });
                let path_clone = path.clone();
                
                let response = PeerSearchResponse {
                    search_id: search_id.clone(),               // id поиска
                    peer_id: peer_id.clone(),                   // id пира инициатора поиска
                    found_peer_id: cache.found_peer_id.clone(), // id пира найденного
                    public_ip: self.public_ip.clone(),   // публичный адрес ноды пира
                    public_port: self.public_port.clone(),
                    hops: 0,                                    // количество прыжков
                    path,                                       // путь поиска
                };

                // Сначала проверяем локальных пиров
                let peers = self.peers.read().await;
                for peer in peers.iter() {
                    let peer_uuid = peer.info.uuid.read().await;
                    if peer_uuid.as_ref() == Some(&peer_id) {
                        println!("[PeerSearch] Found initiator peer {} locally, sending response directly", peer_id);
                        let packet = TransportPacket {
                            act: "search_response".to_string(),
                            to: Some(peer_id.clone()),
                            data: Some(TransportData::PeerSearchResponse(response)),
                            protocol: Protocol::SIGNAL,
                            uuid: self.public_key.clone(),
                            nodes: path_clone.clone(),
                        };
                        peer.send_data(&serde_json::to_string(&packet).unwrap())
                            .await;
                        println!("[PeerSearch] Sent search response to peer");
                        return Ok(());
                    }
                }
                println!(
                    "[PeerSearch] Initiator peer {} not found locally, forwarding response",
                    peer_id
                );
            }
        }

        let peers = self.peers.read().await;
        println!("[PeerSearch] Checking {} local peers", peers.len());
        for peer in peers.iter() {
            let peer_uuid = peer.info.uuid.read().await;
            if peer_uuid.as_ref() == Some(&search_id) {
                println!("[PeerSearch] Found peer {} locally", search_id);
                let mut path = request.path.clone();
                path.push(SearchPathNode {
                    uuid: self.public_key.clone(),
                    public_ip: self.public_ip.clone(),
                    public_port: self.public_port.clone(),
                });
                let path_clone = path.clone();
                
                let response = PeerSearchResponse {
                    search_id: search_id.clone(),             // id поиска
                    peer_id: peer_id.clone(),                 // id пира инициатора поиска
                    found_peer_id: search_id.clone(),         // id пира найденного
                    public_ip: self.public_ip.clone(), // публичный адрес ноды пира
                    public_port: self.public_port.clone(),
                    hops: 0,                                  // количество прыжков
                    path,                                     // путь поиска
                };

                // Кэшируем результат
                let search_id_clone = search_id.clone();
                let found_peer_id = search_id_clone.clone();
                self.search_cache.write().await.insert(
                    search_id_clone.clone(),
                    SearchCache {
                        found_peer_id,
                        public_ip: self.public_ip.clone(),
                        public_port: self.public_port.clone(),
                        expires_at: Instant::now() + Duration::from_secs(300), // 5 минут
                    },
                );

                // Сначала проверяем локальных пиров
                for initiator_peer in peers.iter() {
                    let initiator_uuid = initiator_peer.info.uuid.read().await;
                    if initiator_uuid.as_ref() == Some(&peer_id) {
                        println!("[PeerSearch] Found initiator peer {} locally, sending response directly", peer_id);
                        let packet = TransportPacket {
                            act: "search_response".to_string(),
                            to: Some(peer_id.clone()),
                            data: Some(TransportData::PeerSearchResponse(response)),
                            protocol: Protocol::SIGNAL,
                            uuid: self.public_key.clone(),
                            nodes: path_clone,
                        };
                        initiator_peer.send_data(&serde_json::to_string(&packet).unwrap())
                            .await;
                        println!("[PeerSearch] Sent search response to peer");
                        return Ok(());
                    }
                }
                println!(
                    "[PeerSearch] Initiator peer {} not found locally, forwarding response",
                    peer_id
                );
            }
        }

        // Если не нашли локально и есть еще ходы
        if request.max_hops > 0 {
            println!(
                "[PeerSearch] Peer not found locally, forwarding search request (hops left: {})",
                request.max_hops - 1
            );
            
            // Добавляем себя в путь поиска
            let mut path = request.path.clone();
            path.push(SearchPathNode {
                uuid: self.public_key.clone(),
                public_ip: self.public_ip.clone(),
                public_port: self.public_port.clone(),
            });
            let path_clone = path.clone();
            
            let new_request = PeerSearchRequest {
                search_id: search_id.clone(),
                peer_id: request.peer_id,
                max_hops: request.max_hops - 1,
                path, // Передаем обновленный путь
            };

            let packet = TransportPacket {
                act: "search_peer".to_string(),
                to: None,
                data: Some(TransportData::PeerSearchRequest(new_request)),
                protocol: Protocol::SIGNAL,
                uuid: peer_id,
                nodes: path_clone,
            };

            let servers = self.connected_servers.read().await;
            for server in servers.iter() {
                if let Err(e) = server.send_packet(packet.clone()).await {
                    println!(
                        "[PeerSearch] Failed to forward search request to server: {}",
                        e
                    );
                } else {
                    println!("[PeerSearch] Successfully forwarded search request to server");
                }
            }
        } else {
            println!("[PeerSearch] Search failed - max hops reached");
        }

        Ok(())
    }

    pub async fn handle_search_response(&self, response: PeerSearchResponse) -> Result<(), String> {
        println!(
            "[PeerSearch] Received search response for peer {} (from {})",
            response.search_id, response.peer_id
        );

        // Находим свой индекс в пути поиска
        let my_index = response.path.iter().position(|node| node.uuid == self.public_key);
        
        if let Some(index) = my_index {
            // Если мы последний узел в пути, значит мы инициатор поиска
            if index == response.path.len() - 1 {
                println!("[PeerSearch] We are the initiator, processing response");
                // Сначала проверяем локальных пиров
                let peers = self.peers.read().await;
                for peer in peers.iter() {
                    if let Some(uuid) = peer.info.uuid.read().await.clone() {
                        if uuid == response.peer_id {
                            println!("[PeerSearch] Found initiator peer {} locally, sending response directly", response.peer_id);
                            let path_clone = response.path.clone();
                            let packet = TransportPacket {
                                act: "search_response".to_string(),
                                to: Some(response.peer_id.clone()),
                                data: Some(TransportData::PeerSearchResponse(response.clone())),
                                protocol: Protocol::SIGNAL,
                                uuid: self.public_key.clone(),
                                nodes: path_clone,
                            };
                            peer.send_data(&serde_json::to_string(&packet).unwrap())
                                .await;
                            println!("[PeerSearch] Sent search response to initiator peer");
                            return Ok(());
                        }
                    }
                }
                println!("[PeerSearch] Initiator peer {} not found locally", response.peer_id);
            } else {
                // Мы промежуточный узел, сначала проверяем локальных пиров
                let my_index = response.path.iter().position(|node| node.uuid == self.public_key).unwrap();
                let next_node = &response.path[my_index - 1];
                println!("[PeerSearch] Looking for next node {} in path", next_node.uuid);
                
                // Проверяем локальных пиров
                let peers = self.peers.read().await;
                for peer in peers.iter() {
                    if let Some(uuid) = peer.info.uuid.read().await.clone() {
                        if uuid == next_node.uuid {
                            println!("[PeerSearch] Found next node {} locally, sending response directly", next_node.uuid);
                            let path_clone = response.path.clone();
                            let packet = TransportPacket {
                                act: "search_response".to_string(),
                                to: Some(next_node.uuid.clone()),
                                data: Some(TransportData::PeerSearchResponse(response.clone())),
                                protocol: Protocol::SIGNAL,
                                uuid: self.public_key.clone(),
                                nodes: path_clone,
                            };
                            peer.send_data(&serde_json::to_string(&packet).unwrap())
                                .await;
                            println!("[PeerSearch] Sent search response to next node");
                            return Ok(());
                        }
                    }
                }
                
                // Если не нашли локально, отправляем через сигнальный сервер
                println!("[PeerSearch] Next node {} not found locally, forwarding through signal server", next_node.uuid);
                let path_clone = response.path.clone();
                let packet = TransportPacket {
                    act: "search_response".to_string(),
                    to: Some(next_node.uuid.clone()),
                    data: Some(TransportData::PeerSearchResponse(response.clone())),
                    protocol: Protocol::SIGNAL,
                    uuid: self.public_key.clone(),
                    nodes: path_clone,
                };

                let servers = self.connected_servers.read().await;
                let mut forwarded = false;
                for server in servers.iter() {
                    if let Err(e) = server.send_packet(packet.clone()).await {
                        println!("[PeerSearch] Failed to forward response to server: {}", e);
                    } else {
                        forwarded = true;
                        println!("[PeerSearch] Successfully forwarded response to server");
                        break;
                    }
                }

                if !forwarded {
                    println!("[PeerSearch] Failed to forward response to any server");
                }
            }
        } else {
            println!("[PeerSearch] We are not in the search path, ignoring response");
        }

        Ok(())
    }
}




=== ../src\signal\server.rs ===
use async_std::sync::Mutex;
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpListener;
use tokio::sync::{mpsc, RwLock};

use super::peer_search::PeerSearchManager;
use super::Peer;
use crate::config::Config;
use crate::db::P2PDatabase;
use crate::http::http_proxy::HttpProxy;
use crate::packets::{
    PeerWaitConnection, Protocol, SearchPathNode, SyncPeerInfo, SyncPeerInfoData, TransportData,
    TransportPacket,
};
use crate::signal::client::SignalClient;
use crate::signal::signal_servers::{
    SignalServerInfo as StoredSignalServerInfo, SignalServersList,
};
use crate::tunnel::Tunnel;

const SHOW_LOGS: bool = true;

fn log(message: &str) {
    if SHOW_LOGS {
        println!("{}", message);
    }
}

#[derive(Debug)]
pub struct SignalServer {
    pub peers: Arc<RwLock<Vec<Arc<Peer>>>>,
    pub connected_servers: Arc<RwLock<Vec<Arc<SignalClient>>>>,
    peer_search_manager: Arc<PeerSearchManager>,
    port: i64,
    ip: String,
    message_tx: mpsc::Sender<(Arc<Peer>, String)>,
    pub response_tx: mpsc::Sender<TransportPacket>,
    pub response_rx: Arc<Mutex<mpsc::Receiver<TransportPacket>>>,
    pub proxy_http_tx: mpsc::Sender<TransportPacket>,
    my_public_addr: Arc<String>,
    my_public_key: Arc<String>,
    pub db: Arc<P2PDatabase>,
    pub http_proxy: Arc<HttpProxy>,
}

impl SignalServer {
    pub async fn new(config: &Config, db: &P2PDatabase) -> Arc<Self> {
        let (message_tx, mut message_rx) = mpsc::channel(1000);
        let (response_tx, mut response_rx) = mpsc::channel(1000);
        let (proxy_http_tx, mut proxy_http_rx) = mpsc::channel(1000);

        let tunnel = Tunnel::new().await;
        let public_ip = tunnel.get_public_ip();
        let my_public_addr = Arc::new(format!("{}:{}", public_ip, config.signal_server_port));
        let my_public_key = db.get_or_create_peer_id().unwrap();

        let peers = Arc::new(RwLock::new(Vec::new()));
        let connected_servers = Arc::new(RwLock::new(Vec::new()));
        let peer_search_manager = PeerSearchManager::new(
            db.get_or_create_peer_id().unwrap(),
            public_ip.to_string().clone(),
            config.signal_server_port.clone(),
            peers.clone(),
            connected_servers.clone(),
        );

        let proxy_http_tx_clone = proxy_http_tx.clone();
        let proxy = Arc::new(HttpProxy::new(
            Arc::new(db.clone()),
            proxy_http_tx_clone
        ));

        let proxy_clone = Arc::clone(&proxy);
        let server = SignalServer {
            peers,
            connected_servers,
            peer_search_manager,
            port: config.signal_server_port,
            message_tx,
            response_tx,
            response_rx: Arc::new(Mutex::new(response_rx)),
            proxy_http_tx,
            ip: public_ip,
            my_public_addr,
            my_public_key: Arc::new(my_public_key),
            db: Arc::new(db.clone()),
            http_proxy: proxy,
        };

        tokio::spawn(async move {
            proxy_clone.start().await;
        });
        
        let server_arc = Arc::new(server);
        if let Ok(mut servers_list) = SignalServersList::load_or_create() {
            for server_info in servers_list.servers.iter() {
                if (server_info.public_ip == "127.0.0.1"
                    && server_info.port != config.signal_server_port)
                    || server_info.public_ip != "127.0.0.1"
                {
                    let server_addr = format!("{}:{}", server_info.public_ip, server_info.port);
                    let server_clone = Arc::clone(&server_arc);
                    let public_key = server_info.public_key.clone();
                    tokio::spawn(async move {
                        if let Err(e) = server_clone
                            .connect_to_signal_server(&server_addr, &public_key)
                            .await
                        {
                            log(&format!(
                                "[SignalServer] Failed to connect to signal server {}: {}",
                                server_addr, e
                            ));
                        }
                    });
                }
            }
        }

        let server_clone = Arc::clone(&server_arc);
        let server_clone_for_proxy = Arc::clone(&server_arc);
        let server_clone_for_proxy_http = Arc::clone(&server_arc);

        tokio::spawn(async move {
            while let Some((peer, message)) = message_rx.recv().await {
                let server_clone = server_clone.clone();
                let peer_clone = peer.clone();
                tokio::spawn(async move {
                    server_clone
                        .handle_message(&server_clone, peer_clone, message)
                        .await;
                });
            }
        });

        tokio::spawn(async move {
            let mut rx = server_clone_for_proxy_http.response_rx.lock().await;
            while let Some(response) = rx.recv().await {
                let server_clone = server_clone_for_proxy_http.clone();
                tokio::spawn(async move {
                    if let Some(TransportData::ProxyMessage(msg)) = response.data {
                        log(&format!(
                            "Received response from proxy: {:?}",
                            msg.from_peer_id
                        ));
                        let encrypted_response = base64::decode(&msg.text).unwrap();
                        let nonce = base64::decode(&msg.nonce).unwrap();
                        let nonce_array: [u8; 12] = nonce.try_into().unwrap();
                        let response_bytes = server_clone
                            .db
                            .decrypt_message(&encrypted_response, nonce_array, &msg.from_peer_id)
                            .unwrap();

                        server_clone.http_proxy
                            .set_response(msg.request_id.clone(), response_bytes)
                            .await;
                    }
                });
            }
        });

        tokio::spawn(async move {
            while let Some(packet) = proxy_http_rx.recv().await {
                let server_clone = server_clone_for_proxy.clone();
                tokio::spawn(async move {
                    server_clone.auto_send_packet(packet).await;
                });
            }
        });

        server_arc
    }

    pub async fn run(self: Arc<Self>) {
        let addr = format!("0.0.0.0:{}", self.port);
        let listener = TcpListener::bind(addr.clone()).await.unwrap();
        log(&format!("[SignalServer] Running on {}", addr));

        loop {
            let (socket, _) = listener.accept().await.unwrap();
            log(&format!(
                "[SignalServer] New connection: {}",
                socket.peer_addr().unwrap()
            ));

            let peer = Peer::new(socket, None);

            self.add_peer(peer.clone(), false).await.unwrap();

            let self_clone: Arc<SignalServer> = Arc::clone(&self);
            tokio::spawn(async move {
                self_clone.handle_connection(peer.clone()).await;
            });
        }
    }

    async fn connect_to_signal_server(
        self: Arc<Self>,
        server_addr: &str,
        public_key: &str,
    ) -> Result<(), String> {
        let parts: Vec<&str> = server_addr.split(':').collect();
        if parts.len() != 2 {
            return Err(format!("Invalid server address format: {}", server_addr));
        }

        let ip = parts[0];
        let port: i64 = parts[1].parse::<i64>().map_err(|e| e.to_string())?;

        let mut client = SignalClient::new(&self.db);
        client
            .connect(ip, port, &self.ip, self.port as u16, public_key)
            .await?;

        let message_rx = client.get_message_receiver();
        let client_arc = Arc::new(client);
        self.connected_servers
            .write()
            .await
            .push(client_arc.clone());

        let self_clone: Arc<SignalServer> = Arc::clone(&self);
        if let Some(mut message_rx) = message_rx {
            tokio::spawn(async move {
                while let Some(packet) = message_rx.recv().await {
                    log(&format!(
                        "[SignalServer] Received packet from signal server: {:?}",
                        packet
                    ));
                    self_clone.handle_signal_server_packet(packet).await;
                }
            });
        }

        Ok(())
    }

    async fn handle_signal_server_packet(&self, packet: TransportPacket) {
        match packet.protocol {
            Protocol::SIGNAL => {
                if let Some(data) = &packet.data {
                    match data {
                        TransportData::PeerSearchRequest(request) => {
                            log(&format!(
                                "[SignalServer] Received search request from signal server for peer {} (from {})",
                                request.search_id, request.peer_id
                            ));
                            if let Err(e) = self
                                .peer_search_manager
                                .handle_search_request(request.clone())
                                .await
                            {
                                log(&format!(
                                    "[SignalServer] Failed to handle search request: {}",
                                    e
                                ));
                            }
                        }
                        TransportData::PeerSearchResponse(response) => {
                            log(&format!(
                                "[SignalServer] Received search response from signal server for peer {} (from {})",
                                response.search_id, response.peer_id
                            ));
                            log(&format!(
                                "[SignalServer] Response details - found_peer: {}, public_ip: {}, public_port: {}, hops: {}",
                                response.found_peer_id, response.public_ip, response.public_port, response.hops
                            ));
                            if let Err(e) = self
                                .peer_search_manager
                                .handle_search_response(response.clone())
                                .await
                            {
                                log(&format!(
                                    "[SignalServer] Failed to handle search response: {}",
                                    e
                                ));
                            }
                        }
                        _ => {
                            log(&format!(
                                "[SignalServer] Received unknown packet: {:?}",
                                packet
                            ));
                            self.auto_send_packet(packet).await;
                        }
                    }
                }
            }
            _ => {
                log(&format!(
                    "[SignalServer] Received unknown packet: {:?}",
                    packet
                ));
                self.auto_send_packet(packet).await;
            }
        }
    }

    async fn handle_connection(self: Arc<Self>, peer: Arc<Peer>) {
        loop {
            let message = match peer.receive().await {
                Ok(msg) => msg,
                Err(e) => {
                    log(&format!(
                        "[SignalServer] Failed to receive message from peer {}: {}",
                        peer.info.local_addr, e
                    ));
                    if e == "Peer disconnected" {
                        self.remove_peer(&peer).await;
                        break;
                    }
                    continue;
                }
            };
            log(&format!("[SignalServer] Received message: {}", message));

            if let Err(e) = self.message_tx.send((peer.clone(), message)).await {
                log(&format!(
                    "[SignalServer] Failed to send message to handler: {}",
                    e
                ));
            }
        }
    }

    async fn remove_peer(self: Arc<Self>, peer: &Arc<Peer>) -> bool {
        let mut peers = self.peers.write().await;
        let peer_index = peers
            .iter()
            .position(|p| p.info.local_addr == peer.info.local_addr);

        if let Some(index) = peer_index {
            peers.remove(index);
            true
        } else {
            false
        }
    }

    async fn sync_peers(self: Arc<Self>, peer: Arc<Peer>) {
        let peers_info: Vec<SyncPeerInfo> = {
            let peers_guard = self.peers.read().await;
            let mut peers_info = Vec::new();
            for p in peers_guard.iter() {
                let uuid = p
                    .info
                    .uuid
                    .read()
                    .await
                    .clone()
                    .unwrap_or_else(|| "Not set".to_string());
                peers_info.push(SyncPeerInfo { uuid: uuid });
            }
            peers_info
        };

        let peer_uuid = peer
            .info
            .uuid
            .read()
            .await
            .clone()
            .unwrap_or_else(|| "Not set".to_string());
        let peer_uuid_clone = peer_uuid.clone();

        let packet = TransportPacket {
            act: "peer_list".to_string(),
            to: Some(peer_uuid.clone().to_string()),
            data: Some(TransportData::SyncPeerInfoData(SyncPeerInfoData {
                peers: peers_info,
            })),
            protocol: Protocol::SIGNAL,
            uuid: self.db.get_or_create_peer_id().unwrap(),
            nodes: vec![],
        };

        let packet = serde_json::to_string(&packet).unwrap();
        if let Err(e) = peer.send(packet).await {
            log(&format!(
                "[SignalServer] Failed to send peer list to peer {}: {}",
                peer_uuid_clone.clone().as_str(),
                e
            ));
        } else {
            log(&format!(
                "[SignalServer] Successfully sent peer list to peer {}",
                peer_uuid
            ));
        }
    }

    async fn handle_message(&self, server: &Arc<SignalServer>, peer: Arc<Peer>, message: String) {
        log(&format!(
            "[SignalServer] Handling message from peer {}: {}",
            peer.info.local_addr, message
        ));
        let message: TransportPacket = match serde_json::from_str(&message) {
            Ok(msg) => msg,
            Err(e) => {
                log(&format!(
                    "[SignalServer] Failed to parse message from peer {}: {}. Message: {}",
                    peer.info.local_addr, e, message
                ));
                return;
            }
        };

        if message.act == "http_proxy_response" {
            if let Some(target_peer_id) = &message.to {
                if *target_peer_id != *self.my_public_key {
                    log(&format!("Sending response to peer: {:?}", message.to));
                    self.auto_send_packet(message).await;
                } else {
                    log("Sending response to channel response");
                    self.response_tx.send(message).await;
                }
            }
            return;
        }

        let peer_uuid = &message.uuid;
        let is_peer_wait_connection = message.act == "wait_connection";
        let is_peer_accept_connection = message.act == "accept_connection";

        peer.set_wait_connection(is_peer_wait_connection || is_peer_accept_connection)
            .await;
        peer.set_uuid(peer_uuid.clone()).await;

        if let Some(data) = &message.data {
            match data {
                TransportData::SignalServerInfo(server_info) => {
                    log(&format!(
                        "[SignalServer] Received signal server info from peer {}: {:?}",
                        peer_uuid, server_info
                    ));

                    // Сохраняем информацию о сигнальном сервере
                    let stored_info = StoredSignalServerInfo {
                        public_key: server_info.public_key.clone(),
                        public_ip: server_info.public_ip.clone(),
                        port: server_info.port,
                    };

                    if let Ok(mut servers_list) = SignalServersList::load_or_create() {
                        if let Err(e) = servers_list.add_server(stored_info.clone()) {
                            log(&format!(
                                "[SignalServer] Failed to add signal server to list: {}",
                                e
                            ));
                        } else {
                            // Инициализируем соединение с новым сигнальным сервером
                            let server_addr =
                                format!("{}:{}", stored_info.public_ip, stored_info.port);
                            let server_clone = Arc::clone(server);
                            tokio::spawn(async move {
                                if let Err(e) = server_clone
                                    .connect_to_signal_server(&server_addr, &stored_info.public_key)
                                    .await
                                {
                                    log(&format!(
                                        "[SignalServer] Failed to connect to signal server {}: {}",
                                        server_addr, e
                                    ));
                                }
                            });
                        }
                    }
                }
                TransportData::PeerSearchRequest(request) => {
                    log(&format!(
                        "[SignalServer] Received search request for peer {} from {}",
                        request.search_id, request.peer_id
                    ));
                    if let Err(e) = self
                        .peer_search_manager
                        .handle_search_request(request.clone())
                        .await
                    {
                        log(&format!(
                            "[SignalServer] Failed to handle search request: {}",
                            e
                        ));
                    }
                }
                TransportData::PeerSearchResponse(response) => {
                    log(&format!(
                        "[SignalServer] Received search response for peer {} from {}",
                        response.search_id, response.peer_id
                    ));
                    if let Err(e) = self
                        .peer_search_manager
                        .handle_search_response(response.clone())
                        .await
                    {
                        log(&format!(
                            "[SignalServer] Failed to handle search response: {}",
                            e
                        ));
                    }
                }
                TransportData::PeerInfo(info) => {
                    log(&format!(
                        "[SignalServer] Setting peer UUID: {}",
                        info.peer_id
                    ));
                    peer.set_uuid(info.peer_id.clone()).await;
                }
                TransportData::PeerWaitConnection(data) => {
                    peer.add_open_tunnel(
                        &data.connect_peer_id,
                        data.public_ip.clone(),
                        data.public_port,
                    )
                    .await;
                }
                TransportData::StorageReservationRequest(request) => {
                    // Отправляем запрос всем пирам
                    let peers = self.peers.read().await;
                    for p in peers.iter() {
                        if p.get_key().await.as_ref() != Some(&request.peer_id) {
                            log(&format!(
                                "[SignalServer] Forwarding storage reservation request to peer: {}",
                                p.get_key().await.unwrap_or_default()
                            ));
                            let packet = TransportPacket {
                                act: "reserve_storage".to_string(),
                                to: Some(p.get_key().await.unwrap_or_default()),
                                data: Some(TransportData::StorageReservationRequest(
                                    request.clone(),
                                )),
                                protocol: Protocol::SIGNAL,
                                uuid: self.db.get_or_create_peer_id().unwrap(),
                                nodes: vec![SearchPathNode {
                                    uuid: self.db.get_or_create_peer_id().unwrap(),
                                    public_ip: self.ip.clone(),
                                    public_port: self.port,
                                }],
                            };
                            if let Err(e) = p.send(serde_json::to_string(&packet).unwrap()).await {
                                log(&format!("[SignalServer] Failed to forward storage reservation request: {}", e));
                            }
                        }
                    }
                }
                TransportData::StorageReservationResponse(response) => {
                    let packet = TransportPacket {
                        act: "reserve_storage_response".to_string(),
                        to: Some(response.peer_id.clone()),
                        data: Some(TransportData::StorageReservationResponse(response.clone())),
                        protocol: Protocol::SIGNAL,
                        uuid: self.db.get_or_create_peer_id().unwrap(),
                        nodes: vec![],
                    };
                    self.auto_send_packet(packet).await;
                }
                TransportData::FragmentMetadataSync(data) => {
                    log(&format!(
                        "[SignalServer] Получены метаданные фрагментов от пира {}",
                        data.peer_id
                    ));
                    
                    for fragment in data.fragments.clone() {
                        let storage = crate::db::Storage {
                            file_hash: fragment.file_hash,
                            filename: String::new(), 
                            token: String::new(), 
                            token_hash: None,
                            uploaded_via_token: None,
                            owner_key: fragment.owner_key,
                            storage_peer_key: fragment.storage_peer_key,
                            mime: fragment.mime,
                            public: fragment.public,
                            encrypted: fragment.encrypted,
                            compressed: fragment.compressed,
                            auto_decompress: fragment.auto_decompress,
                            size: fragment.size,
                        };

                        if let Err(e) = self.db.add_storage_fragment(storage) {
                            log(&format!(
                                "[SignalServer] Ошибка при сохранении метаданных фрагмента: {}",
                                e
                            ));
                        }
                    }

                    log("[SignalServer] Метаданные фрагментов успешно сохранены");

                    let packet = TransportPacket {
                        act: "sync_fragments".to_string(),
                        to: None,
                        data: Some(TransportData::FragmentMetadataSync(data.clone())),
                        protocol: Protocol::SIGNAL,
                        uuid: self.db.get_or_create_peer_id().unwrap(),
                        nodes: vec![],
                    };
                    self.broadcast_to_servers(packet).await;
                }
                _ => {}
            }
        }

        if message.act == "info" {
            if let Some(TransportData::PeerInfo(info)) = &message.data {
                peer.set_is_signal_server(info.is_signal_server).await;
            }

            log("[SignalServer] =================");
            log("[SignalServer] CONNECTED PEER INFO:");
            log(&format!("[SignalServer] PUBLIC ADDRESS: {}", peer_uuid));
            log(&format!(
                "[SignalServer] LOCAL ADDRESS: {}",
                peer.info.local_addr
            ));
            log(&format!(
                "[SignalServer] IS SIGNAL SERVER: {}",
                peer.is_signal_server().await
            ));
            if let Some(uuid) = peer.info.uuid.read().await.clone() {
                log(&format!("[SignalServer] PEER UUID: {}", uuid));
            } else {
                log("[SignalServer] PEER UUID: Not set");
            }
            log("[SignalServer] =================");

            server.clone().sync_peers(peer.clone()).await;
        }

        match message.protocol {
            Protocol::STUN => {
                if is_peer_wait_connection {
                    log(&format!(
                        "[SignalServer] Peer is ready to connect: {}",
                        peer_uuid
                    ));
                    if let Some(TransportData::PeerWaitConnection(data)) = message.data {
                        log(&format!(
                            "[SignalServer] Looking for peer with UUID: {}",
                            data.connect_peer_id
                        ));
                        let peers_guard = server.peers.read().await;
                        for target_peer in peers_guard.iter() {
                            if let Some(uuid) = target_peer.info.uuid.read().await.clone() {
                                let open_tunnel =
                                    target_peer.get_open_tunnel(&data.connect_peer_id).await;
                                if uuid == data.connect_peer_id {
                                    log(&format!(
                                        "[SignalServer] Found peer with matching UUID: {}",
                                        data.connect_peer_id
                                    ));
                                    log("peer finded");
                                    if open_tunnel.is_some() {
                                        log("[SignalServer] Peer have open tunnel. Start connect peers");
                                        let server_clone = Arc::clone(server);
                                        server_clone
                                            .connect_peers(peer.clone(), target_peer.clone())
                                            .await;
                                    } else {
                                        log("[SignalServer] Peer without open tunnel, send wait connection");
                                        let packet = TransportPacket {
                                            act: message.act.to_string(),
                                            to: message.to.clone(),
                                            data: Some(TransportData::PeerWaitConnection(
                                                data.clone(),
                                            )),
                                            protocol: Protocol::STUN,
                                            uuid: message.uuid.to_string(),
                                            nodes: vec![],
                                        };
                                        let packet_json = serde_json::to_string(&packet).unwrap();
                                        target_peer.send(packet_json).await;
                                        log("sended packet json");
                                    }
                                    return;
                                }
                            }
                        }
                        log(&format!(
                            "[SignalServer] Peer with UUID {} not found",
                            data.connect_peer_id
                        ));
                    }
                } else if is_peer_accept_connection {
                    if let Some(TransportData::PeerWaitConnection(data)) = message.data.clone() {
                        let peers_guard = server.peers.read().await;
                        for target_peer in peers_guard.iter() {
                            if let Some(uuid) = target_peer.info.uuid.read().await.clone() {
                                if uuid == data.connect_peer_id {
                                    let open_tunnel_a = peer.get_open_tunnel(&uuid).await;
                                    let open_tunnel_b =
                                        target_peer.get_open_tunnel(&peer_uuid).await;
                                    if open_tunnel_a.is_some() && open_tunnel_b.is_some() {
                                        log("[SignalServer] Both peers have open tunnels. Connecting");
                                        server
                                            .connect_peers(peer.clone(), target_peer.clone())
                                            .await;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Protocol::TURN => {
                if let Some(to) = &message.to {
                    log(&format!(
                        "[SignalServer] Received turn packet: {:?}",
                        message
                    ));
                    let peers_guard = server.peers.read().await;
                    for item in peers_guard.iter() {
                        if *item.info.uuid.read().await == Some(to.clone()) {
                            log(&format!(
                                "[SignalServer] Send turn packet: {} {:?}",
                                peer.info.local_addr, message
                            ));

                            let turn_packet = TransportPacket {
                                act: message.act.to_string(),
                                to: message.to.clone(),
                                data: message.data.clone(),
                                protocol: Protocol::TURN,
                                uuid: message.uuid.to_string(),
                                nodes: vec![],
                            };
                            let turn_packet = serde_json::to_string(&turn_packet).unwrap();
                            if let Err(e) = item.send(turn_packet).await {
                                log(&format!(
                                    "[SignalServer] Failed to send turn packet to peer {}: {}",
                                    item.info.local_addr, e
                                ));
                            } else {
                                log(&format!(
                                    "[SignalServer] Successfully send turn packet to peer {}",
                                    item.info.local_addr
                                ));
                            }
                            break;
                        }
                    }
                }
            }
            Protocol::SIGNAL => {
                if message.act == "peer_list" {
                    server.clone().sync_peers(peer.clone()).await;
                } else if message.protocol == Protocol::STUN && message.act == "wait_connection" {
                    if let Some(TransportData::SyncPeerInfoData(data)) = &message.data {
                        log("[SignalServer] Processing peers for wait_connection:");
                        for peer in &data.peers {
                            // println!("  - Public Address: {}", peer.public_addr);
                            log(&format!("    UUID: {}", peer.uuid));
                        }
                    } else {
                        log("[SignalServer] No peers found in the data for wait_connection.");
                    }
                } else if message.to.is_some() {
                    log(&format!(
                        "[SignalServer] Sending packet to peer: {}",
                        message.to.clone().unwrap()
                    ));
                    self.send_to_peer_by_packet(message.clone()).await;
                }
            }
        }
    }

    pub async fn auto_send_packet(&self, message: TransportPacket) {
        let target_peer_id = message.to.clone().unwrap();
        let from_peer_id = message.uuid.clone();
        let mut sended = false;

        if from_peer_id == *target_peer_id {
            return;
        }

        for peer in self.peers.read().await.iter() {
            if peer.info.uuid.read().await.clone().unwrap() == target_peer_id
                || peer.is_signal_server().await
            {
                peer.send(serde_json::to_string(&message).unwrap()).await;
                sended = true;
            }
        }
        if !sended {
            for server in self.connected_servers.read().await.iter() {
                if server.public_key != from_peer_id {
                    log(&format!(
                        "[SignalServer] Sending packet to signal server: {:?}. from uuid: {}",
                        server.public_key, from_peer_id
                    ));
                    server.send_packet(message.clone()).await;
                }
            }
        }
    }

    async fn send_to_peer_by_packet(&self, message: TransportPacket) {
        for peer in self.peers.read().await.iter() {
            if peer.info.uuid.read().await.clone().unwrap() == message.to.clone().unwrap() {
                peer.send(serde_json::to_string(&message).unwrap()).await;
            }
        }
    }

    async fn connect_peers(&self, first_peer: Arc<Peer>, second_peer: Arc<Peer>) {
        log("[SignalServer] Connecting peers");

        {
            log(&format!(
                "[SignalServer] Sending packet to: {}",
                second_peer.info.local_addr
            ));
            SignalServer::send_peer_info(second_peer.clone(), first_peer.clone()).await;
            log(&format!(
                "[SignalServer] Sent packet to peer: {}",
                second_peer.info.local_addr
            ));
        }
        second_peer.set_wait_connection(false).await;
        tokio::time::sleep(Duration::from_millis(500)).await;
        {
            log(&format!(
                "[SignalServer] Sending packet to: {}",
                first_peer.info.local_addr
            ));
            SignalServer::send_peer_info(first_peer.clone(), second_peer.clone()).await;
            log(&format!(
                "[SignalServer] Sent packet to peer: {}",
                first_peer.info.local_addr
            ));
        }
        first_peer.set_wait_connection(false).await;
    }

    async fn add_peer(
        &self,
        peer: Arc<Peer>,
        is_peer_wait_connection: bool,
    ) -> Result<Arc<Peer>, String> {
        let mut peers_guard = self.peers.write().await;
        let mut peer_added = false;
        let mut peer_res: Option<Arc<Peer>> = None;
        for item in peers_guard.iter() {
            if *item.info.local_addr == peer.info.local_addr {
                log(&format!(
                    "Peer already in the list: {}",
                    peer.info.local_addr
                ));
                peer_added = true;
                if is_peer_wait_connection {
                    let mut wait_connection = item.info.wait_connection.write().await;
                    *wait_connection = true;
                }
                peer_res = Some(item.clone());
                break;
            }
        }
        if !peer_added {
            peer_res = Some(peer.clone());
            peers_guard.push(peer.clone());
        }
        if peer_res.is_none() {
            return Err("Failed to add peer to the list".to_string());
        }
        return Ok(peer_res.clone().unwrap());
    }

    async fn send_peer_info(to_peer: Arc<Peer>, about_peer: Arc<Peer>) {
        let pub_id = about_peer.info.uuid.read().await.clone().unwrap();
        if let Some(key_peer) = to_peer.get_key().await {
            let data_open_tunnel = about_peer.get_open_tunnel(&key_peer.to_string()).await;
            if let Some(open_tunnel) = data_open_tunnel {
                let wait_packet = TransportPacket {
                    act: "accept_connection".to_string(), // TODO: было wait_connection
                    to: Some(pub_id.clone()),             // UUID кому отправляем данный пакет
                    data: Some(TransportData::PeerWaitConnection(PeerWaitConnection {
                        connect_peer_id: pub_id.clone(),
                        public_ip: open_tunnel.ip,
                        public_port: open_tunnel.port,
                    })),
                    protocol: Protocol::STUN,
                    uuid: about_peer.info.uuid.read().await.clone().unwrap(),
                    nodes: vec![],
                };
                let wait_packet = serde_json::to_string(&wait_packet).unwrap();

                log(&format!(
                    "[SignalServer] Sending wait packet to peer: {}",
                    to_peer.info.local_addr
                ));
                let result = to_peer.send(wait_packet).await;

                match result {
                    Ok(_) => log(&format!(
                        "[SignalServer] Successfully sent packet to peer: {}. Peer connecting to: {}",
                        key_peer,
                        pub_id,
                    )),
                    Err(e) => log(&format!("[SignalServer] Failed to send peer to peer info: {}", e)),
                }
            }
        }
    }

    async fn broadcast_to_servers(&self, packet: TransportPacket) {
        let servers = self.connected_servers.read().await;
        for server in servers.iter() {
            if let Err(e) = server.send_packet(packet.clone()).await {
                log(&format!(
                    "[SignalServer] Failed to broadcast to server: {}",
                    e
                ));
            }
        }
    }
}


=== ../src\signal\signal_servers.rs ===
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SignalServerInfo {
    pub public_key: String,
    pub public_ip: String,
    pub port: i64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SignalServersList {
    pub servers: Vec<SignalServerInfo>,
}

impl SignalServersList {
    pub fn new() -> Self {
        SignalServersList {
            servers: Vec::new(),
        }
    }

    pub fn load_or_create() -> Result<Self, String> {
        let path = Path::new("signal_servers.json");
        if path.exists() {
            let content = fs::read_to_string(path)
                .map_err(|e| format!("Failed to read signal_servers.json: {}", e))?;
            serde_json::from_str(&content)
                .map_err(|e| format!("Failed to parse signal_servers.json: {}", e))
        } else {
            let list = SignalServersList::new();
            list.save()?;
            Ok(list)
        }
    }

    pub fn save(&self) -> Result<(), String> {
        let content = serde_json::to_string_pretty(self)
            .map_err(|e| format!("Failed to serialize signal servers list: {}", e))?;
        fs::write("signal_servers.json", content)
            .map_err(|e| format!("Failed to write signal_servers.json: {}", e))
    }

    pub fn add_server(&mut self, server: SignalServerInfo) -> Result<(), String> {
        // Проверяем, нет ли уже такого сервера
        if !self.servers.iter().any(|s| s.public_key == server.public_key) {
            self.servers.push(server);
            self.save()?;
        }
        Ok(())
    }
} 

=== ../src\simulation\mod.rs ===
use std::sync::Arc;
use tokio::sync::Mutex;
use crate::config::Config;
use crate::signal::SignalServer;
use crate::peer::Peer;
use crate::db::P2PDatabase;
use std::path::PathBuf;
use std::collections::HashMap;

pub struct NetworkSimulation {
    signal_servers: HashMap<String, Arc<SignalServer>>,
    peers: HashMap<String, Arc<Mutex<Peer>>>,
    db_paths: HashMap<String, PathBuf>,
}

impl NetworkSimulation {
    pub fn new() -> Self {
        Self {
            signal_servers: HashMap::new(),
            peers: HashMap::new(),
            db_paths: HashMap::new(),
        }
    }

    pub async fn add_signal_server(&mut self, config: &Config, id: String, db_path: PathBuf) -> Result<(), Box<dyn std::error::Error>> {
        if !db_path.exists() {
            std::fs::create_dir_all(&db_path)?;
        }
        let db = P2PDatabase::new(db_path.to_str().unwrap())?;
        let signal_server = SignalServer::new(config, &db).await;
        self.signal_servers.insert(id.clone(), signal_server);
        self.db_paths.insert(id, db_path);
        Ok(())
    }

    pub async fn add_peer(&mut self, config: &Config, id: String, db_path: PathBuf) -> Result<(), Box<dyn std::error::Error>> {
        if !db_path.exists() {
            std::fs::create_dir_all(&db_path)?;
        }
        let db = P2PDatabase::new(db_path.to_str().unwrap())?;
        let peer = Peer::new(config, &db).await;
        self.peers.insert(id.clone(), Arc::new(Mutex::new(peer)));
        self.db_paths.insert(id, db_path);
        Ok(())
    }

    pub async fn run_simulation(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut handles = vec![];

        // Запускаем сигнальные серверы
        for (id, server) in &self.signal_servers {
            let server = server.clone();
            let id = id.clone();
            handles.push(tokio::spawn(async move {
                println!("Starting signal server: {}", id);
                server.run().await;
            }));
        }

        // Запускаем пиры
        for (id, peer) in &self.peers {
            let peer = peer.clone();
            let id = id.clone();
            handles.push(tokio::spawn(async move {
                println!("Starting peer: {}", id);
                peer.lock().await.run().await;
            }));
        }

        // Ждем завершения всех задач
        for handle in handles {
            handle.await?;
        }

        Ok(())
    }

    pub fn get_peer(&self, id: &str) -> Option<&Arc<Mutex<Peer>>> {
        self.peers.get(id)
    }
} 

=== ../src\tunnel\mod.rs ===
mod tunnel;

pub use self::tunnel::Tunnel;

=== ../src\tunnel\tunnel.rs ===
use async_std::net::{SocketAddr, UdpSocket};
use async_std::sync::RwLock;
use async_std::{fs, task};
use rand::Rng;
use serde::{Deserialize, Serialize};
use serde_json::Number;
use std::sync::Arc;
use std::time::Duration;
use std::{str, thread};
use stun_client::*;
use tokio::time::timeout;

#[derive(Serialize, Deserialize)]
struct Message {
    text: String,
}

#[derive(Serialize, Deserialize)]
struct FileMessage {
    filename: String,
    data: Vec<u8>,
}

#[derive(Clone)]
pub struct Tunnel {
    pub local_port: u16,
    pub public_ip: String,
    pub public_port: u16,
    pub socket: Option<Arc<UdpSocket>>,
    client: Option<SocketAddr>,
    pub is_connected: Arc<RwLock<bool>>,
}

impl Tunnel {
    pub async fn new() -> Self {
        let local_port = rand::thread_rng().gen_range(16000..65535);
        let (public_ip, public_port) = Self::stun(local_port).await;
        let mut is_connected = Arc::new(RwLock::new(false));
        Tunnel {
            local_port,
            public_ip,
            public_port,
            socket: None,
            client: None,
            is_connected,
        }
    }
    
    pub async fn with_port(port: u16) -> Self {
        let (public_ip, public_port) = Self::stun(port).await;
        Tunnel {
            local_port: port,
            public_ip,
            public_port,
            socket: None,
            client: None,
            is_connected: Arc::new(RwLock::new(false)),
        }
    }

    pub fn get_public_addr(&self) -> String {
        return format!("{}:{}", self.public_ip, self.public_port);
    }

    async fn stun(port: u16) -> (String, u16) {
        let client = Client::new(format!("0.0.0.0:{}", port), None).await;
        if let Err(e) = client {
            panic!("Failed to create STUN client: {:?}", e);
        }
        let mut client = client.unwrap();

        let stun_servers = vec![
            "stun.l.google.com:19302",
            "stun1.l.google.com:19302",
            "stun2.l.google.com:19302",
            "stun3.l.google.com:19302",
            "stun4.l.google.com:19302",
            "stun.stunprotocol.org:3478",
            "stun.voipstunt.com:3478"
        ];

        let mut last_error = None;
        for server in stun_servers {
            println!("[DEBUG] Trying STUN server: {}", server);
            let res = client.binding_request(server, None).await;
            match res {
                Ok(_) => {
                    println!("[DEBUG] Successfully connected to STUN server: {}", server);
                    break;
                }
                Err(e) => {
                    println!("[DEBUG] Failed to connect to {}: {:?}", server, e);
                    last_error = Some(e);
                    continue;
                }
            }
        }

        if let Some(e) = last_error {
            panic!("Failed to connect to any STUN server. Last error: {:?}", e);
        }

        let res = client.binding_request("stun.l.google.com:19302", None).await;
        if let Err(e) = res {
            panic!("Failed to send binding request: {:?}", e);
        }
        let res = res.unwrap();

        let xor_mapped_addr = Attribute::get_xor_mapped_address(&res);
        if let Some(addr) = xor_mapped_addr {
            (addr.ip().to_string(), addr.port())
        } else {
            let mapped_addr = Attribute::get_mapped_address(&res);
            if let Some(addr) = mapped_addr {
                (addr.ip().to_string(), addr.port())
            } else {
                panic!(
                    "Failed to get XOR mapped address or Mapped address from STUN response: {:?}",
                    res
                );
            }
        }
    }

    pub async fn make_connection(
        &mut self,
        ip: &str,
        port: u16,
        timeout_default: u64,
    ) -> Result<(), String> {
        let addr = format!("{}:{}", ip, port)
            .parse::<SocketAddr>()
            .expect("Invalid address");
        let local_port = self.local_port;
        let mut timeout_count = timeout_default;
        println!("[STUN] Trying to connect to {}:{}", ip, port);

        while timeout_count > 0 {
            let sock = match UdpSocket::bind(format!("0.0.0.0:{}", local_port)).await {
                Ok(s) => Arc::new(s),
                Err(e) => {
                    return Err(format!("[STUN] Failed to bind UDP socket: {:?}", e));
                }
            };

            println!(
                "[STUN] Sending connection request to {}:{}... {}/{}",
                ip, port, timeout_count, timeout_default
            );

            if let Err(e) = sock.send_to(b"Con. Request!", addr).await {
                println!("[STUN] Failed to send connection request: {:?}", e);
                timeout_count -= 1;
                continue;
            }

            let mut buf = vec![0u8; 1024];
            match timeout(Duration::from_secs(2), sock.recv_from(&mut buf)).await {
                Ok(res) => match res {
                    Ok((_n, peer)) => {
                        println!(
                            "[STUN] Reply received from {}:{}...",
                            peer.ip(),
                            peer.port()
                        );
                        if let Err(e) = sock.send_to(b"Con. Request!", addr).await {
                            println!("[STUN] Failed to resend connection request: {:?}", e);
                            timeout_count -= 1;
                            continue;
                        }
                        self.client = Some(addr);
                        self.socket = Some(sock.clone());
                        self.is_connected = Arc::new(RwLock::new(true));
                        println!("[STUN] Hole with {} successfully broken!", addr);
                        return Ok(());
                    }
                    Err(e) => {
                        timeout_count -= 1;
                        println!("[STUN] Error while receiving data: {:?}", e);
                    }
                },
                Err(_) => {
                    timeout_count -= 1;
                    println!("[STUN] No handshake with {}:{} yet...", ip, port);
                }
            }
        }
        self.is_connected = Arc::new(RwLock::new(false));
        if self.client.is_none() {
            return Err(format!(
                "[STUN] Failed to establish connection with {}:{}",
                ip, port
            ));
        }
        Err(format!(
            "[STUN] Failed to establish connection with {}:{}",
            ip, port
        ))
    }

    pub fn backlife_cycle(&self, freq: u64) {
        if let Some(client) = self.client {
            if let Some(sock) = &self.socket {
                let sock = sock.clone();
                thread::spawn(move || {
                    Self::life_cycle(sock, client, freq);
                });
                println!("[STUN] Session with {} stabilized!", client);
            }
        } else {
            println!("[STUN] No client to stabilize session with.");
        }
    }

    fn life_cycle(sock: Arc<UdpSocket>, client: SocketAddr, freq: u64) {
        println!("[STUN] Starting life cycle...");
        let sock_clone = sock.clone();

        // Запуск отдельной задачи для отправки KPL
        thread::spawn(move || {
            loop {
                println!("[STUN] Sending keep-alive...");
                task::block_on(sock_clone.send_to(b"KPL", client)).unwrap();
                thread::sleep(Duration::from_secs_f64(1.0 / freq as f64));
            }
        });

        // Основной цикл для обработки входящих данных
        // loop {
        //     let mut buf = vec![0u8; 9999];
        //     while let Ok((n, reply_addr)) = task::block_on(sock.recv_from(&mut buf)) {
        //         Self::handle_received_data(&buf[..n], reply_addr, client, sock.clone(), message_tx.clone());
        //     }
        // }
    }

    fn handle_received_data(
        data: &[u8],
        reply_addr: SocketAddr,
        client: SocketAddr,
        sock: Arc<UdpSocket>,
    ) {
        let protocol = &data[..3];
        println!(
            "[STUN] {}: Received {} from {}: {:?}",
            client.ip(),
            str::from_utf8(protocol).unwrap(),
            reply_addr,
            data
        );

        if protocol == b"KPL" {
            return;
        } else if protocol == b"MSG" {
            let message: Message = serde_json::from_slice(&data[3..]).unwrap();
            println!("[STUN] Message from {}: {}", client.ip(), message.text);
        } else if protocol == b"FIL" {
            let file_message: FileMessage = serde_json::from_slice(&data[3..]).unwrap();
            println!(
                "[STUN] Received file {} from {}",
                file_message.filename,
                client.ip()
            );
            task::block_on(Self::save_file(&file_message.filename, &file_message.data));
        }
    }

    pub async fn send_message(&self, message: &str) {
        let msg = Message {
            text: message.to_string(),
        };
        let msg_bytes = serde_json::to_vec(&msg).unwrap();
        let client = self.client.unwrap();
        self.socket
            .as_ref()
            .unwrap()
            .send_to(&[b"MSG", &msg_bytes[..]].concat(), client)
            .await
            .unwrap();
    }

    async fn save_file(filename: &str, data: &[u8]) {
        let path = format!("./received_files/{}", filename);
        if let Err(e) = fs::create_dir_all("./received_files").await {
            println!("Failed to create directory: {:?}", e);
            return;
        }
        if let Err(e) = fs::write(&path, data).await {
            println!("Failed to save file: {:?}", e);
        } else {
            println!("File saved to {}", path);
        }
    }

    pub async fn send_file_path(&self, file_path: &str) {
        let filename = file_path.split('/').last().unwrap().to_string();
        let data = fs::read(file_path).await;
        if let Err(e) = data {
            println!("Failed to read file: {:?}", e);
            return;
        }
        self.send_file(&filename, data.unwrap()).await;
    }

    pub async fn send_file(&self, filename: &str, data: Vec<u8>) {
        let file_message = FileMessage {
            filename: filename.to_string(),
            data,
        };
        let file_message_bytes = serde_json::to_vec(&file_message).unwrap();
        let client = self.client.unwrap();
        self.socket
            .as_ref()
            .unwrap()
            .send_to(&[b"FIL", &file_message_bytes[..]].concat(), client)
            .await
            .unwrap();
    }

    pub fn get_public_ip(&self) -> String {
        self.public_ip.clone()
    }

    pub fn get_public_port(&self) -> u16 {
        self.public_port
    }

    pub async fn is_connected(&self) -> bool {
        *self.is_connected.read().await
    }
}


=== ../src\ui\console.rs ===
use crate::crypto::token::get_metadata_from_token;
use crate::db::P2PDatabase;
use crate::manager::ConnectionTurnStatus;
use crate::peer::peer_api::PeerAPI;
use colored::*;
use hex;
use std::collections::HashMap;
use std::io::{self, Write};
use std::sync::Arc;
use std::time::SystemTime;
use tokio::sync::RwLock;

pub fn print_welcome() {
    println!("\n{}", r#"
    ██╗     ██╗████████╗███████╗    ██████╗ ███████╗███████╗██████╗ 
    ██║     ██║╚══██╔══╝██╔════╝    ██╔══██╗██╔════╝██╔════╝██╔══██╗
    ██║     ██║   ██║   █████╗      ██████╔╝█████╗  █████╗  ██████╔╝
    ██║     ██║   ██║   ██╔══╝      ██╔═══╝ ██╔══╝  ██╔══╝  ██╔══██╗
    ███████╗██║   ██║   ███████╗    ██║     ███████╗███████╗██║  ██║
    ╚══════╝╚═╝   ╚═╝   ╚══════╝    ╚═╝     ╚══════╝╚══════╝╚═╝  ╚═╝
    "#.bright_blue());
    println!("{}", "                    P2P File Sharing Network".bright_cyan());
    println!("{}", "                    Version 2.0".bright_yellow());
    println!("\n{}", "Добро пожаловать в LITE PEER TO LITE NODE!".bright_green());
    println!("{}", "Введите 'help' для просмотра доступных команд\n".bright_white());
}

pub fn print_all_files(db: &P2PDatabase) {
    let myfiles = db.get_my_fragments();

    let uuid_peer = db.get_or_create_peer_id().unwrap();
    println!("{}", format!("[Peer] UUID: {}", uuid_peer).yellow());

    match myfiles {
        Ok(myfiles) => {
            println!("{}", "My Files:".bold().underline().blue());
            for fragment in myfiles {
                println!("  {}: {}", "Storage Peer UUID".yellow(), fragment.storage_peer_key);
                println!("  {}: {}", "Token".yellow(), fragment.token);
                println!("  {}: {}", "Filename".yellow(), fragment.filename);
                println!("  {}: {}", "UUID Fragment (key db)".yellow(), fragment.file_hash);
                println!("  {}: {}", "Size".yellow(), fragment.size);
                println!("  {}: {}", "Mime".yellow(), fragment.mime);
                println!("  {}: {}", "Public".yellow(), fragment.public);
                println!("  {}: {}", "Encrypted".yellow(), fragment.encrypted);
                println!("  {}: {}", "Compressed".yellow(), fragment.compressed);
                println!();
            }
        }
        Err(_) => (()),
    }
}

pub fn print_all_fragments(db: &P2PDatabase) {
    let fragments = db.get_storage_fragments();

    match fragments {
        Ok(fragments) => {
            println!("{}", "All fragments:".bold().underline().blue());
            for fragment in fragments {
                println!("  {}: {}", "Owner Peer UUID".yellow(), fragment.owner_key);
                println!(
                    "  {}: {}",
                    "Storage Peer UUID".yellow(),
                    fragment.storage_peer_key
                );
                println!("  {}: {}", "File Hash".yellow(), fragment.file_hash);
                println!("  {}: {}", "Mime".yellow(), fragment.mime);
                println!("  {}: {}", "Public".yellow(), fragment.public);
                println!("  {}: {}", "Encrypted".yellow(), fragment.encrypted);
                println!("  {}: {}", "Compressed".yellow(), fragment.compressed);
                println!("  {}: {}", "Token".yellow(), fragment.token);
                println!("  {}: {}", "Filename".yellow(), fragment.filename);
                println!();
            }
        }
        Err(_) => (()),
    }
}

pub async fn print_tokens_info(db: &P2PDatabase) {
    let tokens = match db.get_all_tokens() {
        Ok(tokens) => tokens,
        Err(e) => {
            println!(
                "{}",
                format!("[Peer] Ошибка при получении токенов: {}", e).red()
            );
            return;
        }
    };

    println!(
        "\n{}",
        "╔════════════════════════════════════════════════════════════╗".yellow()
    );
    println!(
        "{}",
        "║                    ИНФОРМАЦИЯ О ТОКЕНАХ                    ║".yellow()
    );
    println!(
        "{}",
        "╠════════════════════════════════════════════════════════════╣".yellow()
    );

    if tokens.is_empty() {
        println!(
            "{}",
            "║ Нет доступных токенов                                      ║".red()
        );
    } else {
        for (peer_id, token_info) in tokens {
            println!(
                "{}",
                "╠════════════════════════════════════════════════════════════╣".yellow()
            );
            println!(
                "{} {}",
                "║ Peer ID:".cyan(),
                format!("{:>40} ║", peer_id).white()
            );
            println!(
                "{} {}",
                "║ Токен:".cyan(),
                format!("{:>40} ║", token_info.token).white()
            );
            println!(
                "{} {}",
                "║ Свободное место:".cyan(),
                format!("{:>32} байт ║", token_info.free_space).white()
            );
            println!(
                "{} {}",
                "║ Занятое место:".cyan(),
                format!("{:>34} байт ║", token_info.used_space).white()
            );
            println!(
                "{} {}",
                "║ Доступно:".cyan(),
                format!("{:>38} байт ║", token_info.free_space - token_info.used_space).white()
            );

            let timestamp = token_info.timestamp;
            let datetime = SystemTime::UNIX_EPOCH + std::time::Duration::from_secs(timestamp);
            let datetime_str = format!("{:?}", datetime);
            println!(
                "{} {}",
                "║ Время создания:".cyan(),
                format!("{:>35} ║", datetime_str).white()
            );

            // Пытаемся получить метаданные токена
            if let Ok(metadata) = get_metadata_from_token(token_info.token.clone()).await {
                println!(
                    "{} {}",
                    "║ Размер файла:".cyan(),
                    format!("{:>37} байт ║", metadata.file_size).white()
                );
                println!(
                    "{} {}",
                    "║ Провайдер:".cyan(),
                    format!("{:>41} ║", metadata.storage_provider).white()
                );
                println!(
                    "{} {}",
                    "║ Подпись:".cyan(),
                    format!("{:>43} ║", hex::encode(&metadata.signature)).white()
                );
            } else {
                println!(
                    "{}",
                    "║ Не удалось получить метаданные токена                ║".red()
                );
            }
        }
    }

    println!(
        "{}",
        "╚════════════════════════════════════════════════════════════╝".yellow()
    );
    println!();
}

pub fn print_all_commands() {
    let width = 75; 
    let horizontal_line = "═".repeat(width - 2);
    let top_border = format!("╔{}╗", horizontal_line);
    let middle_border = format!("╠{}╣", horizontal_line);
    let bottom_border = format!("╚{}╝", horizontal_line);
    
    let commands = vec![
        ("files", "Список всех ваших файлов"),
        ("fragments", "Список всех ваших фрагментов"),
        ("tokens", "Показать все токены и их метаданные"),
        ("peers", "Список всех пиров"),
        ("virtual_storage", "Интерактивное управление виртуальным хранилищем"),
        ("search_peer <peer_id>", "Поиск конкретного пира"),
        ("connect <peer_id>", "Подключиться к пиру"),
        ("send_all <message>", "Отправить сообщение всем пирам"),
        ("<message>", "Отправить сообщение пиру"),
        ("get <session_key>", "Получить файл от пира"),
        ("upload <file_path>", "Загрузить файл на пир"),
        ("reserve <size_in_bytes>", "Зарезервировать место на пирах"),
        ("valid_token <token>", "Проверить токен хранилища"),
        ("set_public <file_hash> <true/false>", "Изменить публичный доступ к файлу"),
        ("delete <file_hash>", "Удалить файл"),
        ("help", "Показать доступные команды"),
    ];

    println!("\n{}", top_border.bright_blue());
    println!("{}", format!("║{:^width$}║", "Доступные команды:", width = width - 2).bright_blue());
    println!("{}", middle_border.bright_blue());

    for (cmd, desc) in commands {
        println!("{}", format!("║  {:<30} - {:<25} ║", cmd.bright_green(), desc.bright_white()).bright_blue());
    }
    
    println!("{}", bottom_border.bright_blue());
    println!();
}

pub async fn console_manager(
    api: Arc<PeerAPI>,
    connections_turn: Arc<RwLock<HashMap<String, ConnectionTurnStatus>>>,
    db: &P2PDatabase,
) {
    let mut input = String::new();
    print!("\x1b[32m[LP2LP] >\x1b[0m ");
    io::stdout().flush().unwrap();
    std::io::stdin().read_line(&mut input).unwrap();
    let trimmed_input = input.trim();

    if trimmed_input == "help" {
        print_all_commands();
    } else if trimmed_input == "virtual_storage" {
        if let Err(e) = api.virtual_storage_interactive().await {
            println!("{}", format!("[Peer] Ошибка в виртуальном хранилище: {}", e).red());
        }
    } else if trimmed_input == "files" {
        print_all_files(db);
    } else if trimmed_input == "fragments" {
        print_all_fragments(db);
    } else if trimmed_input == "tokens" {
        print_tokens_info(db).await;
    } else if trimmed_input == "peers" {
        if let Err(e) = api.request_peer_list().await {
            println!("{}", format!("[Peer] Failed to request peer list: {}", e).red());
        }
    } else if trimmed_input == "sync_fragments" {
        if let Err(e) = api.sync_fragment_metadata().await {
            println!("{}", format!("[Peer] Failed to sync fragment metadata: {}", e).red());
        } else {
            println!("{}", "[Peer] Fragment metadata sync started".green());
        }
    } else if trimmed_input.starts_with("set_public ") {
        let args: Vec<&str> = trimmed_input.split_whitespace().collect();
        if args.len() != 3 {
            println!("{}", "[Peer] Использование: set_public <file_hash> <true/false>".red());
            return;
        }
        let file_hash = args[1].to_string();
        let public = match args[2].to_lowercase().as_str() {
            "true" => true,
            "false" => false,
            _ => {
                println!("{}", "[Peer] Значение public должно быть true или false".red());
                return;
            }
        };
        if let Err(e) = api.change_file_public_access(file_hash, public).await {
            println!("{}", format!("[Peer] Ошибка при изменении доступа: {}", e).red());
        }
    } else if trimmed_input.starts_with("delete ") {
        let file_hash = trimmed_input.strip_prefix("delete ").unwrap();
        if let Err(e) = api.delete_file(file_hash.to_string()).await {
            println!("{}", format!("[Peer] Ошибка при удалении файла: {}", e).red());
        }
    } else if trimmed_input.starts_with("search_peer ") {
        let peer_id = trimmed_input.strip_prefix("search_peer ").unwrap();
        if let Err(e) = api.search_peer(peer_id.to_string()).await {
            println!("{}", format!("[Peer] Failed to search peer: {}", e).red());
        }
    } else if trimmed_input.starts_with("reserve ") {
        let size_str = trimmed_input.strip_prefix("reserve ").unwrap();
        match size_str.parse::<u64>() {
            Ok(size) => {
                if let Err(e) = api.reserve_storage(size).await {
                    println!(
                        "{}",
                        format!("[Peer] Failed to reserve storage: {}", e).red()
                    );
                } else {
                    println!(
                        "{}",
                        format!("[Peer] Storage reservation request sent for {} bytes", size)
                            .green()
                    );
                }
            }
            Err(_) => println!(
                "{}",
                "[Peer] Invalid size format. Please provide a number in bytes.".red()
            ),
        }
    } else if trimmed_input.starts_with("valid_token ") {
        let token = trimmed_input.strip_prefix("valid_token ").unwrap();
        if let Err(e) = api.valid_token(token.to_string()).await {
            println!(
                "{}",
                format!("[Peer] Failed to validate token: {}", e).red()
            );
        } else {
            println!("{}", format!("[Peer] Token validated successfully").green());
        }
    } else if trimmed_input.starts_with("connect ") {
        let peer_id = trimmed_input.strip_prefix("connect ").unwrap();
        println!(
            "{}",
            format!("[Peer] Trying to connect to peer: {}", peer_id).cyan()
        );

        if let Err(e) = api.connect_to_peer(peer_id.to_string()).await {
            println!(
                "{}",
                format!("[Peer] Failed to connect to peer: {}", e).red()
            );
        } else {
            println!(
                "{}",
                "[Peer] Waiting for peer to accept connection...".yellow()
            );
        }
    } else if trimmed_input.starts_with("get ") {
        let filename = trimmed_input.strip_prefix("get ").unwrap();
        if let Err(e) = api.get_file(filename.to_string()).await {
            println!(
                "{}",
                format!("[Peer] Failed to get file {}: {}", filename, e).red()
            );
        } else {
            println!(
                "{}",
                format!("[Peer] File {} request sent successfully", filename).green()
            );
        }
    } else if trimmed_input.starts_with("upload ") {
        let file_path = trimmed_input.strip_prefix("upload ").unwrap().trim();
        if file_path.is_empty() {
            println!("{}", "[Peer] Использование: upload <путь_к_файлу>".red());
            return;
        }

        let path = std::path::Path::new(file_path);
        let is_directory = path.is_dir();

        if is_directory {
            print!("{}", "Вы указали путь к директории. Загрузить все файлы? (y/n): ".yellow());
            io::stdout().flush().unwrap();
            let mut input = String::new();
            std::io::stdin().read_line(&mut input).unwrap();
            if input.trim().to_lowercase() != "y" {
                println!("{}", "Загрузка отменена".red());
                return;
            }
        }

        println!("\n{}", "Настройка параметров загрузки:".cyan());
        
        // Запрос на шифрование
        print!("{}", "Шифровать файлы? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();
        let encrypted = input.trim().to_lowercase() == "y";

        // Запрос на публичный доступ
        print!("{}", "Сделать файлы публичными? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        input.clear();
        std::io::stdin().read_line(&mut input).unwrap();
        let public = input.trim().to_lowercase() == "y";

        // Запрос на декомпрессию
        print!("{}", "Декомпрессировать файлы после загрузки? (y/n): ".yellow());
        io::stdout().flush().unwrap();
        input.clear();
        std::io::stdin().read_line(&mut input).unwrap();
        let decompress = input.trim().to_lowercase() == "y";

        println!("\n{}", "Параметры загрузки:".cyan());
        println!("{}", format!("Шифрование: {}", if encrypted { "включено" } else { "выключено" }).yellow());
        println!("{}", format!("Публичный доступ: {}", if public { "да" } else { "нет" }).yellow());
        println!("{}", format!("Декомпрессия: {}", if decompress { "да" } else { "нет" }).yellow());
        println!();

        if is_directory {
            if let Err(e) = api.upload_directory(file_path.to_string(), encrypted, public, decompress).await {
                println!("{}", format!("[Peer] Ошибка при загрузке директории: {}", e).red());
            }
        } else {
            if let Err(e) = api.upload_file(file_path.to_string(), encrypted, public, decompress, "").await {
                println!("{}", format!("[Peer] Ошибка при загрузке файла: {}", e).red());
            } else {
                println!("{}", "[Peer] Файл успешно загружен".green());
            }
        }
    } else if connections_turn.read().await.len() > 0 {
        let connections = connections_turn.read().await;
        for (peer_id, _) in connections.iter() {
            if let Err(e) = api
                .send_message(peer_id.clone(), trimmed_input.to_string())
                .await
            {
                println!(
                    "{}",
                    format!("[Peer] Failed to send message to {}: {}", peer_id, e).red()
                );
            }
        }
    } else {
        println!("{}", format!("[Peer] Команда '{}' не найдена", trimmed_input).red());
    }
}


=== ../src\ui\mod.rs ===
mod console;

pub use console::{print_all_files,console_manager, print_welcome};